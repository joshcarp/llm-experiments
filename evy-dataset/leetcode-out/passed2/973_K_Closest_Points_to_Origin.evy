
func kClosest:[][]num points:[][]num K:num
    return nsmallest K points (lambda x: x[0] * x[0] + x[1] * x[1])
end

func nsmallest:[][]num K:num arr:[][]num key:func
    // heapify the array
    heapify arr key
    // extract K smallest elements
    result:[][]num
    for range K
        result = result + [arr[0]]
        arr = arr[1:]
        heapify arr key
    end
    return result
end

func heapify arr:[][]num key:func
    n := len arr
    for i := range (floor n/2)-1 -1 -1
        heapifyDown arr i n key
    end
end

func heapifyDown arr:[][]num i:num n:num key:func
    left := 2 * i + 1
    right := 2 * i + 2
    smallest := i
    if left < n and key(arr[left]) < key(arr[smallest])
        smallest = left
    end
    if right < n and key(arr[right]) < key(arr[smallest])
        smallest = right
    end
    if smallest != i
        tmp := arr[i]
        arr[i] = arr[smallest]
        arr[smallest] = tmp
        heapifyDown arr smallest n key
    end
end

func test
    assert [[1 1] [2 2]] (kClosest [[1 3] [2 2] [3 1]] 2)
    assert [[1 1] [2 2] [3 3]] (kClosest [[3 3] [5 -1] [1 1] [2 2]] 3)
end
test
