
func Solution:{}any
    self:{}any
    return self
end

func trap:num self:{}any height:[]num
    ls := len height
    if ls == 0
        return 0
    end
    res := 0
    left := 0
    while left < ls and height[left] == 0
        left = left + 1
    end
    pos := left + 1
    while pos < ls
        if height[pos] >= height[left]
            res = res + (self.rainWater height left pos)
            left = pos
            pos = pos + 1
        else if pos == ls - 1
            max_value := 0
            max_index := pos
            for index := range left + 1 ls
                if height[index] > max_value
                    max_value = height[index]
                    max_index = index
                end
            end
            res = res + (self.rainWater height left max_index)
            left = max_index
            pos = left + 1
        else
            pos = pos + 1
        end
    end
    return res
end

func rainWater:num self:{}any height:[]num start:num end:num
    if end - start <= 1
        return 0
    end
    min_m := min height[start] height[end]
    res := min_m * (end - start - 1)
    step := 0
    for index := range start + 1 end
        if height[index] > 0
            step = step + height[index]
        end
    end
    return res - step
end

func test
    s := (Solution)
    print (s.trap [2 6 3 8 2 7 2 5 0])
end
test

func min:num a:num b:num
    if a < b
        return a
    else
        return b
    end
end

func max:num a:num b:num
    if a > b
        return a
    else
        return b
    end
end
