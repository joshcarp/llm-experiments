
class Point:{}any
    self:{}any
    self.x := 0
    self.y := 0
    return self
end

func Point:Point a:num b:num
    self := (Point)
    self.x = a
    self.y = b
    return self
end

class Solution:{}any
    self:{}any
    return self
end

func maxPoints:num self:{}any points:[]Point
    if points == []
        return 0
    end
    ls := len points
    res := 0
    for i := range ls
        lineMap:{}num
        overlap := 0
        maxPoint := 0
        for j := range i+1 ls
            x := points[j].x - points[i].x
            y := points[j].y - points[i].y
            if x == 0 and y == 0
                overlap = overlap + 1
                continue
            end
            gcd := generateGCD self x y
            if gcd != 0
                x = x / gcd
                y = y / gcd
            end
            if has lineMap x
                if has lineMap[x] y
                    lineMap[x][y] = lineMap[x][y] + 1
                else
                    lineMap[x][y] = 1
                end
            else
                lineMap[x] = {}
                lineMap[x][y] = 1
            end
            maxPoint = max maxPoint lineMap[x][y]
        end
        res = max res (maxPoint + overlap + 1)
    end
    return res
end

func generateGCD:num self:{}any x:num y:num
    if y == 0
        return x
    else
        return generateGCD self y (x % y)
    end
end

func test
    p1 := (Point 1 1)
    p2 := (Point 2 2)
    p3 := (Point 3 3)
    p4 := (Point 1 3)
    p5 := (Point 2 1)
    p6 := (Point 3 2)
    p7 := (Point 1 1)
    p8 := (Point 2 2)
    p9 := (Point 3 3)
    p10 := (Point 1 3)
    p11 := (Point 2 1)
    p12 := (Point 3 2)
    sol := (Solution)
    assert 4 (sol.maxPoints [p1 p2 p3 p4 p5 p6])
    assert 4 (sol.maxPoints [p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12])
end
test
// output:
//line 9 column 1: invalid return type: a
//line 21 column 31: invalid type declaration for "points"
