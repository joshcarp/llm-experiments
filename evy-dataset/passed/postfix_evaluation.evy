
// Defining valid unary operator symbols
UNARY_OP_SYMBOLS := ["-" "+"]

// operators & their respective operation
OPERATORS := {
    "^": func p:num q:num
        return p^q
    end,
    "*": func p:num q:num
        return p * q
    end,
    "/": func p:num q:num
        return p / q
    end,
    "+": func p:num q:num
        return p + q
    end,
    "-": func p:num q:num
        return p - q
    end,
}


func parseToken:any token:any
    if token in OPERATORS
        return token
    end
    try
        return str2num token
    catch
        msg := sprintf "%v is neither a number nor a valid operator" token
        panic msg
    end
end


func evaluate:num postFix:[]string verbose:bool = false
    if (len postFix) == 0
        return 0
    end
    // Checking the list to find out whether the postfix expression is valid
    validExpression := [parseToken token for token in postFix]
    if verbose
        // print table header
        print "Symbol".center(8) "Action".center(12) "Stack" sep:" | "
        print "-" * (30 + (len postFix))
    end
    stack := []
    for x := range validExpression
        if !(x in OPERATORS)
            stack = stack + [x]  // append x to stack
            if verbose
                // output in tabular format
                print (sprintf "%v" x).rjust(8) (sprintf "push(%v)" x).ljust(12) stack sep:" | "
            end
            continue
        end
        // If x is operator
        // If only 1 value is inside the stack and + or - is encountered
        // then this is unary + or - case
        if x in UNARY_OP_SYMBOLS and (len stack) < 2
            b := stack[-1]  // pop stack
            stack = stack[:-1]
            if x == "-"
                b = b * -1  // negate b
            end
            stack = stack + [b]
            if verbose
                // output in tabular format
                print "".rjust(8) (sprintf "pop(%v)" b).ljust(12) stack sep:" | "
                print (sprintf "%v" x).rjust(8) (sprintf "push(%v%v)" x b).ljust(12) stack sep:" | "
            end
            continue
        end
        b := stack[-1]  // pop stack
        stack = stack[:-1]
        if verbose
            // output in tabular format
            print "".rjust(8) (sprintf "pop(%v)" b).ljust(12) stack sep:" | "
        end

        a := stack[-1]  // pop stack
        stack = stack[:-1]
        if verbose
            // output in tabular format
            print "".rjust(8) (sprintf "pop(%v)" a).ljust(12) stack sep:" | "
        end
        // evaluate the 2 values popped from stack & push result to stack
        stack = stack + [OPERATORS[x](a, b)]  // type: ignore[index]
        if verbose
            // output in tabular format
            print (sprintf "%v" x).rjust(8) (sprintf "push(%v%v%v)" a x b).ljust(12) stack sep:" | "
        end
    end
    // If everything is executed correctly, the stack will contain
    // only one element which is the result
    if (len stack) != 1
        panic "Input is not a valid postfix expression"
    end
    return stack[0]
end


func main
    // Create a loop so that the user can evaluate postfix expressions multiple times
    while true
        expression := split (read "Enter a Postfix Expression (space separated): ") " "
        prompt := "Do you want to see stack contents while evaluating? [y/N]: "
        verbose := (read prompt).strip().lower() == "y"
        output := evaluate expression verbose
        print "Result = " output
        prompt := "Do you want to enter another expression? [y/N]: "
        if (read prompt).strip().lower() != "y"
            break
        end
    end
end
