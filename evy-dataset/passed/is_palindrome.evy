
func ListNode:{}any
    self:{}any
    self.val := 0
    self.next_node := nil
    return self
end

func isPalindrome:bool head:{}any
    if head == nil
        return true
    end
    # split the list to two parts
    fast:{}any
    slow:{}any
    fast = head.next_node
    slow = head
    while fast != nil and fast.next_node != nil
        fast = fast.next_node.next_node
        slow = slow.next_node if slow != nil else nil
    end
    if slow != nil
        # slow will always be defined,
        # adding this check to resolve mypy static check
        second := slow.next_node
        slow.next_node = nil  # Don't forget here! But forget still works!
    end
    # reverse the second part
    node:{}any
    while second != nil
        nxt := second.next_node
        second.next_node = node
        node = second
        second = nxt
    end
    # compare two parts
    # second part has the same or one less node
    while node != nil and head != nil
        if node.val != head.val
            return false
        end
        node = node.next_node
        head = head.next_node
    end
    return true
end

func isPalindromeStack:bool head:{}any
    if head == nil or head.next_node == nil
        return true
    end
    # 1. Get the midpoint (slow)
    slow:{}any
    fast:{}any
    slow = head
    fast = head
    while fast != nil and fast.next_node != nil
        fast = fast.next_node.next_node
        slow = slow.next_node if slow != nil else nil
    end
    # slow will always be defined,
    # adding this check to resolve mypy static check
    if slow != nil
        stack := [slow.val]
        # 2. Push the second half into the stack
        while slow.next_node != nil
            slow = slow.next_node
            stack = stack + [slow.val]
        end
        # 3. Comparison
        cur:{}any
        cur = head
        while (len stack) > 0 and cur != nil
            if stack[-1] != cur.val
                return false
            end
            stack = stack[:-1]
            cur = cur.next_node
        end
    end
    return true
end

func isPalindromeDict:bool head:{}any
    if head == nil or head.next_node == nil
        return true
    end
    d:{}any
    d = {}
    pos := 0
    while head != nil
        if has d head.val
            d[head.val] = d[head.val] + [pos]
        else
            d[head.val] = [pos]
        end
        head = head.next_node
        pos = pos + 1
    end
    checksum := pos - 1
    middle := 0
    for v := range d
        if (len d[v]) % 2 != 0
            middle = middle + 1
        else
            for step := range (len d[v])
                i := step
                if d[v][i] + d[v][(len d[v]) - 1 - step] != checksum
                    return false
                end
            end
        end
        if middle > 1
            return false
        end
    end
    return true
end

func test
    assert true==(isPalindrome nil)
    assert true==(isPalindrome (ListNode 1))
    assert false==(isPalindrome (ListNode 1 (ListNode 2)))
    assert true==(isPalindrome (ListNode 1 (ListNode 2 (ListNode 1))))
    assert true==(isPalindrome (ListNode 1 (ListNode 2 (ListNode 2 (ListNode 1))))
    assert true==(isPalindromeStack nil)
    assert true==(isPalindromeStack (ListNode 1))
    assert false==(isPalindromeStack (ListNode 1 (ListNode 2)))
    assert true==(isPalindromeStack (ListNode 1 (ListNode 2 (ListNode 1))))
    assert true==(isPalindromeStack (ListNode 1 (ListNode 2 (ListNode 2 (ListNode 1))))
    assert true==(isPalindromeDict nil)
    assert true==(isPalindromeDict (ListNode 1))
    assert false==(isPalindromeDict (ListNode 1 (ListNode 2)))
    assert true==(isPalindromeDict (ListNode 1 (ListNode 2 (ListNode 1))))
    assert true==(isPalindromeDict (ListNode 1 (ListNode 2 (ListNode 2 (ListNode 1))))
    assert false==(isPalindromeDict (ListNode 1 (ListNode 2 (ListNode 1 (ListNode 3 (ListNode 2 (ListNode 1)))))))
end
test
