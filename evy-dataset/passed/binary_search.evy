
func bisectLeft:[]num sortedCollection:[]num item:num lo:num hi:num
    if hi < 0
        hi = len sortedCollection
    end
    while lo < hi
        mid := lo + (hi - lo) / 2
        if sortedCollection[mid] < item
            lo = mid + 1
        else
            hi = mid
        end
    end
    return lo
end

func bisectRight:[]num sortedCollection:[]num item:num lo:num hi:num
    if hi < 0
        hi = len sortedCollection
    end
    while lo < hi
        mid := lo + (hi - lo) / 2
        if sortedCollection[mid] <= item
            lo = mid + 1
        else
            hi = mid
        end
    end
    return lo
end

func insortLeft sortedCollection:[]num item:num lo:num hi:num
    sortedCollection = sortedCollection[:bisectLeft sortedCollection item lo hi] + [item] + sortedCollection[bisectLeft sortedCollection item lo hi:]
end

func insortRight sortedCollection:[]num item:num lo:num hi:num
    sortedCollection = sortedCollection[:bisectRight sortedCollection item lo hi] + [item] + sortedCollection[bisectRight sortedCollection item lo hi:]
end

func binarySearch:num sortedCollection:[]num item:num
    if sortedCollection != sort sortedCollection
        panic "sortedCollection must be sorted in ascending order"
    end
    left := 0
    right := len sortedCollection - 1
    while left <= right
        midpoint := left + (right - left) / 2
        current_item := sortedCollection[midpoint]
        if current_item == item
            return midpoint
        else if item < current_item
            right = midpoint - 1
        else
            left = midpoint + 1
        end
    end
    return -1
end

func binarySearchStdLib:num sortedCollection:[]num item:num
    if sortedCollection != sort sortedCollection
        panic "sortedCollection must be sorted in ascending order"
    end
    index := bisectLeft sortedCollection item
    if index != len sortedCollection and sortedCollection[index] == item
        return index
    end
    return -1
end

func binarySearchByRecursion:num sortedCollection:[]num item:num left:num right:num
    if right < 0
        right = len sortedCollection - 1
    end
    if sortedCollection != sort sortedCollection
        panic "sortedCollection must be sorted in ascending order"
    end
    if right < left
        return -1
    end
    midpoint := left + (right - left) / 2
    if sortedCollection[midpoint] == item
        return midpoint
    else if sortedCollection[midpoint] > item
        return binarySearchByRecursion sortedCollection item left (midpoint - 1)
    else
        return binarySearchByRecursion sortedCollection item (midpoint + 1) right
    end
end

func exponentialSearch:num sortedCollection:[]num item:num
    if sortedCollection != sort sortedCollection
        panic "sortedCollection must be sorted in ascending order"
    end
    bound := 1
    while bound < len sortedCollection and sortedCollection[bound] < item
        bound = bound * 2
    end
    left := bound / 2
    right := min bound (len sortedCollection - 1)
    lastResult := binarySearchByRecursion sortedCollection item left right
    if lastResult == -1
        return -1
    end
    return lastResult
end

func sort arr:[]num
    // bubble sort
    for endIdx := range (len arr)-1 0 -1
        for i := range endIdx
            if arr[i] > arr[i + 1]
                tmp := arr[i]
                arr[i] = arr[i + 1]
                arr[i + 1] = tmp
            end
        end
    end
    return arr
end

func min:num a:num b:num
    if a < b
        return a
    end
    return b
end

searches := [binarySearchStdLib binarySearch exponentialSearch binarySearchByRecursion]

func main
    import doctest
    import timeit
    doctest.testmod()
    for search := range searches
        name := sprintf "%26s" (search.name)
        print (sprintf "%s: %s = %v\n" name (search.name) (search [0 5 7 10 15] 10))
    end
    print "\nBenchmarks...\n"
    setup := "collection := range 1000"
    for search := range searches
        name := search.name
        print (sprintf "%26s: %v\n" name (timeit.timeit (sprintf "%s(collection, 500)" name) setup 5000 globals))
    end
    user_input := read "Enter numbers separated by comma: "
    collection := sort (numArr (split user_input ","))
    target := str2num (read "Enter a single number to be found in the list: ")
    result := binarySearch sortedCollection:collection item:target
    if result == -1
        print (sprintf "%v was not found in %v.\n" target collection)
    else
        print (sprintf "%v was found at position %v of %v.\n" target result collection)
    end
end

func numArr:[]num s:{}bool
    result:[]num
    for k := range s
        n := str2num k
        result = result + [n]
    end
    return result
end
