
func ListNode:{}any val:num next:{}any
    self:{}any
    self.val = val
    self.next = next
    return self
end

func Solution:{}any
    self:{}any
    return self
end

func isPalindrome:bool self:{}any head:{}any
    if head == {}
        return true
    end
    p1:{}any
    p2:{}any
    p3:{}any
    pre:{}any
    p1 = head
    p2 = head
    p3 = head.next
    pre = p1
    while (has p2 "next") and (has p2.next "next")
        p2 = p2.next.next
        pre = p1
        p1 = p3
        p3 = p3.next
        p1.next = pre
    end
    if (has p2 "next") and p2.next == {}
        p1 = p1.next
    end
    while (has p3 "val")
        if p1.val != p3.val
            return false
        end
        p1 = p1.next
        p3 = p3.next
    end
    return true
end

func test
    head := (ListNode 1 (ListNode 2 (ListNode 3 (ListNode 4 (ListNode 5 {})))))
    sol := (Solution)
    assert true==(isPalindrome sol head)
    head = (ListNode 1 (ListNode 2 (ListNode 2 (ListNode 1 {}))))
    assert true==(isPalindrome sol head)
    head = (ListNode 1 (ListNode 2 (ListNode 3 (ListNode 3 (ListNode 1 {})))))
    assert false==(isPalindrome sol head)
end
test
// output:
//line 24 column 5: "p3" accepts values of type {}any, found any
//line 26 column 38: "has" takes 1st argument of type {}, found any
//line 27 column 21: field access with "." expects map type, found any
//line 30 column 9: "p3" accepts values of type {}any, found any
//line 33 column 36: mismatched type for ==: any, {}
//line 34 column 9: "p1" accepts values of type {}any, found any
//line 40 column 9: "p1" accepts values of type {}any, found any
//line 41 column 9: "p3" accepts values of type {}any, found any
//line 14 column 24: "self" declared but not used
