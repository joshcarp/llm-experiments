
func ladderLength:num beginWord:string endWord:string wordList:[]string
    wordList = wordList[:]
    wordList.discard beginWord
    wordList.discard endWord
    hash_map:{}any
    res := 0
    res = bfs (set [beginWord]) (set [endWord]) wordList 2
    return res
end

func bfs:num forward:{}string backward:{}string wordlist:[]string level:num
    if (len forward) == 0 or (len backward) == 0
        return 0
    end
    if (len forward) > (len backward)
        return bfs backward forward wordlist level
    end
    is_connected := false
    next_level:{}string
    for word := range forward
        for c := range "abcdefghijklmnopqrstuvwxyz"
            for i := range (len word)
                neigh := word[:i] + c + word[i + 1:]
                if has backward neigh
                    is_connected = true
                    return level
                end
                if !(is_connected) and has wordlist neigh
                    next_level.add neigh
                    wordlist.discard neigh
                end
            end
        end
    end
    if !(is_connected)
        return bfs next_level backward wordlist (level + 1)
    end
    return 0
end

func test
    assert 5 (ladderLength "hit" "cog" ["hot" "dot" "dog" "lot" "log"])
    assert 2 (ladderLength "a" "b" ["a" "b" "c"])
    assert 2 (ladderLength "hot" "dog" ["hot" "dog"])
    assert 5 (ladderLength "qa" "sq" ["si" "go" "se" "cm" "so" "ph" "mt" "db" "mb" "sb" "kr" "ln" "tm" "le" "av" "sm" "ar" "ci" "ca" "br" "ti" "ba" "to" "ra" "fa" "yo" "ow" "sn" "ya" "cr" "po" "fe" "ho" "ma" "re" "or" "rn" "au" "ur" "rh" "sr" "tc" "lt" "lo" "as" "fr" "nb" "yb" "if" "pb" "ge" "th" "pm" "rb" "sh" "co" "ga" "li" "ha" "hz" "no" "bi" "di" "hi" "qa" "pi" "os" "uh" "wm" "an" "me" "mo" "na" "la" "st" "er" "sc" "ne" "mn" "mi" "am" "ex" "pt" "io" "be" "fm" "ta" "tb" "ni" "mr" "pa" "he" "lr" "sq" "ye"])
    assert 4 (ladderLength "hot" "dog" ["hot" "cog" "dog" "tot" "hog" "hop" "pot" "dot"])
end
test
