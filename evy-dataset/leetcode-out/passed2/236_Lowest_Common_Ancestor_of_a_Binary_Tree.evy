
func Node:{}any
    self:{}any
    self.val = 0
    self.left = {}
    self.right = {}
    return self
end

func Solution:{}any
    self:{}any
    return self
end

func lowestCommonAncestor self:{}any root:{}any p:{}any q:{}any
    stack := [root]
    parent := {root: {}}
    while !(has parent (sprintf "%v" p)) or !(has parent (sprintf "%v" q))
        node:{}any
        node = stack[-1].({}any)
        stack = stack[:-1]
        if (has node "left") and node["left"].({}any) != {}
            parent[(sprintf "%v" node["left"])] = node
            stack = stack + [node["left"]]
        end
        if (has node "right") and node["right"].({}any) != {}
            parent[(sprintf "%v" node["right"])] = node
            stack = stack + [node["right"]]
        end
    end
    ancestors := {}
    while p != {}
        ancestors[(sprintf "%v" p)] = true
        p = parent[(sprintf "%v" p)].({}any)
    end
    while !(has ancestors (sprintf "%v" q))
        q = parent[(sprintf "%v" q)].({}any)
    end
    return q
end

func test
    root := (Node)
    root.val = 3
    root.left = (Node)
    root.left.val = 5
    root.left.left = (Node)
    root.left.left.val = 6
    root.left.right = (Node)
    root.left.right.val = 2
    root.left.right.left = (Node)
    root.left.right.left.val = 7
    root.left.right.right = (Node)
    root.left.right.right.val = 4
    root.right = (Node)
    root.right.val = 1
    root.right.left = (Node)
    root.right.left.val = 0
    root.right.right = (Node)
    root.right.right.val = 8
    p := root.left.right.left.({}any)
    q := root.right.({}any)
    sol := (Solution)
    lca := lowestCommonAncestor sol root p q
    assert 3 (lca.val)
end
test
