filename,content,python
stringart.evy,"// String art
// Inpsired by https://youtu.be/dLiSXcaBZmk

pi := 3.141592654

lissajousA := 0
lissajousB := 0
lissajousPct := 0
thetaOffset := 0
nails:[][]num

func drawall
    draw 80 0.05 0.05 1 20
    sleep 3
    draw 80 0 0.05 2 1
    sleep 3
    draw 160 0 0.05 2 1
    sleep 3
    draw 160 0 0.05 4 1
    sleep 3
    drawAnimate 80 0.02
    sleep 3
    drawlAnimate 120 2 1 270 pi/4 0.02
end

func draw n:num dotInterval:num cordInterval:num a:num c:num
    setnails n 0 0 0 0
    clear ""black""
    drawNails dotInterval
    drawCords a c cordInterval
end

func drawl n:num a:num b:num pct:num toffset:num
    setnails n a b pct toffset
    clear ""black""
    drawNails 0
    drawCords 1 n/4 0
end

func drawAnimate n:num interval:num
    for i := range n*2
        draw n 0 0 1 i+1
        sleep interval
    end
end

func drawlAnimate n:num a:num b:num steps:num toffset:num interval:num
    for p := range steps -1 -1
        pct := p / steps
        drawl n a b pct toffset*(1 - pct)
        sleep interval
    end
end

func drawNails interval:num
    for i := range (len nails)
        nail i
        sleep interval
    end
end

func drawCords a:num c:num interval:num
    for i := range (len nails)
        j := a * i + c
        cord i j
        nail i
        nail j
        sleep interval
    end
end

func nail n:num
    color ""orange""
    xy := pos n
    move xy[0] xy[1]
    circle 0.6
end

func cord i:num j:num
    ixy := pos i
    jxy := pos j
    color ""lightgreen""
    width 0.3
    move ixy[0] ixy[1]
    line jxy[0] jxy[1]
end

func pos:[]num n:num
    return nails[n % (len nails)]
end

func setnails n:num a:num b:num pct:num toffset:num
    if (len nails) == n and lissajousA == a and lissajousB == b and lissajousPct == pct and thetaOffset == toffset
        // No change to computed nail positions
        return
    end
    lissajousA = a
    lissajousB = b
    lissajousPct = pct
    thetaOffset = toffset
    nails = []
    for i := range n
        theta := thetaOffset + (pi * 2 * i / n)
        nails = nails + [(calcpos theta)]
    end
end

func calcpos:[]num theta:num
    cpos := circlePos theta
    lpos := lissajousPos theta
    x := interpolate lpos[0] cpos[0] lissajousPct
    y := interpolate lpos[1] cpos[1] lissajousPct
    return [(toCanvas x) (toCanvas y)]
end

func circlePos:[]num theta:num
    x := cos theta
    y := sin theta
    return [x y]
end

func lissajousPos:[]num theta:num
    x := sin lissajousA*theta
    y := sin lissajousB*theta
    return [x y]
end

func toCanvas:num n:num
    return n * 40 + 50
end

func interpolate:num a:num b:num pct:num
    return a * pct + b * (1 - pct)
end

// Still working on this one
// drawlAnimate 80 1 4 100 0 0.02

drawall
",
movingdot.evy,"for i := range 0 100 0.1
    clear
    dot i 50

    sleep 0.01
end

func dot x:num y:num
    color ""red""
    move x y
    circle 10
end
",
bounce.evy,"background := ""hsl(0deg 0% 0% / 10%)""
x := 10
y := 50
s := 1
width 1
fill background
stroke ""red""

on animate
    clear background
    move x y
    circle 10
    x = x + s
    if x < 10 or x > 90
        s = -s
    end
end
",
juggle.evy,"// increase `s` for highter speed
// try 5.1 vs 5 to visualize rounding errors
s := 0.5
radius := 5

colors := [""red"" ""orange"" ""gold"" ""forestgreen"" ""blue"" ""indigo"" ""purple"" ""deeppink""]
dots := [
    {x:(pos 0) y:(pos 2) dx:s dy:s}
    {x:(pos 1) y:(pos 3) dx:s dy:s}
    {x:(pos 2) y:(pos 4) dx:s dy:-s}
    {x:(pos 3) y:(pos 3) dx:s dy:-s}
    {x:(pos 4) y:(pos 2) dx:-s dy:-s}
    {x:(pos 3) y:(pos 1) dx:-s dy:-s}
    {x:(pos 2) y:(pos 0) dx:-s dy:s}
    {x:(pos 1) y:(pos 1) dx:-s dy:s}
]

for i := range (len dots)
    dots[i].radius = radius
    dots[i].color = i
end

func pos:num i:num
    l := (100 - 2 * radius) / 4
    return radius + i * l
end

on animate
    clear

    for dot := range dots
        update dot
        draw dot colors[dot.color]
    end
end

func update dot:{}num
    dot.x = dot.x + dot.dx
    dot.y = dot.y + dot.dy
    dot.dx = delta dot.dx dot.x
    dot.dy = delta dot.dy dot.y
end

func delta:num d:num n:num
    if n >= radius and n < 100 - radius
        return d
    end
    return -d
end

func draw dot:{}num col:string
    color col
    move dot.x dot.y
    circle dot.radius
end
",
splashtrig.evy,"sa := -0.007
sb := -0.006
sc := -0.005
sd := -0.004
se := -0.003
radius := 5

pi := 3.141593
tau := 2 * pi

colors := [
    ""red"" ""orange"" ""gold"" ""forestgreen"" ""blue"" ""indigo"" ""purple"" ""deeppink""
]
dots := [
    {phase:(0 / 8) orbit:10 s:sa}
    {phase:(1 / 8) orbit:10 s:sa}
    {phase:(2 / 8) orbit:10 s:sa}
    {phase:(3 / 8) orbit:10 s:sa}
    {phase:(4 / 8) orbit:10 s:sa}
    {phase:(5 / 8) orbit:10 s:sa}
    {phase:(6 / 8) orbit:10 s:sa}
    {phase:(7 / 8) orbit:10 s:sa}
    {phase:(0 / 8) orbit:20 s:sb}
    {phase:(1 / 8) orbit:20 s:sb}
    {phase:(2 / 8) orbit:20 s:sb}
    {phase:(3 / 8) orbit:20 s:sb}
    {phase:(4 / 8) orbit:20 s:sb}
    {phase:(5 / 8) orbit:20 s:sb}
    {phase:(6 / 8) orbit:20 s:sb}
    {phase:(7 / 8) orbit:20 s:sb}
    {phase:(0 / 8) orbit:30 s:sc}
    {phase:(1 / 8) orbit:30 s:sc}
    {phase:(2 / 8) orbit:30 s:sc}
    {phase:(3 / 8) orbit:30 s:sc}
    {phase:(4 / 8) orbit:30 s:sc}
    {phase:(5 / 8) orbit:30 s:sc}
    {phase:(6 / 8) orbit:30 s:sc}
    {phase:(7 / 8) orbit:30 s:sc}
    {phase:(0 / 8) orbit:40 s:sd}
    {phase:(1 / 8) orbit:40 s:sd}
    {phase:(2 / 8) orbit:40 s:sd}
    {phase:(3 / 8) orbit:40 s:sd}
    {phase:(4 / 8) orbit:40 s:sd}
    {phase:(5 / 8) orbit:40 s:sd}
    {phase:(6 / 8) orbit:40 s:sd}
    {phase:(7 / 8) orbit:40 s:sd}
    {phase:(0 / 8) orbit:50 s:se}
    {phase:(1 / 8) orbit:50 s:se}
    {phase:(2 / 8) orbit:50 s:se}
    {phase:(3 / 8) orbit:50 s:se}
    {phase:(4 / 8) orbit:50 s:se}
    {phase:(5 / 8) orbit:50 s:se}
    {phase:(6 / 8) orbit:50 s:se}
    {phase:(7 / 8) orbit:50 s:se}
]

for i := range (len dots)
    dots[i].radius = radius
    dots[i].color = i
end

on animate
    // 2% opacity leaves trails on movement
    clear ""hsl(0deg 100% 100% / 2%)""

    for dot := range dots
        update dot
        draw dot colors[dot.color % (len colors)]
    end
end

func update dot:{}num
    dot.phase = dot.phase + dot.s
end

func draw dot:{}num col:string
    color col
    x := 50 + dot.orbit * (cos (tau * dot.phase))
    y := 50 + dot.orbit * (sin (tau * dot.phase))
    move x y
    circle dot.radius
end
",
welcome.evy,"move 10 20
line 50 50
rect 25 25
color ""red""
circle 10

x := 12
print ""x:"" x
if x > 10
    print ""🍦 big x""
end
",
math.evy,"pi := 3.14159265
e := 2.718281828459045

print ""rand1"" (rand1)
print ""rand 10"" (rand 10)
print
print ""min 3 2:"" (min 3 2)
print ""max 3 2:"" (max 3 2)
print
print ""floor 2.6:"" (floor 2.6)
print ""ceil 2.4:"" (floor 2.4)
print ""round 2.6:"" (round 2.6)
print
print ""pow 2 3:"" (pow 2 3)
print ""log e:"" (log e)
print ""sqrt 2:"" (sqrt 2)
print
print ""sin pi:"" (sin pi)
print ""cos pi:"" (cos pi)
print ""atan2 0 0:"" (atan2 0 0)
",
strings.evy,"s := ""Hello World!""

print ""s:"" s
print ""s+s:"" s+s
print ""s[1:-1]:"" s[1:-1]
print
print ""upper s:"" (upper s)
print ""lower s:"" (lower s)
print ""index s \""e\"":"" (index s ""e"")
print
print ""startswith \""Hello\"":"" (startswith s ""Hello"")
print ""startswith \""hello\"":"" (startswith s ""hello"")
print ""endswith \""World!\"":"" (endswith s ""World!"")
print ""endswith \""World\"": "" (endswith s ""World"")
print
print ""replace s \""l\"" \""L\"":"" (replace s ""l"" ""L"")
print ""trim s \""H!\"":"" (trim s ""H!"")
",
helloworld.evy,"print ""👋🌏 Hello, World!""
",
echo.evy,"print ""Write something, press enter and enjoy the echo.""
while true
    s := read
    print s s s
end
",
events.evy,"x := 50
y := 50
dy := 2
radius := 5
stopped := false
speed := 0.5
hue := 0

dot x y radius hue

on animate
    if stopped
        return
    end
    clear
    y = y + dy * speed
    dot x y radius hue
    if y >= 100 - radius or y <= radius
        dy = dy * -1
    end
end

on key k:string
    print ""key"" k
    if k == "" ""
        stopped = !stopped
    else if k == ""ArrowUp""
        hue = hue + 5
    else if k == ""ArrowDown""
        hue = hue - 5
    end
    dot x y radius hue
end

// update x position with x-slider
// update speed with y-slider
on input id:string val:string
    if id == ""sliderx""
        x = str2num val
    else
        s := str2num val
        speed = s * 0.01
    end
    dot x y radius hue
end

func dot x:num y:num radius:num hue:num
    hsl hue 100 50
    move x y
    circle radius
end

func hsl hue:num sat:num light:num
    s := sprintf ""hsl(%.0fdeg %.0f%% %.0f%%)"" hue%360 sat light
    color s
end
",
coords.evy,"grid
print ""Move mouse or touch to print coordinates""

on move x:num y:num
    print ""x:"" (round x) ""y:"" (round y)
end
",
draw.evy,"down := false
width 1

on down x:num y:num
    down = true
    move x y
end

on up
    down = false
end

on move x:num y:num
    if down
        line x y
    end
end
",
ellipse.evy,"labels := [""x"" ""y"" ""radX"" ""radY"" ""rot°"" ""start°"" ""end°""]
vals := [50 60 30 17 5 0 180]
cnt := len vals
cur := 1
w := 11

print ""Watermelon, anyone?""
print ""🍉""
print ""Use arrow keys or drag numbers""
print ""for your perfect piece.""

draw

func draw
    clear ""hsl(210deg 5% 15%)"" // near black
    drawEllipse
    drawText
    drawHighlight cur
end

func drawEllipse
    width 2
    fill ""red""
    stroke ""darkgreen""
    ellipse vals[0] vals[1] vals[2] vals[3] vals[4] vals[5] vals[6]
end

func drawText
    font {size:2.7 style:""italic"" family:""Fira Code, monospace""}
    width 0.2
    fill ""hsl(210deg 13% 72%)"" // light grey
    move 2 15
    text ""// ""
    for i := range (len labels)
        move i*w+20 15
        text (sprintf ""%5s"" labels[i])
    end
    font {size:2.7 style:""normal""}
    fill ""hsl(27deg 100% 74%)"" // orange
    move 2 10
    text ""ellipse""
    fill ""hsl(204deg 100% 75%)"" // ligth  blue
    for i := range (len labels)
        move i*w+20 10
        text (sprintf ""%5.0f"" vals[i])
    end

end

func drawHighlight i:num
    fill ""none""
    stroke ""white""
    width 0.4
    x := i * w + 20
    move x-1 9
    rect 10 4
end

// keyboard interaction
on key k:string
    if k == ""ArrowLeft""
        cur = (cur + cnt - 1) % cnt
    else if k == ""ArrowRight""
        cur = (cur + 1) % cnt
    else if k == ""ArrowUp""
        vals[cur] = vals[cur] + 1
    else if k == ""ArrowDown""
        vals[cur] = max 0 vals[cur]-1
    end
    draw
end

// pointer interaction

dragy := -1
deltay := 0

on down x:num y:num
    if y < 20 and x > 18
        cur = min (floor (x - 18)/w) (len labels)-1
        dragy = y
        draw
    end
end

on up
    dragy = -1
    deltay = 0
end

on move x:num y:num
    if dragy == -1
        return
    end
    if x == 0 or x == 100 or y == 0 or y == 100
        // stop animation when we leave the canvas
        dragy = -1
        deltay = 0
        return
    end
    deltay = y - dragy
    if deltay < 0
        deltay = floor deltay
    else
        deltay = ceil deltay
    end
end

on animate
    if deltay == 0
        return
    end
    if cur < 4
        val := vals[cur] + deltay / 10
        vals[cur] = max 0 (min 100 val)
    else
        vals[cur] = vals[cur] + deltay / 5
    end
    draw
end
",
tictactoetext.evy,"// x - bot
// o - human

playGame ""x"" (selectStrength)

func selectStrength:num
    print ""Select strength 1-3.""
    while true
        str := read
        n := str2num str
        if !err and n >= 1 and n <= 3
            return n
        end
        printf ""💣 %q is not a valid strength (1-3). Try again.\n"" str
    end
    return -1
end

func playGame turn:string strength:num
    board := newBoard
    printAll strength board
    while !(isGameover board)
        if turn == ""x""
            botTurn board strength
        else
            humanTurn board
        end
        printAll strength board
        turn = next turn
    end
    result := winner board
    if result == "".""
        print ""Tie.""
    else
        printf ""%q wins.\n"" result
    end
end

func newBoard:[]string
    return [
        ""."" ""."" "".""
        ""."" ""."" "".""
        ""."" ""."" "".""
    ]
end

func isGameover:bool b:[]string
    return (emptyCnt b) == 0 or (winner b) != "".""
end

func next:string turn:string
    if turn == ""o""
        return ""x""
    end
    return ""o""
end

func emptyCnt:num b:[]string
    cnt := 0
    for i := range 9
        if b[i] == "".""
            cnt = cnt + 1
        end
    end
    return cnt
end

func winner:string b:[]string
    if b[0] != ""."" and ((b[1] == b[0] and b[2] == b[0]) or (b[4] == b[0] and b[8] == b[0]) or (b[3] == b[0] and b[6] == b[0]))
        return b[0]
    end
    if b[4] != ""."" and ((b[1] == b[4] and b[7] == b[4]) or (b[3] == b[4] and b[5] == b[4]) or (b[2] == b[4] and b[6] == b[4]))
        return b[4]
    end
    if b[8] != ""."" and ((b[6] == b[8] and b[7] == b[8]) or (b[2] == b[8] and b[5] == b[8]))
        return b[8]
    end
    return ""."" // no winner
end

func printAll strength:num b:[]string
    cls
    printNotes strength
    printBoard b
end

func printNotes strength:num
    printf ""Strength %0.f.\n\n"" strength
    print ""Enter index for \""o\"" move:""
    print ""0 1 2""
    print ""3 4 5""
    print ""6 7 8\n""
end

func printBoard b:[]string
    print b[0] b[1] b[2]
    print b[3] b[4] b[5]
    print b[6] b[7] b[8]
    print
end

func humanTurn b:[]string
    while true
        str := read
        n := str2num str
        if !err and n <= 8 and n >= 0 and b[n] == "".""
            b[n] = ""o""
            return
        end
        printf ""💣 %q is not a valid move (0-8, free fields). Try again.\n"" str
    end
end

func botTurn b:[]string strength:num
    if strength == 1
        bot1Turn b
    else if strength == 2
        bot2Turn b
    else
        bot3Turn b
    end
end

func bot1Turn b:[]string
    target := rand (emptyCnt b)
    cnt := 0
    for i := range 9
        if b[i] == "".""
            if target == cnt
                b[i] = ""x""
                return
            end
            cnt = cnt + 1
        end
    end
end

func bot2Turn b:[]string
    // try to win in next move
    for i := range 9
        if b[i] == "".""
            b[i] = ""x""
            if (winner b) == ""x""
                return
            end
            b[i] = "".""
        end
    end
    // try to stop ""o"" from winning in next move
    for i := range 9
        if b[i] == "".""
            b[i] = ""o""
            if (winner b) == ""o""
                b[i] = ""x""
                return
            end
            b[i] = "".""
        end
    end
    // random move if no win or block possible
    bot1Turn b
end

func bot3Turn b:[]string
    e := emptyCnt b
    if e == 9
        bot1Turn b
    else if e == 8 and b[4] == "".""
        b[4] = ""x""
    else if e == 8 // ""o"" on 4
        corners := [0 2 6 8]
        i := corners[rand 4]
        b[i] = ""x""
    else
        minmax b ""x"" 0
    end
end

func minmax:num b:[]string turn:string depth:num
    if (isGameover b)
        return score b depth
    end
    scores:[]num
    moves:[]num
    b2 := b[:]
    turn2 := next turn
    for i := range 9
        if b[i] == "".""
            b2[i] = turn
            scores = scores + [(minmax b2 turn2 depth+1)]
            moves = moves + [i]
            b2[i] = "".""
        end
    end

    idx:num
    if turn == ""x""
        idx = maxIndex scores
    else
        idx = minIndex scores
    end
    if depth == 0
        b[moves[idx]] = turn
    end
    return scores[idx]
end

func score:num b:[]string depth:num
    w := winner b
    if w == ""x""
        return 10 - depth
    else if w == ""o""
        return -10 + depth
    end
    return 0
end

func minIndex:num nums:[]num
    nmin := nums[0]
    idx := 0
    for i := range 1 (len nums)
        if nums[i] < nmin
            nmin = nums[i]
            idx = i
        end
    end
    return idx
end

func maxIndex:num nums:[]num
    nmax := nums[0]
    idx := 0
    for i := range 1 (len nums)
        if nums[i] > nmax
            nmax = nums[i]
            idx = i
        end
    end
    return idx
end
",
rand.evy,"while true
    print ""╔════════════════════════╗""
    print ""║ Guess my number (1-10) ║""
    print ""╚════════════════════════╝""

    n := 1 + (rand 10)
    guess := readn

    while guess != n
        if guess < n
            print guess ""Guess higher.""
        else
            print guess ""Guess lower.""
        end
        guess = readn
    end
    print guess ""You got it 🥳.""
    sleep 2
    cls
end

// readn reads a number.
// If the input is not a number readn
// prints an error and repeats prompt.
func readn:num
    while true
        str := read
        n := str2num str
        if !err
            return n
        end
        print ""💣 '""+str+""'is not a number. Try again.""
    end
    return -1
end
",
hanoi.evy,"// towers of hanoi

colors := [""red"" ""orange"" ""gold"" ""green"" ""blue"" ""darkviolet"" ""violet"" ""black""]
towers := [
    []
    [8 7 6 5 4 3 2 1]
    []
]

selected := -1
startTower := 1
numPieces := (len towers[startTower])

// Drawing / positioning
towerx := [17 50 83]
w := 5 // line width
basey := 20
font {align:""center"" baseline:""top""}

width w
linecap ""round""

func drawTowers
    clear ""white""
    color ""black""
    move 0 basey-(w / 2)
    line 100 basey-(w / 2)
    for tower := range 3
        x := towerx[tower]
        color ""black""
        move x basey
        line x basey+42
        if tower == 2
            text ""✨""
        end
        for n := range (len towers[tower])
            y := n * w + (w / 2) + basey
            if tower == selected and n == (len towers[tower]) - 1
                y = y + w
            end
            piece := towers[tower][n]
            pieceWidth := piece * 3 + 5
            color colors[piece - 1]
            move x-(pieceWidth / 2) y
            line x+(pieceWidth / 2) y
        end
    end
end

on down x:num _:num
    tower := floor x/100*3
    if selected == -1 and (len towers[tower]) == 0
        cls
        print ""No pieces on that tower!""
        return
    else if selected == -1
        selected = tower
    else if selected == tower
        selected = -1
    else
        movePiece selected tower
        selected = -1
    end
    drawTowers
    checkGameover tower
end

func movePiece from:num to:num
    if (len towers[to]) > 0 and towers[from][-1] > towers[to][-1]
        cls
        print ""Piece too big to move there.""
        return
    end
    towers[to] = towers[to] + [towers[from][-1]]
    towers[from] = towers[from][:-1]
end

func checkGameover tower:num
    if tower == 2 and (len towers[tower]) == numPieces
        cls
        print ""Well done! 🥳""
        exit 0
    end
end

drawTowers
print ""Move all disks to the third pole✨.""
",
tictactoe.evy,"// See https://evy.dev#tictactoetext for a simpler, text based version
// x - bot
// o - human

board:[]string
humanScore:num
botScore:num
botStrength := 2
botStart := false
turn:string

font {family:""Fira Code, monospace""}
linecap ""round""

newGame

func newGame
    board = newBoard
    if botStart
        turn = ""x""
        draw
        botTurn
    end
    turn = ""o""
    draw
    botStart = !botStart
end

func newBoard:[]string
    return [
        ""."" ""."" "".""
        ""."" ""."" "".""
        ""."" ""."" "".""
    ]
end

func drawGameover
    msg := ""🎀 Tie.""
    w := winner
    if w == ""o""
        humanScore = humanScore + 1
        msg = ""🥳 You win!""
    else if w == ""x""
        botScore = botScore + 1
        msg = ""🤖 wins.""
    end
    clear ""white""
    drawBoard
    drawWinningLine
    drawWinningMsg msg
    sleep 0.5
    newGame
end

// --- graphics ---

func draw
    clear ""white""
    drawBoard
    drawScore
end

func drawBoard
    // grid
    vline 37.5 27 98 1 ""black""
    vline 62.5 27 98 1 ""black""
    hline 12.5 87.5 50 1 ""black""
    hline 12.5 87.5 75 1 ""black""

    // x and o
    font {size:20}
    for i := range 9
        if board[i] != "".""
            x := (getX i) - 6
            y := (getY i) - 6
            move x y
            text board[i]
        end
    end
end

func drawScore
    font {size:4}
    move 13 16
    text (sprintf ""score     🤖:%.0f    you:%.0f"" botScore humanScore)
    move 13 10
    text ""strength  ""+(repeatstr ""🦾"" botStrength)
    move 13 4
    if turn == ""x""
        text ""turn      🤖 thinking…""
    else if turn == ""o""
        text ""turn      you""
    end
end

func drawWinningLine
    w := winner
    if w == "".""
        return
    end
    l := winningLine w
    color ""hsl(330deg 100% 50% / 80%)""
    width 3
    move (getX l.i1) (getY l.i1)
    line (getX l.i2) (getY l.i2)
end

func winningLine:{}num s:string
    if board[0] == s and board[1] == s and board[2] == s
        return {i1:0 i2:2}
    else if board[3] == s and board[4] == s and board[5] == s
        return {i1:3 i2:5}
    else if board[6] == s and board[7] == s and board[8] == s
        return {i1:6 i2:8}
    else if board[0] == s and board[3] == s and board[6] == s
        return {i1:0 i2:6}
    else if board[1] == s and board[4] == s and board[7] == s
        return {i1:1 i2:7}
    else if board[2] == s and board[5] == s and board[8] == s
        return {i1:2 i2:8}
    else if board[0] == s and board[4] == s and board[8] == s
        return {i1:0 i2:8}
    else if board[2] == s and board[4] == s and board[6] == s
        return {i1:2 i2:6}
    end
    return {}
end

func drawWinningMsg msg:string
    move 13 10
    color ""black""
    font {size:7}
    text msg
    sleep 1.5
end

func getX:num i:num
    return 24 + (i % 3) * 25
end

func getY:num i:num
    return 88 - (floor i/3) * 25
end

func vline x:num y1:num y2:num w:num c:string
    line2 x y1 x y2 w c
end

func hline x1:num x2:num y:num w:num c:string
    line2 x1 y x2 y w c
end

func line2 x1:num y1:num x2:num y2:num w:num c:string
    width w
    color c
    move x1 y1
    line x2 y2
end

func repeatstr:string s:string cnt:num
    r:string
    for range cnt
        r = r + s
    end
    return r
end

// --- game logic ---

on down x:num y:num
    if y > 25 and x > 13 and x < 87
        i := floor (x - 12.5)/25
        j := floor (100 - y)/25
        humanBotTurn i+j*3
        return
    end
    if x > 35 and x < 55 and y > 7 and y < 16
        botStrength = botStrength % 3 + 1
        draw
        return
    end
end

func humanBotTurn i:num
    success := humanTurn i
    if !success
        return
    end
    if (isGameover)
        drawGameover
        return
    end

    turn = ""x""
    draw
    botTurn

    turn = ""o""
    draw
    if (isGameover)
        drawGameover
    end
end

func humanTurn:bool i:num
    if board[i] != "".""
        return false
    end
    board[i] = ""o""
    return true
end

func isGameover:bool
    return (emptyCnt) == 0 or (winner) != "".""
end

func emptyCnt:num
    cnt := 0
    for i := range 9
        if board[i] == "".""
            cnt = cnt + 1
        end
    end
    return cnt
end

func winner:string
    if board[0] != ""."" and ((board[1] == board[0] and board[2] == board[0]) or (board[4] == board[0] and board[8] == board[0]) or (board[3] == board[0] and board[6] == board[0]))
        return board[0]
    end
    if board[4] != ""."" and ((board[1] == board[4] and board[7] == board[4]) or (board[3] == board[4] and board[5] == board[4]) or (board[2] == board[4] and board[6] == board[4]))
        return board[4]
    end
    if board[8] != ""."" and ((board[6] == board[8] and board[7] == board[8]) or (board[2] == board[8] and board[5] == board[8]))
        return board[8]
    end
    return ""."" // no winner
end

func botTurn
    if botStrength == 1
        bot1Turn
    else if botStrength == 2
        bot2Turn
    else
        bot3Turn
    end
end

func bot1Turn
    target := rand (emptyCnt)
    cnt := 0
    for i := range 9
        if board[i] == "".""
            if target == cnt
                board[i] = ""x""
                return
            end
            cnt = cnt + 1
        end
    end
end

func bot2Turn
    // try to win in next move
    for i := range 9
        if board[i] == "".""
            board[i] = ""x""
            if (winner) == ""x""
                return
            end
            board[i] = "".""
        end
    end
    // try to stop ""o"" from winning in next move
    for i := range 9
        if board[i] == "".""
            board[i] = ""o""
            if (winner) == ""o""
                board[i] = ""x""
                return
            end
            board[i] = "".""
        end
    end
    // random move if no win or block possible
    bot1Turn
end

func bot3Turn
    e := emptyCnt
    if e == 9
        bot1Turn
    else if e == 8 and board[4] == "".""
        board[4] = ""x""
    else if e == 8 // ""o"" on 4
        corners := [0 2 6 8]
        i := corners[rand 4]
        board[i] = ""x""
    else
        board[minmax ""x"" 0] = ""x""
    end
end

func minmax:num turn:string depth:num
    if (isGameover)
        return score depth
    end
    scores:[]num
    moves:[]num
    nextTurn := next turn
    nextDepth := depth + 1
    for i := range 9
        if board[i] == "".""
            board[i] = turn
            scores = scores + [(minmax nextTurn nextDepth)]
            moves = moves + [i]
            board[i] = "".""
        end
    end

    idx:num
    if turn == ""x""
        idx = maxIndex scores
    else
        idx = minIndex scores
    end
    if depth != 0
        return scores[idx]
    else
        return moves[idx]
    end
end

func score:num depth:num
    w := winner
    if w == ""x""
        return 10 - depth
    else if w == ""o""
        return -10 + depth
    end
    return 0
end

func next:string turn:string
    if turn == ""o""
        return ""x""
    end
    return ""o""
end

func minIndex:num nums:[]num
    nmin := nums[0]
    idx := 0
    for i := range 1 (len nums)
        if nums[i] < nmin
            nmin = nums[i]
            idx = i
        end
    end
    return idx
end

func maxIndex:num nums:[]num
    nmax := nums[0]
    idx := 0
    for i := range 1 (len nums)
        if nums[i] > nmax
            nmax = nums[i]
            idx = i
        end
    end
    return idx
end
",
text.evy,"move 10 85
text ""“Time is an illusion.""
move 10 78
text ""Lunchtime doubly so.”""

// all font properties
font {
    size:4
    style:""italic"" // ""normal""
    family:""Tahomana, sans-serif"" // see https://developer.mozilla.org/en-US/docs/Web/CSS/font-family
    weight:700
    letterspacing:-0.1 // extra inter-character space
    align:""center"" // ""right"", ""left"" (default)
    baseline:""middle"" // ""top"", ""bottom"", ""alphabetic"" (default)
}
move 60 72
color ""dodgerblue""
text ""― Douglas Adams""

color ""black""
font {size:6 style:""normal"" letterspacing:0 align:""left"" family:""Fira Code, monospace""}
fill ""none""

move 10 50
line 45 50
move 10 50
font {baseline:""bottom""}
text ""bottom""

move 10 35
line 45 35
move 10 35
font {baseline:""top""}
text ""top""

move 10 20
line 45 20
move 10 20
font {baseline:""middle""}
text ""middle""

move 10 5
line 45 5
move 10 5
font {baseline:""alphabetic""}
text ""alphabetic""

move 70 48
line 70 56
move 70 50
font {align:""left""}
text ""left""

move 70 33
line 70 41
move 70 35
font {align:""right""}
text ""right""

move 70 18
line 70 26
move 70 20
font {align:""center""}
text ""center""
",
poly.evy,"width 1
color ""red""

fill ""none""
poly [10 80] [30 60] [50 80] [70 60] [90 80]

fill ""gold""
poly [10 20] [50 50] [20 10] [10 20]
",
fill.evy,"width 2

move 10 65
color ""red""
circle 7
move 3 40
rect 14 14
move 3 35
line 17 35

move 30 65
stroke ""blue""
circle 7
move 23 40
rect 14 14
move 23 35
line 37 35

move 50 65
color ""green""
fill ""orange""
circle 7
move 43 40
rect 14 14
move 43 35
line 57 35

move 70 65
stroke ""deeppink""
fill ""cyan""
circle 7
move 63 40
rect 14 14
move 63 35
line 77 35

move 90 65
stroke ""violet""
fill ""none""
circle 7
move 83 40
rect 14 14
move 83 35
line 97 35
",
circle-rect.evy,"move 20 0
rect 10 30
rect 20 5

move 50 50
color ""red""
circle 10

grid
",
linestyle.evy,"width 3
linecap ""round""
move 5 80
line 95 80

linecap ""butt""
move 5 70
line 95 70

linecap ""square""
move 5 60
line 95 60

width 1
move 5 30
dash 5 3 1 3
line 95 30

dash
move 5 20
line 95 20
",
lines.evy,"for i := range 0 100 3
    move i 0
    line 100 i
end
",
syntax_by_example.md,"// This is a comment
",
syntax_by_example.md,"x:num // or string, bool, any, []num, {}string
y := 1 // type inference (num)
print x y // 0 1
",
syntax_by_example.md,"z:num
z = 5
print z // 5
",
syntax_by_example.md,"pi := 3.1415
x := 5 * (3 + pi) - 2 / 7.6
print x // 30.44434210526316
",
syntax_by_example.md,"trace := false
debug := true
level := ""error""

b := !trace and debug or level == """"
print b // true
",
syntax_by_example.md,"str := ""abc"" + ""🥪123"" // ""abc🥪123"" - concatenation
s2 := str[0] // ""a"" - indexing
s3 := str[1:5] // ""bc🥪1"" - slicing
print str s2 s3
",
syntax_by_example.md,"str := ""newline: \n indentation: \t""
print str
print ""quotation mark : \"" "" // escaping
",
syntax_by_example.md,"x := 6
if x > 10
    print ""huge""
else if x > 5
    print ""medium""
else
    print ""small""
end
",
syntax_by_example.md,"str := ""abc""
if (len str) > 2
    if (startswith str ""a"")
        print ""string starting with 'a'""
    else
        print ""string not starting with 'a'""
    end
else
    print ""single character or empty string""
end
",
syntax_by_example.md,"x := 0
while x < 10
    print x // 0 1 2 ... 9
    x = x + 1
end
",
syntax_by_example.md,"for x := range 5
    print x // 0 1 2 3 4
end

for x := range 5 10
    print x // 5 6 7 8 9
end

for x := range 1 10 2 // from to step
    print x // 1 3 5 7 9
end

for x := range -10
    print x // nothing. step is 1 by default.
end
",
syntax_by_example.md,"for x := range [1 2 3]
    print x // 1 2 3
end
",
syntax_by_example.md,"m := {name:""Mali"" sport:""climbing""}
for key := range m
    print key m[key]
end
",
syntax_by_example.md,"x := 0
while true
    print ""tick... ""
    sleep 1
    if x > 2
        print ""💥""
        break // breaks out of the innermost loop
    end
    x = x + 1
end
",
syntax_by_example.md,"func add:num a:num b:num
    return a + b
end
",
syntax_by_example.md,"func foxprint s:string
    print ""🦊 ""+s
end
",
syntax_by_example.md,"func list args:any...
    for arg := range args[:-1]
        printf ""%v, "" arg
    end
    printf ""%v"" args[-1]
end
",
syntax_by_example.md,"n := add 1 2
print n // 3
foxprint ""🐾"" // 🦊 🐾
list 2 true ""blue"" // [2 true blue]

// previous function definitions
func add:num a:num b:num
    return a + b
end

func foxprint s:string
    print ""🦊 ""+s
end

func list args:any...
    print args
end
",
syntax_by_example.md,"a1:[]num
a2:[][]string
a1 = [1 2 3 4] // type: num[]
a2 = [[""1"" ""2""] [""a"" ""b""]] // type: string[][]
print a1 a2
",
syntax_by_example.md,"a1 := [true false] // type: bool[]
a2 := [""s1"" // line break allowed
    ""s2""] // type: string[]
print a1 a2
",
syntax_by_example.md,"a1:[]any
a2 := [""chars"" 123] // type: any[]
print a1 a2
",
syntax_by_example.md,"a1 := [1 2 3 4]
a2 := [[""1"" ""2""] [""a"" ""b""]]
print a1[1] // 2
print a2[1][0] // ""a""
print a1[-1] // 4
",
syntax_by_example.md,"a := [1 2 3 4]
a = a + [100] // [1 2 3 4 100]; optional extra whitespace
a = [0] + a + [101 102] // [0 1 2 3 4 100 101 102]
",
syntax_by_example.md,"a := [0] * 5 // [0 0 0 0 0]
a = [1 2] * 2 + a + [3] * 3 // [1 2 1 2 0 0 0 0 0 3 3 3]
n := 3
b := [""hello""] * n
print b // [""hello"" ""hello"" ""hello""]
",
syntax_by_example.md,"a := [1 2 3]
b := a[:2] // [1 2]
b = a[1:2] // [2]
b = a[-2:] // [2 3]
",
syntax_by_example.md,"m1 := {letters:""abc"" name:""Jill""} // type: {}string
m2 := {
    letters:""abc"" // line break allowed
    name:""Jill""
}
print m1 m2
",
syntax_by_example.md,"m := {letters:""abc"" name:""Jill""}
s := ""letters""
print m.letters // abc
print m[s] // abc
print m[""letters""] // abc
",
syntax_by_example.md,"x:any
m1:{}any
m2 := {letter:""a"" number:1} // {}any
print x m1 m2 // false {} {letter:a number:1}

a1:[]any
a2 := [""b"" 2] // []any
print a1 a2 // [] [b 2]
",
syntax_by_example.md,"print (typeof ""abc"") // ""string""
print (typeof true) // ""bool""
print (typeof [1 2]) // ""[]num""
print (typeof [[1 2] [3 4]]) // ""[][]num""
",
syntax_by_example.md,"x:any
print x (typeof x) // flase bool
x = [1 2 3 4]
s := x.([]num) // type assertion
print s (typeof s) // [1 2 3 4] []num
",
syntax_by_example.md,"v:any
v = ""🐐""
if (typeof v) == ""string""
    s := v.(string) // type assertion
    print s+s // 🐐🐐
end
",
syntax_by_example.md,"on key k:string
    print ""key:"" k
end
",
spec.md,"arr1 := [1 2 3] // []num
arr2 := [1] + [] // []num
print 1 (typeof arr1) (typeof arr2)

arr3 := [1 ""a""] // []any
arr4 := [[1] [""a""]] // [][]any
arr5 := [] // []any
print 2 (typeof arr3) (typeof arr4) (typeof arr5)

map1 := {} // {}any
map2 := {age:10} // {}num
print 3 (typeof map1) (typeof map2)
",
spec.md,"arr:[]num
print 1 arr (typeof arr)
arr = []
print 2 arr (typeof arr)
print 3 (typeof [])
",
spec.md,"s := ""a""
print 1 s
s = ""b""
print 2 s
// s = 100 // parse error, wrong type
",
spec.md,"x := ""outer""
print 1 x
for range 1
    x := true
    print 2 x
end
print 3 x
",
spec.md,"str := ""hello""
str = str + "", "" + str // hello, hello
str = ""H"" + str[1:] // Hello, hello
str = ""She said, \"""" + str + ""!\""""
print str
",
spec.md,"arr1 := [1 2 3]
arr2:[]num
print arr1 arr2
",
spec.md,"arr := [""abc"" 123] // []any
print ""Type of arr:"" (typeof arr)
",
spec.md,"m := {letters:""abc"" for:""u""}
print 1 m.letters m.for
print 2 m[""letters""] m[""for""]

key := ""German letters""
m[key] = ""äöü""
print 3 m[key]
print 4 m[""German letters""]
",
spec.md,"m := {letters:""abc""}
print 1 (has m ""letters"")
print 2 (has m ""digits"")
",
spec.md,"m := {letters:""abc""}
del m ""letters""
print m
",
spec.md,"arr := [""a"" ""b"" ""c""]
print 1 arr[0]
print 2 arr[-1]
",
spec.md,"s := ""abcd""
print 1 s[1:3]
print 2 s[:2]
print 3 s[2:]
print 4 s[:]
print 5 s[:-1]
",
spec.md,"a := 10
b := 3
print 1 a-b
print 2 (a - b)
print 3 a -b
// print a - b // parse error
",
spec.md,"person := {
    name:""Jane Goddall""
    born:1934
}
print person
",
spec.md,"x := 5 + 3
x = 7 - 2

arr := [1 2 3]
arr[3 - 2] = 10

func fn:num
    return 7 + 1
end

print x arr (fn)
",
spec.md,"print -5
len ""a""+""b""

arr := [1+1]
arr[0] = 3 + 2
print 2+arr[0]

map := {address:""10 Downing ""+""Street""}
map.address = ""221B Baker Street""

print (len map)
",
spec.md,"func validate:bool s:string maxl:num
    return (len s) <= maxl
end
",
spec.md,"func reverse arr:[]string
    if arr == []
        return
    end
    // ...
end
",
spec.md,"print ""length of abc:"" (len ""abc"")
",
spec.md,"on down _:num y:num
    print ""y:"" (round y)
end
",
spec.md,"func quote args:any...
    words:[]string
    for arg := range args
        word := sprintf ""«%v»"" arg
        words = words + [word]
    end
    print (join words "" "")
end

quote ""Life, universe and everything?"" 42
",
spec.md,"for x := range 2
    y := 0
    while y < 10
        if y == 2
            print ""break"" y
            break
        end
        print ""no break"" y
        y = y + 1
    end
    print ""x"" x ""y"" y
    print
end
",
spec.md,"func foo:string
    if (rand1) < 0.7
        return ""bar""
    else
        return ""baz""
    end
end
",
spec.md,"print (typeof ""abc"")
print (typeof true)
print

arr := [""abc"" 1]
print (typeof arr)
print (typeof arr[0])
print (typeof arr[1])
",
spec.md,"func fn nums:[]num
    print nums
end

fn []
",
spec.md,"x := [1 2 3]
print ""x"" (typeof x)
y:[]any
y = [1 2 3]
print ""y"" (typeof y)
// y = x // parse error
// x = y // parse error
",
spec.md,"x:any
x = [1 2 3 4]
num_array := x.([]num)
print ""typeof x:"" (typeof x)
print ""typeof num_array"" (typeof num_array)
print

x = ""abc""
str := x.(string)
print ""typeof x:"" (typeof x)
print ""typeof str:"" (typeof str)
",
spec.md,"x:[]any
x = [1 2 3 true]
x = [1 2 3]
print ""x:"" x ""typeof x:"" (typeof x)
// print x.([]num) // parse error
// print x[0].(string) // run-time panic
",
spec.md,"arr:[]{}any
arr = [{a:1} {b:[1 2 {}]} {}]
print (typeof arr)
print (typeof arr[0])
print (typeof arr[0].a)
",
builtins.md,"print ""Hello""
print 2 true ""blue""
print ""array:"" [1 2 3]
print ""map:"" {name:""Scholl"" age:21}
",
builtins.md,"print ""Here's a tab: 👉\t👈\nShe said: \""Thank you!\""""
",
builtins.md,"name := read
print ""Hello, ""+name+""!""
",
builtins.md,"print ""Hello""
sleep 1
cls
print ""Bye""
",
builtins.md,"printf ""The tank is 100%% full.\n\n""

weather := ""rainy""
printf ""It is %v today.\n"" weather
rainfall := 10
printf ""There will be %vmm of rainfall.\n"" rainfall
unicorns := false
printf ""There will be unicorns eating lollipops: %v.\n\n"" unicorns

quote := ""Wow!""
printf ""They said: %q\n"" quote
printf ""Array: %v\n"" [1 2 3]
printf ""Map: %v\n"" {a:1 b:2}
",
builtins.md,"printf ""right:  |%7.2f|\n"" 1
printf ""left:   |%-7.2v|\n"" ""abcd""
printf ""zeropad:|%07.2f|\n"" 1.2345
",
builtins.md,"l := len ""abcd""
print ""len \""abcd\"":"" l

l = len [1 2]
print ""len [1 2]:"" l

l = len {a:3 b:4 c:5}
print ""len {a:3 b:4 c:5}:"" l
",
builtins.md,"a:any
a = ""abcd""
t := typeof a
print ""typeof \""abcd\"":"" t

t = typeof {kind:true strong:true}
print ""typeof {kind:true strong:true}:"" t

t = typeof [[1 2] [3 4]]
print ""typeof [[1 2] [3 4]]:"" t

t = typeof [1 2 true]
print ""typeof [1 2 true]:"" t

print ""typeof []:"" (typeof [])
",
builtins.md,"map := {a:1}
printf ""has %v %q: %t\n"" map ""a"" (has map ""a"")
printf ""has %v %q: %t\n"" map ""X"" (has map ""X"")
",
builtins.md,"map := {a:1 b:2}
del map ""b""
print map
",
builtins.md,"print ""2""
sleep 1
print ""1""
",
builtins.md,"n:num
n = str2num ""1""
print ""n:"" n ""err:"" err
n = str2num ""NOT-A-NUMBER""
print ""n:"" n ""err:"" err
",
builtins.md,"b:bool
b = str2bool ""true""
print ""b:"" b ""err:"" err
b = str2bool ""NOT-A-BOOL""
print ""b:"" b ""err:"" err
",
builtins.md,"n:num
if (rand1) < 0.5
    n = str2num ""not-a-number""
else
    n = str2num ""5""
end
print ""n:"" n ""error:"" err
",
builtins.md,"arr := [0 1 2]
i := 5 // e.g. user input
print arr[i] // out of bounds
print ""This line will not be executed""
",
builtins.md,"n := str2num ""NOT A NUM""
print ""num:"" n
print ""err:"" err
print ""errmsg:"" errmsg
",
builtins.md,"s := sprint ""a"" [true] {a:1 b:2}
printf ""%q\n"" s
printf ""%q\n"" (sprint)
",
builtins.md,"s := sprintf ""%10q: %.f"" ""val"" 123.45
print s
",
builtins.md,"s := join [""a"" ""b"" ""c"" 1 3.141592654 true] "", ""
print s
",
builtins.md,"print (split ""a,b,c"" "","")
print (split ""a,b,c"" ""."")
print (split ""a,b,c"" """")
",
builtins.md,"s := upper ""abc D e ü""
print s
",
builtins.md,"s := lower ""abc D e ü""
print s
",
builtins.md,"n := index ""abcde"" ""de""
print n
",
builtins.md,"b := startswith ""abcde"" ""ab""
print b
",
builtins.md,"b := endswith ""abcde"" ""ab""
print b
",
builtins.md,"s := trim "".,..abc.de."" "".,""
print s
",
builtins.md,"s := replace ""abc123xyzabc abc"" ""abc"" ""ABC""
print s
",
builtins.md,"print (rand 3)
print (rand 3)
",
builtins.md,"print (rand1)
print (rand1)
",
builtins.md,"print (min 3 1)
",
builtins.md,"print (min 3 1)
",
builtins.md,"print (floor 2.7)
print (floor 3)
",
builtins.md,"print (ceil 2.1)
print (ceil 4)
",
builtins.md,"print (round 2.4)
print (round 2.5)
",
builtins.md,"print (pow 2 3)
",
builtins.md,"printf ""%.2f\n"" (log 1)
printf ""%.2f\n"" (log 2.7183) // e
",
builtins.md,"print (sqrt 9)
",
builtins.md,"pi := 3.14159265
print (sin 0.5*pi)
",
builtins.md,"pi := 3.14159265
print (cos pi)
",
builtins.md,"pi := 3.14159265
rad := atan2 1 1
degrees := rad * 180 / pi
printf ""rad: %.2f degrees: %.2f"" rad degrees
",
builtins.md,"grid
move 30 60
circle 1
",
builtins.md,"move 30 20
line 70 20
line 50 50
line 30 20
",
builtins.md,"grid
move 40 20
rect 10 30
rect 40 20
",
builtins.md,"grid
move 50 50
circle 10
",
builtins.md,"color ""darkmagenta""
rect 20 20
",
builtins.md,"width 10
line 30 30
width 1
line 60 60
width 0.1
line 90 90
grid
",
builtins.md,"color ""darkmagenta""
rect 20 20
clear
color ""blue""
circle 5
grid
",
builtins.md,"grid
",
builtins.md,"color ""hsl(0deg 100% 0% / 50%)""
for i := range 0 101 10
    width 0.1
    if i == 50
        width 0.2
    end
    move i 0
    line i 100
    move 0 i
    line 100 i
end
",
builtins.md,"gridn 2 ""red""
",
builtins.md,"c := ""red""
n := 2

color c
linecnt := 0
for i := range 0 101 n
    width 0.1
    if linecnt % 5 == 0
        width 0.2
    end
    linecnt = linecnt + 1
    move i 0
    line i 100
    move 0 i
    line 100 i
end
",
builtins.md,"width 1
color ""red""

fill ""none""
poly [10 80] [30 60] [50 80] [70 60] [90 80]

fill ""gold""
poly [10 20] [50 50] [20 10] [10 20]
",
builtins.md,"// red circle
color ""red""
ellipse 50 50 40

// yellow, flat ellipse
color ""gold""
ellipse 50 50 40 10

// blue, flat ellipse tilted by 45°
color ""blue""
ellipse 50 50 40 10 45

// white, flat, half ellipse tilted by 135°
color ""white""
ellipse 50 50 40 10 135 0 180
",
builtins.md,"width 1
color ""red""
rect 30 30

stroke ""blue""
rect 30 30
",
builtins.md,"width 1
color ""red""
rect 30 30

fill ""blue""
rect 30 30
",
builtins.md,"width 2

dash 5 // same as: dash 5 5, dash 5 5 5
hline 85 ""red""

dash 10 4 1 4
hline 75 ""blue""

dash 10 5 10 // same as: dash 10 5 10 10 5 10
hline 65 ""gold""

dash // reset dash
hline 50 ""black""

gridn 5 ""gray""

func hline y:num c:string
    color c
    move 0 y
    line 100 y
end
",
builtins.md,"width 5
grid

linecap ""round""
hline 70

linecap ""butt""
hline 50

linecap ""square""
hline 30

func hline y:num
    move 10 y
    line 90 y
end
",
builtins.md,"move 20 70
text ""“Time is an illusion.""
move 20 63
text ""Lunchtime doubly so.”""
move 35 48
text ""― Douglas Adams""
",
builtins.md,"font {family:""Bradley Hand, cursive"" size:4}

move 10 65
text ""“The wonderful thing about programming""
move 10 60
text ""is that anyone can learn it and do it. You""
move 10 55
text ""don't have to be a genius or have a specific""
move 10 50
text ""background. You just need curiosity and""
move 10 45
text ""the willingness to try.”""

// all font properties
font {
    size:9
    style:""normal"" // ""normal""
    family:""Tahomana, sans-serif"" // see https://developer.mozilla.org/en-US/docs/Web/CSS/font-family
    weight:900
    letterspacing:-0.5 // extra inter-character space. negative allowed. default:0
    align:""right"" // ""left"", ""right""
    baseline:""middle"" // ""top"", ""bottom"", ""alphabetic"" (default)
}

move 90 32
color ""red""
text ""Grace Hopper""
color ""black""
font {size:4 letterspacing:0 weight:100 style:""normal""}
move 90 25
text ""computer scientist, compiler builder""
",
builtins.md,"font {size:6 family:""Fira Code, monospace""}

move 25 78
line 25 86
move 25 80
font {align:""left""}
text ""left""

move 25 63
line 25 71
move 25 65
font {align:""right""}
text ""right""

move 25 48
line 25 56
move 25 50
font {align:""center""}
text ""center""

move 55 80
line 90 80
move 55 80
font {baseline:""bottom"" align:""left""}
text ""bottom""

move 55 65
line 90 65
move 55 65
font {baseline:""top""}
text ""top""

move 55 50
line 90 50
move 55 50
font {baseline:""middle""}
text ""middle""

move 55 35
line 90 35
move 55 35
font {baseline:""alphabetic""}
text ""alphabetic""
",
builtins.md,"font {
    family:""Fira Code, monospace""
    size:9
    weight:700
    style:""italic""
    letterspacing:0.5
    baseline:""top""
    align:""center""
}
",
builtins.md,"on key k:string
    print k
end
",
builtins.md,"on key k:string
    print k
end
",
builtins.md,"on down x:num y:num
    printf ""x: %2.0f y: %2.0f\n"" x y
end
",
builtins.md,"on up x:num y:num
    move x y
    color ""red""
    circle 1
end
",
builtins.md,"down := false
width 1

on down x:num y:num
    down = true
    move x y
end

on move x:num y:num
    if down
        line x y
    end
end

on up
    down = false
end
",
builtins.md,"semiblack := ""hsl(0deg 0% 0% / 10%)""
width 1
fill semiblack
stroke ""red""

on animate ms:num
    clear semiblack
    y := 100 - (ms / 20) % 100
    move 50 y
    circle 10
end
",
builtins.md,"on input id:string val:string
    print ""id:"" id ""val:"" val
end
",
text.evy,"move 10 85
text ""“Time is an illusion.""
move 10 78
text ""Lunchtime doubly so.”""

// all font properties
font {
    size:4
    style:""italic"" // ""normal""
    family:""Tahomana, sans-serif"" // see https://developer.mozilla.org/en-US/docs/Web/CSS/font-family
    weight:700
    letterspacing:-0.1 // extra inter-character space
    align:""center"" // ""right"", ""left"" (default)
    baseline:""middle"" // ""top"", ""bottom"", ""alphabetic"" (default)
}
move 60 72
color ""dodgerblue""
text ""― Douglas Adams""

color ""black""
font {size:6 style:""normal"" letterspacing:0 align:""left"" family:""Fira Code, monospace""}
fill ""none""

move 10 50
line 45 50
move 10 50
font {baseline:""bottom""}
text ""bottom""

move 10 35
line 45 35
move 10 35
font {baseline:""top""}
text ""top""

move 10 20
line 45 20
move 10 20
font {baseline:""middle""}
text ""middle""

move 10 5
line 45 5
move 10 5
font {baseline:""alphabetic""}
text ""alphabetic""

move 70 48
line 70 56
move 70 50
font {align:""left""}
text ""left""

move 70 33
line 70 41
move 70 35
font {align:""right""}
text ""right""

move 70 18
line 70 26
move 70 20
font {align:""center""}
text ""center""
",
poly.evy,"width 1
color ""red""

fill ""none""
poly [10 80] [30 60] [50 80] [70 60] [90 80]

fill ""gold""
poly [10 20] [50 50] [20 10] [10 20]
",
fill.evy,"width 2

move 10 65
color ""red""
circle 7
move 3 40
rect 14 14
move 3 35
line 17 35

move 30 65
stroke ""blue""
circle 7
move 23 40
rect 14 14
move 23 35
line 37 35

move 50 65
color ""green""
fill ""orange""
circle 7
move 43 40
rect 14 14
move 43 35
line 57 35

move 70 65
stroke ""deeppink""
fill ""cyan""
circle 7
move 63 40
rect 14 14
move 63 35
line 77 35

move 90 65
stroke ""violet""
fill ""none""
circle 7
move 83 40
rect 14 14
move 83 35
line 97 35
",
circle-rect.evy,"move 20 0
rect 10 30
rect 20 5

move 50 50
color ""red""
circle 10

grid
",
linestyle.evy,"width 3
linecap ""round""
move 5 80
line 95 80

linecap ""butt""
move 5 70
line 95 70

linecap ""square""
move 5 60
line 95 60

width 1
move 5 30
dash 5 3 1 3
line 95 30

dash
move 5 20
line 95 20
",
lines.evy,"for i := range 0 100 3
    move i 0
    line 100 i
end
",
ellipse.evy,"ellipse 50 85 30 10 0
ellipse 50 55 30 10 30
",
Learn:-Evy.md,"print ""Hello world""
",
Practice:-Variables.md,"s := ""false""
print s s
",
Practice:-Variables.md,"s := true
print s s
",
Practice:-Variables.md,"s:bool
print s s
",
Practice:-Variables.md,"s:bool
s = true
print s s
",
Practice:-Variables.md,"s := true
s = true
print s s
",
Practice:-Variables.md,"s:num
print s s
",
Practice:-Variables.md,"s := 2
print s s
",
Practice:-Variables.md,"c2 := ""red""
c1 := ""blue""
w1 := 2
w2 := 5

color c1
width w1
move 20 80
line 80 80

color c2
move 20 60
line 80 60

width w2
move 20 40
line 80 40

color c1
move 20 20
line 80 20
",
Practice:-Variables.md,"c2 := ""red""
c1 := ""blue""
w1 := 2
w2 := 5

color c1
width w1
move 20 80
line 80 80

width w2
move 20 60
line 80 60

color c2
move 20 40
line 80 40

width w1
move 20 20
line 80 20
",
Practice:-Variables.md,"c1 := ""red""
c2 := ""blue""
w1 := 2
w2 := 5

color c1
width w1
move 20 80
line 80 80

width w2
move 20 60
line 80 60

color c2
move 20 40
line 80 40

width w1
move 20 20
line 80 20
",
Practice:-Variables.md,"c1 := ""red""
c2 := ""blue""
w1 := 2
w2 := 5

color c1
width w1
move 20 80
line 80 80

width w2
move 20 60
line 80 60

color c2
move 20 20
line 80 20

width w1
move 20 40
line 80 40
",
Practice:-Variables.md,"c1 := ""red""
c2 := ""blue""
w1 := 2
w2 := 5

color c1
width w1
move 20 60
line 80 60

width w2
move 20 80
line 80 80

color c2
move 20 20
line 80 20

width w1
move 20 40
line 80 40
",
Practice:-Variables.md,"a := ""abc""
b:num
// --- missing line of code goes here ---
print a b
",
Practice:-Variables.md,"b := 2.4
// --- missing line of code goes here ---
print a b
",
Practice:-Variables.md,"a:string
a = ""abc""
// --- missing line of code goes here ---
print a b
",
Practice:-Variables.md,"a:string
b := 2.4
// --- missing line of code goes here ---
print a b
",
Practice:-Basic-Data-Types.md,"print 1 2 12
",
Practice:-Basic-Data-Types.md,"print false true
",
Practice:-Basic-Data-Types.md,"print false ""true""
",
Practice:-Basic-Data-Types.md,"print 1 ""2""
",
Practice:-Basic-Data-Types.md,"print 1 ""2
",
Practice:-Basic-Data-Types.md,"print +1 ""2""
",
Practice:-Basic-Data-Types.md,"print ""3"" .5
",
Practice:-Read.md,"s1 := read
print s1 s1
s2 := read
print s1 s2
",
Practice:-Draw.md,"color ""red""
move 50 50
circle 20
",
Practice:-Draw.md,"clear ""blue""
color ""red""
move 50 50
rect 20 20
",
Practice:-Draw.md,"clear ""green""
color ""white""
width 4
move 80 20
line 80 80
line 20 20
line 20 80
",
Practice:-Draw.md,"clear ""black""
width 4
move 20 80
color ""red""
circle 10
color ""white""
line 80 20
color ""red""
circle 10
",
Practice:-Draw.md,"grid

color ""purple""
width 1
move 50 10
line 50 90

color ""blue""
move 50 10
line 40 50
line 50 90
line 60 50
line 50 10

color ""forestgreen""
move 50 20
line 30 50
line 50 80
line 70 50
line 50 20

color ""gold""
move 50 30
line 20 50
line 50 70
line 80 50
line 50 30

color ""orange""
move 50 40
line 10 50
line 50 60
line 90 50
line 50 40

color ""red""
",
Practice:-Draw.md,"
",
Practice:-Draw.md,"clear ""black""
color ""red""
rect 100 50
move 50 50
color ""yellow""
circle 20
",
Practice:-Draw.md,"
",
Practice:-Draw.md,"clear ""aqua""
width 0.4
line 10 100
move 0 10
line 20 100
move 0 20
line 30 100
move 0 30
line 40 100
move 0 40
line 50 100
move 0 50
line 60 100
move 0 60
line 70 100
move 0 70
line 80 100
move 0 80
line 90 100
move 0 90
line 100 100
",
Practice:-Print.md,"print ""hello""
",
Practice:-Print.md,"print ""hola
",
Practice:-Print.md,"print ""2""
print ""1""
",
Practice:-Print.md,"print ""1"" ""2""
print ""3""
",
Practice:-Print.md,"print ""x""
print ""y"" ""z""
",
Practice:-Print.md,"
",
Practice:-Print.md,"print ""1 2 3""
print ""4 5 6""
",
Practice:-Print.md,"a b
c d
e F
",
Practice:-Print.md,"
",
Practice:-Print.md,"print ""a b""
print ""c d""
print ""e F""
",
Practice:-Print.md,"
",
Practice:-Print.md,"print ""print 1 2 3""
print ""print 4 5 6""
",
pentaphobe-lsystems.evy,"pi := 3.14159

// --- starting position and size of the tree
// trunk length
startSize := 30
// pointing upwards!
startAngle := radians 90

// --- specifies the tree colours
rootColor := {hue:25 sat:64 light:20}
tipColor := {hue:95 sat:89 light:36}

// --- thickness of the branches
rootWidth := 3
tipWidth := 0.25

// --- controls the shape of the tree
// how much each branch turns from its parent
angleChange := radians 45
// how much smaller each branch is than its parent
sizeChange := 0.63

// --- controls the swaying of the tree
// the current angle of sway
angleOffset := 0
// how fast we sway
swaySpeed := 0.8
// how far to sway
swayAmount := 0.2
// how much large branches sway
largeSway := 0.05
// how much small branches sway
smallSway := 2

// --- limits how many branches to draw
// ⚠️ be careful changing this!
maxIter := 5 // maximum ""depth"" of branches
// to draw
minSize := 0.5 // minimum length of a branch

paused := false

on animate t:num
    if !paused
        angleOffset = (sin (t / 1000 * swaySpeed)) * swayAmount
    end

    redraw
end

func redraw
    clear ""#e3f8f7""
    width 0.5
    color ""red""
    fill ""none""

    move 50 10
    draw 50 10 startAngle startSize 0
end

// draws a branch and then draws its two children
func draw x:num y:num angle:num size:num iter:num
    if size < minSize or iter > maxIter
        return
    end

    trunkWidth := remap size [minSize startSize] [tipWidth rootWidth]
    width trunkWidth

    sway := remap size [minSize startSize] [smallSway largeSway]

    amount := remap iter [0 maxIter] [0 1]
    color (colorMix rootColor tipColor amount)

    newX := x + (cos angle) * size
    newY := y + (sin angle) * size

    // draw line for this branch
    line newX newY

    newAngle := angle + (angleOffset * sway)
    newSize := size * sizeChange

    // draw the left child branch
    draw newX newY newAngle-angleChange newSize iter+1
    // draw the right...
    draw newX newY newAngle+angleChange newSize iter+1
    // move back to the start
    move x y
end

// converts from degrees to radians
func radians:num degrees:num
    return (degrees * pi) / 180
end

// interpolate from one number to another
// amount is how far between a and b we get
//
// a ----------------------------- b
// 0            0.5                1
func interp:num a:num b:num amount:num
    delta := b - a
    return a + (delta * amount)
end

// colorMix is like interp but for colours
// it blends between the two provided colours based on amount
// and returns a string you can use with color()
func colorMix:string a:{}num b:{}num amount:num
    h := interp a.hue b.hue amount
    s := interp a.sat b.sat amount
    l := interp a.light b.light amount
    return sprintf ""hsl(%.fdeg %.f%% %.f%%)"" h s l
end

// convert a number from one range to another
// eg.
//
//   remap 5 [0 10] [50 100]
//
// would turn 5 into 75
func remap:num in:num inRange:[]num outRange:[]num
    result := in - inRange[0]
    result = result / (inRange[1] - inRange[0])
    result = result * (outRange[1] - outRange[0])
    result = result + outRange[0]
    return max outRange[0] (min outRange[1] result)
end

on key k:string
    if k == "" ""
        paused = !paused
    end
end

on input id:string val:string
    if id == ""sliderx""
        degreesValue := remap (str2num val) [0 100] [5 90]
        angleChange = radians degreesValue
    else
        // sizeChange = remap (str2num val) [0 100] [0.458 0.9]

        smallSway = remap (str2num val) [0 100] [0.5 5]
    end
end

",
p5js-stringy.evy,"x:[]num
y:[]num
clear ""black""

for range 20
    x = x + [0]
    y = y + [0]
end

segLength := 3

width 1
color ""#ffffffb0""

on move x:num y:num
    draw x y
end

func draw mouseX:num mouseY:num
    clear ""black""
    drawSegment 0 mouseX mouseY
    for i := range (len x)-1
        drawSegment i+1 x[i] y[i]
    end
end

func drawSegment i:num xin:num yin:num
    dx := xin - x[i]
    dy := yin - y[i]
    angle := atan2 dy dx
    x[i] = xin - (cos angle) * segLength
    y[i] = yin - (sin angle) * segLength
    move x[i] y[i]
    line x[i]+dx y[i]+dy
end
",
barnsley-fern.evy,"color ""green""
r:num
x:num
y:num
nx:num
ny:num

for range 500000
    r = rand1
    if r < 0.01
        nx = 0
        ny = 0.16 * y
    else if r < 0.08
        nx = 0.2 * x - 0.26 * y
        ny = 0.23 * x + 0.22 * y + 1.6
    else if r < 0.15
        nx = -0.15 * x + 0.28 * y
        ny = 0.26 * x + 0.24 * y + 0.44
    else
        nx = 0.85 * x + 0.04 * y
        ny = -0.04 * x + 0.85 * y + 1.6
    end
    x = nx
    y = ny
    move 50+x*15 y*10-3
    circle 0.05
end
",
p5js-circles.evy,"fill ""white""

on move x:num y:num
    move x y
    circle 9
end
",
greyhair2.evy,"// parameters
clear ""red""
blackHairs := 550
style := ""lin"" // ""exp"" or ""lin""
k := 2 // linear
exp := 1.025 // exponent
start := 0.5 // exponent

// internal state
left:[]bool
right:[]bool
leftIdx:[]num
rightIdx:[]num
initData

on animate
    whiten style
    drawHair 40 75 right
    drawFace
    drawHair 30 270 left
    if blackHairs == 0
        exit 0
    end
end

func whiten s:string
    if s == ""exp""
        // exponential
        whitenCnt (round start)
        start = start * exp
    else
        whitenCnt k // linear
    end
end

func whitenCnt cnt:num
    for range cnt
        if blackHairs <= 0
            return
        end
        blackHairs = blackHairs - 1
        left[leftIdx[blackHairs]] = false
        right[rightIdx[blackHairs]] = false
    end
end

func drawHair x:num rot:num hair:[]bool
    width 0.1
    fill ""none""
    d := 0
    for i := range (len hair)
        if hair[i]
            stroke ""black""
        else
            stroke ""white""
        end
        ellipse x+d 64-d 31 21 rot 180 0
        d = d + 0.05
    end
end

func drawFace
    color ""gold""
    move 50 50
    circle 20
    color ""black""
    width 2
    move 47 50
    line 52 48
    move 60 48
    line 62.5 49.5
end

func initData
    for i := range blackHairs
        left = left + [true]
        right = right + [true]
        leftIdx = leftIdx + [i]
        rightIdx = rightIdx + [i]
    end

    shuffle leftIdx
    shuffle rightIdx
end

func shuffle arr:[]num
    for x := range (len arr) 0 -1
        i := rand x
        h := arr[i]
        arr[i] = arr[x - 1]
        arr[x - 1] = h
    end
end
",
greyhair1.evy,"// parameters
k := 7 // linear
exp := 1.1 // exponent
start := 0.5 // exponent
cnt := 600
hairLin := newHair cnt ""linear""
hairExp := newHair cnt ""exp""

frame := 0

on animate
    frame = frame + 1
    if frame % 2 == 0
        return
    end
    clear ""red""
    whiten hairLin
    drawHead 25 hairLin

    whiten hairExp
    drawHead 75 hairExp

    if hairLin.props.cnt[0] == 0 and hairExp.props.cnt[0] == 0
        exit 0
    end
end

func whiten hair:{}{}[]num
    if hair.props.style[0] == 1
        // exponential
        whitenCnt (round start) hair
        start = start * exp
    else
        whitenCnt k hair // linear
    end
end

func whitenCnt n:num hair:{}{}[]num
    for range n
        if hair.props.cnt[0] <= 0
            return
        end
        cnt := hair.props.cnt[0] - 1
        hair.props.cnt[0] = cnt
        idx := hair.left.idx[cnt]
        hair.left.black[idx] = 0
        idx = hair.right.idx[cnt]
        hair.right.black[idx] = 0
    end
end

func drawHead x:num hair:{}{}[]num
    drawFace x 60
    drawHair x-4 56 265 hair.left.black // left
    drawHair x-7 58 79 hair.right.black // right
end

func drawHair x:num y:num rot:num hair:[]num
    width 0.1
    fill ""none""
    d := 0
    for i := range (len hair)
        if hair[i] == 1
            stroke ""black""
        else
            stroke ""white""
        end
        ellipse x+d y-d 31 17 rot 200 0
        d = d + 0.02
    end
end

func drawFace x:num y:num
    color ""gold""
    move x y
    circle 15
    color ""black""
    width 1.5
    move x-5 y
    line x y-2
    move x+7 y-2
    line x+9 y-0.5
end

func shuffle arr:[]num
    for x := range (len arr) 0 -1
        i := rand x
        h := arr[i]
        arr[i] = arr[x - 1]
        arr[x - 1] = h
    end
end

func newHair:{}{}[]num cnt:num style:string
    lb:[]num // left black hair
    rb:[]num // right black hair
    li:[]num // left shuffled index for white hair in order
    ri:[]num // right shuffled index for white hair in order
    for i := range cnt
        lb = lb + [1]
        rb = rb + [1]
        li = li + [i]
        ri = ri + [i]
    end
    shuffle li
    shuffle ri
    s := 0
    if style == ""exp""
        s = 1
    end
    return {
        left:{black:lb idx:li}
        right:{black:rb idx:ri}
        props:{cnt:[cnt] style:[s]}
    }
end
",
flower.evy,"color ""red""
move 40 70
circle 9

color ""pink""
move 55 70
circle 9

color ""blue""
move 67 64
circle 9

color ""pink""
move 70 50
circle 9

move 70 40
color ""red""
circle 9

color ""blue""
move 60 30
circle 9

move 45 1
color ""brown""
rect 10 60

move 30 60
color ""blue""
circle 9

move 30 45
color ""pink""
circle 9

move 38 33
color ""red""
circle 9

move 50 50
color ""yellow""
circle 17

grid
",
coin-toss-game.evy,"streak := 0
width 1
font {baseline:""top"" family:""arial""}
drawCoins

on down x:num _:num
    guess:string
    if x < 50
        guess = ""heads""
    else
        guess = ""tails""
    end
    clear
    drawHighlight guess
    drawCoins
    sleep 0.3
    clear
    drawCoins
    win := play guess
    drawScore win
end

func drawCoins
    color ""gold""
    stroke ""orange""
    // heads
    move 25 50
    circle 20
    move 25 63
    font {align:""center"" size:34}
    text ""🤪""

    // tails
    move 75 50
    circle 20
    move 75 62
    text ""🧜\u200d♀️""

    // divider
    color ""black""
    dash 5 5
    move 50 0
    line 50 90
    dash

    // labels
    font {size:8}
    move 25 27
    text ""heads""
    move 75 27
    text ""tails""
end

func drawHighlight guess:string
    if guess == ""heads""
        move 0 0
    else
        move 50 0
    end
    color ""magenta""
    rect 50 85

end

func drawScore win:bool
    font {align:""left"" size:4}
    move 5 95
    if !win
        text ""You lose.""
        return
    end
    emojis:string
    for range streak
        emojis = emojis + ""🥳 ""
    end
    msg := sprintf ""You win! Streak %v %s"" streak emojis
    text msg
end

func play:bool guess:string
    result:string
    r := rand 2
    if r == 0
        result = ""heads""
    else
        result = ""tails""
    end
    win := guess == result
    if win
        streak = streak + 1
    else
        streak = 0
    end
    return win
end
",
sine3.evy,"pi := 3.14159265359

font {size:4 family:""arial""}

speed := 50
ydist := 50

on animate ms:num
    clear
    gridn 50 ""hsl(0deg 100% 0% / 20%)""
    t := ms / 1000 * speed / 25
    scale := ydist / 2
    ylinear := (trianglewave t) * scale * 2 / pi + 50
    ycos := (cos t) * scale + 50
    draw ylinear ycos
end

func draw ylinear:num ycos:num
    clear
    draw_dot ylinear ""black""
    draw_dot ycos ""hsl(0deg 100% 50% / 90%)""
    draw_labels
end

func draw_labels
    color ""red""
    move 10 92
    text ""sine""
    color ""black""
    move 20 92
    text ""linear""
end

func draw_dot y:num c:string
    color c
    move 50 y
    circle 1
end

p := 2 * pi
p100 := 100 * p

func trianglewave:num x:num
    x100 := 100 * x
    h := x100 % p100 / 100
    y := (abs h-p/2) - p / 4
    return y
end

func abs:num n:num
    if n < 0
        return -n
    end
    return n
end

on input id:string val:string
    n := str2num val
    if id == ""sliderx""
        speed = n
    else if id == ""slidery""
        ydist = n
    end
end
",
sine2.evy,"radius := 25
deg := 0
xr := radius

on animate ms:num
    deg = ms / 3
    //    xr := xradius ms radius
    draw xr radius deg
end

func xradius:num ms:num r:num
    s := ms % 10000 / 1000 // repeat: 10s
    if s < 2 or s > 10
        // full circle; pause 2s
        return 25
    else if s > 5 and s < 7
        // line; pause 2s
        return 0.001
    end
    t := s - 2 // normalize for one pause: 2s
    if s > 7
        t = s - 4 // normalise for two pauses: 4s
    end
    xr := (cos t) + 1
    return xr * r / 2 // scale by radius
end

func draw xr:num yr:num deg:num
    clear
    gridn 50 ""lightgrey""

    // black circle
    color ""black""
    fill ""none""
    width 0.3
    ellipse 50 50 xr yr

    // red dot
    color ""red""
    width 3
    ellipse 50 50 xr yr 0 deg deg+0.05
end

on input id:string val:string
    if id != ""sliderx""
        return
    end
    n := str2num val
    xr = n / 100 * radius + 0.001
    draw xr radius deg
end
",
montecarlo.evy,"in:num

for total := range 1000000
    x := rand1
    y := rand1
    d := sqrt x*x+y*y
    if d <= 1
        in = in + 1
    end
    pi := in / total * 4

    //output
    cls
    print ""π:"" pi

    // draw
    if d <= 1
        color ""red""
    else
        color ""black""
    end
    move x*100 y*100
    circle 0.2
end
```
",
sine1.evy,"on animate ms:num
    deg := ms / 3
    radius := 25
    xr := xradius ms radius
    draw xr radius deg
end

func xradius:num ms:num r:num
    s := ms % 10000 / 1000 // repeat: 10s
    if s < 2 or s > 10
        // full circle; pause 2s
        return 25
    else if s > 5 and s < 7
        // line; pause 2s
        return 0.001
    end
    t := s - 2 // normalize for one pause: 2s
    if s > 7
        t = s - 4 // normalise for two pauses: 4s
    end
    xr := (cos t) + 1
    return xr * r / 2 // scale by radius
end

func draw xr:num yr:num deg:num
    clear
    gridn 50 ""lightgrey""

    // black circle
    color ""black""
    fill ""none""
    width 0.3
    ellipse 50 50 xr yr

    // red dot
    color ""red""
    width 3
    ellipse 50 50 xr yr 0 deg deg+0.05
end
",
sine5.evy,"theta := 0 // angle of black circle as it rotates around y axis
r := 25 // black circle radius (hopefully)
tau := 2 * 3.14159265359 // 1 rotation
rotations_per_second := 0.05
rotation_speed := rotations_per_second * tau // per second

prev_t := 0 // elapsed time at start of last frame
delta_t := 0 // store milliseconds since last frame

on animate t:num
    delta_t = t - prev_t
    prev_t = t
    deg := t / 3
    theta = theta + rotation_speed * delta_t * 0.001
    draw theta deg
end

func abs:num z:num
    if z >= 0
        return z
    else
        return -z
    end
end

func draw theta:num deg:num
    clear
    gridn 50 ""lightgrey""

    // Ellipse seems to crash if x is negative.
    // So take abs value -- this gives correct result
    // for black circle, but position of red dot about circle
    // is a bit incorrect -- it should change from clockwise
    // to counterclockwise as we increase theta and flip
    // the black circle so it is facing back to front.
    x := (abs (r * (cos theta)))

    // black circle
    color ""black""
    width 0.3
    fill ""none""
    ellipse 2*r 2*r x r

    // red dot
    color ""red""
    width 3
    ellipse 2*r 2*r x r 0 deg deg+0.1
end
",
sine4.evy,"grid

move 0 50
width 0.5

pi := 3.14159265359
p := 10 * pi
p100 := 100 * p
s := 2
for x := range 0 100 0.1
    x100 := 100 * x
    h := x100 % p100 / 100
    y := (abs h-p/2) * s + (50 - s * p / 4)
    line x y
end

color ""red""
move 0 50
for x := range 0 100 0.1
    y := (cos x*0.2)
    line x y*pi*5+50
end

func abs:num n:num
    if n < 0
        return -n
    end
    return n
end
",
interactive-draw.evy,"c := {x:50 y:50 radius:10 dx:0 dy:0}
down := false
state := ""none"" // ""move"", ""resizex"", ""resizey""
draw

func draw
    clear
    draw_grid
    draw_circle
    if state == ""move""
        draw_cross
    end
    if state == ""resizex"" or state == ""resizey""
        draw_handles
    end
end

on move x:num y:num
    if !down
        state = get_state x y
        draw
        return
    end
    if x == 0 or x == 100 or y == 0 or y == 100
        release
        return
    end

    if state == ""move""
        update x+c.dx y+c.dy c.radius
    else if state == ""resizex""
        update c.x c.y (abs x-c.x)
    else if state == ""resizey""
        update c.x c.y (abs y-c.y)
    end
    draw
end

func update x:num y:num radius:num
    x = (round x/10) * 10
    y = (round y/10) * 10
    radius = (round radius/10) * 10
    if x != c.x or y != c.y or radius != c.radius
        c.x = x
        c.y = y
        c.radius = radius
        print ""x:"" x ""y:"" y ""radius:"" radius
    end
end

on down x:num y:num
    state = get_state x y
    if state == ""none""
        return
    end
    down = true
    c.dx = c.x - x
    c.dy = c.y - y
end

on up
    release
end

func release
    state = ""none""
    down = false
    draw
end

func get_state:string x:num y:num
    dist := sqrt (c.x - x)*(c.x - x)+(c.y - y)*(c.y - y)
    if dist > c.radius + 3
        return ""none""
    else if dist < c.radius - 3
        return ""move""
    else if (abs c.x-x) >= (abs c.y-y)
        return ""resizex""
    end
    return ""resizey""
end

func draw_grid
    width 0.05
    color ""hsl(0deg 100% 0% / 50%)""
    for i := range 0 101 10
        move i 0
        line i 100
        move 0 i
        line 100 i
    end
end

func draw_circle
    color ""red""
    move c.x c.y
    circle c.radius
end

func draw_cross
    color ""black""
    width 0.4
    move c.x-1 c.y
    line c.x+1 c.y
    move c.x c.y-1
    line c.x c.y+1
end

func draw_handles
    color ""black""
    width 0.4
    move c.x+c.radius c.y-1
    line c.x+c.radius c.y+1
    move c.x-c.radius c.y-1
    line c.x-c.radius c.y+1
    move c.x-1 c.y+c.radius
    line c.x+1 c.y+c.radius
    move c.x-1 c.y-c.radius
    line c.x+1 c.y-c.radius
end

func abs:num n:num
    if n < 0
        return -n
    end
    return n
end
",
taxi.evy,"grid

move 50 60
color ""red""
circle 10

move 20 10
color ""yellow""
rect 60 50

move 5 20
color ""yellow""
rect 25 20

move 70 20
color ""yellow""
rect 20 20

move 25 15
color ""black""
circle 10

move 25 15
color ""white""
circle 5

move 75 15
color ""black""
circle 10

move 75 15
color ""white""
circle 5

move 32 10
color ""black""
rect 35 2

move 5 38
color ""black""
rect 85 2

move 20 55
color ""black""
rect 60 3

move 20 57
color ""brown""
rect 60 3

move 20 50
color ""brown""
rect 10 10

move 10 40
color ""brown""
rect 10 10

move 80 40
color ""brown""
rect 10 10

move 70 50
color ""brown""
rect 10 10

move 70 50
color ""black""
rect 2 7

move 30 50
color ""black""
rect 2 7

move 20 40
color ""black""
rect 2 10

move 78 40
color ""black""
rect 2 10

move 70 50
color ""black""
rect 10 2

move 20 50
color ""black""
rect 10 2

move 50 10
color ""black""
rect 2 47

move 3 20
color ""black""
rect 2 20

move 90 20
color ""black""
rect 2 20

move 76 20
color ""black""
rect 14 2

move 3 20
color ""black""
rect 21 2

move 5.1 23
color ""red""
rect 3 8

move 5 26
color ""white""
rect 2 5

move 5 26
color ""yellow""
rect 2 2

move 88 23
color ""red""
rect 2 8

move 88 23
color ""black""
rect 3 2

move 5 23
color ""black""
rect 3 2

move 88 30
color ""black""
rect 3 2

move 5 30
color ""black""
rect 3 2

move 68 30
color ""black""
rect 5 2

move 38 30
color ""black""
rect 5 2

move 10 71.5
color ""orange""
rect 80 25

move 30 75
color ""black""
rect 2 17

move 45 75
color ""black""
rect 2 17

move 55 75
color ""black""
rect 2 15

move 30 82
color ""black""
rect 15 2

move 50 90
color ""black""
rect 12 2

move 50 75
color ""black""
rect 12 2

move 70 80
color ""black""
rect 2 12

move 70 75
color ""black""
rect 2 2
",
pentaphobe-mousechaser.evy,"//
// Mouse chaser
//
//

// --- Setup constants --------
speed := 20
friction := 5

// --- State ------------------
chaserX := 0
chaserY := 0
chaserVelX := 0
chaserVelY := 0

targetX := 0
targetY := 0

// evy passes an absolute time rather than time delta
// so we store the previous time in order to calculate delta
previousTime := 0

// --- events -----------------

on move x:num y:num
    targetX = x
    targetY = y
end

on animate t:num
    // calculate deltaTime
    deltaTime := (t - previousTime) / 1000
    previousTime = t

    // -- update (time bound)
    update deltaTime

    // -- draw (frame bound)
    col := spinColor t
    clear col
    drawWorld
end

// --- movement updates ------

func update dT:num
    scaledFriction := 1 / (1 + dT * friction)
    chaserVelX = chaserVelX * scaledFriction
    chaserVelY = chaserVelY * scaledFriction

    chase

    chaserX = chaserX + chaserVelX * dT
    chaserY = chaserY + chaserVelY * dT
end

func chase
    dir := direction chaserX chaserY targetX targetY

    moveX := cos dir
    moveY := sin dir

    chaserVelX = chaserVelX + moveX * speed
    chaserVelY = chaserVelY + moveY * speed
end

// --- drawing ---------------

func drawWorld
    drawEntity ""red"" ""darkred"" chaserX chaserY 5
end

func drawEntity col:string strokeCol:string x:num y:num size:num
    fill col
    stroke strokeCol
    move x y
    circle size
end

// --- utilities ------------

func spinColor:string deg:num
    deg = deg % 360
    col := sprintf ""hsl(%f 0%% 100%% / 2%%)"" deg
    return col
end

func constrain:num in:num minimum:num maximum:num
    if in < minimum
        return minimum
    else if in > maximum
        return maximum
    end
    return in
end

func direction:num x:num y:num toX:num toY:num
    deltaX := toX - x
    deltaY := toY - y
    return atan2 deltaY deltaX
end
",
035.evy,"// Return maximum element in the list.
// max_element([1, 2, 3]) // 3
// max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) // 123
func max_element:num nums:[]num
    result := nums[0]
    for n := range nums[1:]
        if result < n
            result = n
        end
    end
    return result
end

func testall
    test 3 (max_element [1 2 3])
    test 124 (max_element [5 3 -5 2 -3 3 9 0 124 1 -10])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult

",
021.evy,"// Given list of numbers (of at least two elements), apply a linear transform to that list,
// such that the smallest number will become 0 and the largest will become 1
// rescale_to_unit [1.0 2.0 3.0 4.0 5.0] // [0.0 0.25 0.5 0.75 1.0]
func rescale_to_unit:[]num numbers:[]num
    min_number := numbers[0]
    max_number := numbers[0]
    for n := range numbers
        if n < min_number
            min_number = n
        end
        if n > max_number
            max_number = n
        end
    end
    result:[]num
    for n := range numbers
        result = result + [(n - min_number)/(max_number - min_number)]
    end
    return result
end

func testall
    test [0 1] (rescale_to_unit [2 49.9])
    test [1 0] (rescale_to_unit [100 49.9])
    test [0 0.25 0.5 0.75 1] (rescale_to_unit [1 2 3 4 5])
    test [0.25 0 1 0.5 0.75] (rescale_to_unit [2 1 5 3 4])
    test [0.25 0 1 0.5 0.75] (rescale_to_unit [12 11 15 13 14])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
009.evy,"// From a given list of integers, generate an array of rolling maximum element found until given moment
// in the sequence.
// rollingMax([1, 2, 3, 2, 3, 4, 2]) // [1, 2, 3, 3, 3, 4, 4]
func rollingMax:[]num numbers:[]num
    if numbers == []
        return []
    end
    running_max := numbers[0]
    result:[]num
    for number := range numbers
        if number > running_max
            running_max = number
        end
        result = result + [running_max]
    end
    return result
end

func testall
    test [] (rollingMax [])
    test [1 2 3 4] (rollingMax [1 2 3 4])
    test [4 4 4 4] (rollingMax [4 3 2 1])
    test [3 3 3 100 100] (rollingMax [3 2 3 100 3])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
008.evy,"// For a given array of number, return an array consisting of a sum and a product of all the integers in the array.
// Empty sum should be equal to 0 and empty product should be equal to 1.
// sumProduct [] // (0, 1)
// sumProduct [1, 2, 3, 4] // (10, 24)
func sumProduct:[]num numbers:[]num
    sum_value := 0
    prod_value := 1
    for number := range numbers
        sum_value = sum_value + number
        prod_value = prod_value * number
    end
    return [sum_value prod_value]
end

func testall
    test [0 1] (sumProduct [])
    test [3 1] (sumProduct [1 1 1])
    test [100 0] (sumProduct [100 0])
    test [15 105] (sumProduct [3 5 7])
    test [10 10] (sumProduct [10])
end

func abs:num x:num
    if x < 0
        return -x
    end
    return x
end

fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if (sprintf ""%v"" want) != (sprintf ""%v"" got)
        fails = fails + 1
        printf ""want != got:\n want: %v\n got:  %v\n"" want got
    end
end

func finished
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
finished
",
020.evy,"// From a supplied list of numbers (of length at least two) select and return
// two that are the closest to each other and return them in order
// (smaller number, larger number).
//
// findClosest [1.0 2.0 3.0 4.0 5.0 2.2] // [2.0 2.2]
// findClosest [1.0 2.0 3.0 4.0 5.0 2.0] // [2.0 2.0]
func findClosest:[]num nums:[]num
    distance := -1
    length := len nums
    result := [0] * 2

    for i := range length
        for j := range length
            if i != j
                d := abs nums[i]-nums[j]
                if d < distance or distance == -1
                    distance = d
                    result[0] = nums[i]
                    result[1] = nums[j]
                end
            end
        end
    end
    if result[1] < result[0]
        return [result[1] result[0]]
    end
    return result
end

func abs:num n:num
    if n >= 0
        return n
    end
    return -n
end

func testall
    test [3.9 4] (findClosest [1 2 3.9 4 5 2.2])
    test [5 5.9] (findClosest [1 2 5.9 4 5])
    test [2 2.2] (findClosest [1 2 3 4 5 2.2])
    test [2 2] (findClosest [1 2 3 4 5 2])
    test [2.2 3.1] (findClosest [1.1 2.2 3.1 4.1 5.1])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult

",
034.evy,"// Return sorted unique elements in an array
// unique [5, 3, 5, 2, 3, 3, 9, 0, 123] [0, 2, 3, 5, 9, 123]
func unique:[]num nums:[]num
    if (len nums) < 2
        return nums
    end

    nums2 := nums[:]
    sort nums2
    result := [nums2[0]]

    for n := range nums2
        if n != result[-1]
            result = result + [n]
        end
    end
    return result
end

func sort arr:[]num
    // bubble sort
    for endIdx := range (len arr)-1 0 -1
        for i := range endIdx
            if arr[i] > arr[i + 1]
                tmp := arr[i]
                arr[i] = arr[i + 1]
                arr[i + 1] = tmp
            end
        end
    end
end

func testall
    test [0 2 3 5 9 123] (unique [5 3 5 2 3 3 9 0 123])
    test [] (unique [])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult

",
022.evy,"// Filter given list of any values for num
// filterInts [""a"", 3.14, 5] // [5]
// filterInts [1, 2, 3, ""abc"", {}, []] // [1, 2, 3]
func filterInts:[]num values:[]any
    result:[]num
    for a := range values
        if (typeof a) == ""num""
            n := a.(num)
            if n == (round n)
                result = result + [n]
            end
        end
    end
    return result
end

func testall
    test [] (filterInts [])
    test [4 9] (filterInts [4 {} [] 23.2 9 ""adasd""])
    test [3 3 3] (filterInts [3 ""c"" 3 3 ""a"" ""b""])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult

",
036.evy,"// Return the number of times the digit 7 appears in integers less than n
// which are divisible by 11 or 13.
// fizzBuzz 50 // 0
// fizzBuzz 78 // 2
// fizzBuzz 79 // 3
func fizzBuzz:num n:num
    str:string
    for i := range n
        if i % 11 == 0 or i % 13 == 0
            str = str + (sprint i)
        end
    end
    result := 0
    for ch := range str
        if ch == ""7""
            result = result + 1
        end
    end
    return result
end

func testall
    test 0 (fizzBuzz 50)
    test 2 (fizzBuzz 78)
    test 3 (fizzBuzz 79)
    test 3 (fizzBuzz 100)
    test 6 (fizzBuzz 200)
    test 192 (fizzBuzz 4000)
    test 639 (fizzBuzz 10000)
    test 8026 (fizzBuzz 100000)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult

",
037.evy,"// This function takes an array l and returns an array l' such that
//  l' is identical to l in the odd indices, while its values at the even indices are equal
//  to the values of the even indices of l, but sorted.
//
//  sortEven [1 2 3] // [1 2 3]
//  sortEven [5 6 3 4] // [3 6 5 4]
func sortEven:[]num nums:[]num
    even:[]num
    for i := range 0 (len nums) 2
        even = even + [nums[i]]
    end
    sort even
    result := [0] * (len nums)

    for i := range (len nums)
        if i % 2 == 0
            result[i] = even[i / 2]
        else
            result[i] = nums[i]
        end
    end
    return result
end

func sort arr:[]num
    // bubble sort
    for endIdx := range (len arr)-1 0 -1
        for i := range endIdx
            if arr[i] > arr[i + 1]
                tmp := arr[i]
                arr[i] = arr[i + 1]
                arr[i + 1] = tmp
            end
        end
    end
end

func testall
    test [1 2 3] (sortEven [1 2 3])
    test [-10 3 -5 2 -3 3 5 0 9 1 123] (sortEven [5 3 -5 2 -3 3 9 0 123 1 -10])
    test [-12 8 3 4 5 2 12 11 23 -10] (sortEven [5 8 -12 4 23 2 3 11 12 -10])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult

",
023.evy,"// Return length of given string
// strlen """" // 0
// strlen ""abc"" // 3
func strlen:num str:string
    return len str
end

func testall
    test 0 (strlen """")
    test 1 (strlen ""x"")
    test 9 (strlen ""asdasnakj"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult

",
027.evy,"// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
// flipCase ""Hello"" // ""hELLO""
func flipCase:string str:string
    result:string
    for i := range (len str)
        ch := str[i]
        if ""a"" <= ch
            result = result + (upper ch)
        else
            result = result + (lower ch)
        end

    end
    return result
end

func testall
    test """" (flipCase """")
    test ""hELLO!"" (flipCase ""Hello!"")
    test ""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"" (flipCase ""These violent delights have violent ends"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult

",
033.evy,"// This function takes an array l and returns an array l' such that l' is
// identical to l in the indices that are not divisible by three, while its
// values at the indices that are divisible by three are equal to the
// values of the corresponding indices of l, but sorted.
// sort_third [1 2 3] // [1 2 3]
// sort_third [5 6 3 4 8 9 2] // [2 6 3 4 8 9 5]
func sort_third:[]num nums:[]num
    div3:[]num
    for i := range 0 (len nums) 3
        div3 = div3 + [nums[i]]
    end
    sort div3
    result := [0] * (len nums)

    for i := range (len nums)
        if i % 3 == 0
            result[i] = div3[i / 3]
        else
            result[i] = nums[i]
        end
    end
    return result
end

func sort arr:[]num
    // bubble sort
    for endIdx := range (len arr)-1 0 -1
        for i := range endIdx
            if arr[i] > arr[i + 1]
                tmp := arr[i]
                arr[i] = arr[i + 1]
                arr[i + 1] = tmp
            end
        end
    end
end

func testall
    test [1 2 3] (sort_third [1 2 3])
    test [1 3 -5 2 -3 3 5 0 123 9 -10] (sort_third [5 3 -5 2 -3 3 9 0 123 1 -10])
    test [-10 8 -12 3 23 2 4 11 12 5] (sort_third [5 8 -12 4 23 2 3 11 12 -10])
    test [2 6 3 4 8 9 5] (sort_third [5 6 3 4 8 9 2])
    test [2 8 3 4 6 9 5] (sort_third [5 8 3 4 6 9 2])
    test [2 6 9 4 8 3 5] (sort_third [5 6 9 4 8 3 2])
    test [2 6 3 4 8 9 5 1] (sort_third [5 6 3 4 8 9 2 1])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult

",
026.evy,"//  From an array of integers, remove all elements that occur more than once.
//  Keep order of elements left the same as in the input.
//  removeDuplicates [1, 2, 3, 2, 4] //  [1, 3, 4]
func removeDuplicates:[]num nums:[]num
    seen:{}bool
    dups:{}bool
    result:[]num
    for n := range nums
        ns := sprint n
        if has seen ns
            dups[ns] = true
        end
        seen[ns] = true
    end
    for n := range nums
        ns := sprint n
        if !(has dups ns)
            result = result + [n]
        end
    end
    return result
end

func testall
    test [] (removeDuplicates [])
    test [1 2 3 4] (removeDuplicates [1 2 3 4])
    test [1 4 5] (removeDuplicates [1 2 3 2 4 3 5])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult

",
018.evy,"// Find how many times a given substring can be found in the original string.
// Count overlapping cases.
// findTimes "" """" // 0
// findTimes ""aa"" """" // 3
// findTimes ""aaa"" ""a"" // 3
func findTimes:num str:string sub:string
    times := 0
    rend := (len str) - (len sub) + 1
    for i := range rend
        if str[i:i + (len sub)] == sub
            times = times + 1
        end
    end
    return times
end

func testall
    test 0 (findTimes """" ""x"")
    test 4 (findTimes ""xyxyxyx"" ""x"")
    test 4 (findTimes ""cacacacac"" ""cac"")
    test 1 (findTimes ""john doe"" ""john"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult

",
030.evy,"// Return only positive numbers in the list.
// getPositive [-1 2 -4 5 6] // [2, 5, 6]
// getPositive [5 3 -5 2 -3 3 9 0 123 1 -10] // [5 3 2 3 9 123 1]
func getPositive:[]num nums:[]num
    result:[]num
    for n := range nums
        if n > 0
            result = result + [n]
        end
    end
    return result
end

func testall
    test [4 5 6] (getPositive [-1 -2 4 5 6])
    test [5 3 2 3 3 9 123 1] (getPositive [5 3 -5 2 3 3 9 0 123 1 -10])
    test [] (getPositive [-1 -2])
    test [] (getPositive [])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult

",
024.evy,"// For a given number n, find the largest number that divides n evenly, smaller than n
// largestDivisor(15) // 5
func largestDivisor:num n:num
    for i := range n-1 0 -1
        if n % i == 0
            return i
        end
    end
    return -1
end

func testall
    test 1 (largestDivisor 3)
    test 1 (largestDivisor 7)
    test 5 (largestDivisor 10)
    test 50 (largestDivisor 100)
    test 7 (largestDivisor 49)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult

",
025.evy,"// Return list of prime factors of given integer in the order from smallest to
// largest. Each of the factors should be listed number of times
// corresponding to how many times it appears in factorization. Input number
// should be equal to the product of all factors
// factorize 8 // [2, 2, 2]
// factorize 25 // [5, 5]
// factorize 70 // [2, 5, 7]
func factorize:[]num n:num
    result:[]num
    i := 2
    while i <= (sqrt n) + 1
        if n % i == 0
            result = result + [i]
            n = n / i
        else
            i = i + 1
        end
    end
    if n > 1
        result = result + [n]
    end
    return result
end

func testall
    test [2] (factorize 2)
    test [2 2] (factorize 4)
    test [2 2 2] (factorize 8)
    test [3 19] (factorize 3*19)
    test [3 3 19 19] (factorize 3*19*3*19)
    test [3 3 3 19 19 19] (factorize 3*19*3*19*3*19)
    test [3 19 19 19] (factorize 3*19*19*19)
    test [2 3 3] (factorize 3*2*3)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult

",
031.evy,"// Return true if a given number is prime, and false otherwise.
// isPrime 6 // false
// isPrime 101 // true
// isPrime 11 // true
// isPrime 13441 // true
// isPrime 61 // true
// isPrime 4 // false
// isPrime 1 // false
func isPrime:bool n:num
    if n < 2
        return false
    end
    for k := range 2 (sqrt n)+1
        if n % k == 0
            return false
        end
    end
    return true
end

func testall
    test false (isPrime 6)
    test true (isPrime 101)
    test true (isPrime 11)
    test true (isPrime 13441)
    test true (isPrime 61)
    test false (isPrime 4)
    test false (isPrime 1)
    test true (isPrime 5)
    test true (isPrime 11)
    test true (isPrime 17)
    test false (isPrime 5*17)
    test false (isPrime 11*7)
    test false (isPrime 13441*19)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult

",
019.evy,"// Input is a space-delimited string of numerals from ""zero"" to ""nine"".
// Valid choices are ""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"" and ""nine"".
// Return the string with numbers sorted from smallest to largest
// sortNumbers ""three one five"" // ""one three five""
func sortNumbers:string numbers:string
    map := {zero:0 one:1 two:2 three:3 four:4 five:5 six:6 seven:7 eight:8 nine:9}
    arr := split numbers "" ""
    // bubble sort
    for endIdx := range (len arr)-1 0 -1
        for i := range endIdx
            if map[arr[i]] > map[arr[i + 1]]
                tmp := arr[i]
                arr[i] = arr[i + 1]
                arr[i + 1] = tmp
            end
        end
    end
    return join arr "" ""
end

func testall
    test """" (sortNumbers """")
    test ""three"" (sortNumbers ""three"")
    test ""three five nine"" (sortNumbers ""three five nine"")
    test ""zero four five seven eight nine"" (sortNumbers ""five zero four seven nine eight"")
    test ""zero one two three four five six"" (sortNumbers ""six five four three two one zero"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult

",
095.evy,"// Given a dictionary, return true if all keys are strings in lower
// case or all keys are strings in upper case, else return false.
// The function should return false if the given dictionary is empty.
// sameCaseKey {""a"":""apple"", ""b"":""banana""} // true
// sameCaseKey {""a"":""apple"", ""A"":""banana"", ""B"":""banana""} // false
// sameCaseKey {""a"":""apple"", 8:""banana"", ""a"":""apple""} // false
// sameCaseKey {""Name"":""John"", ""Age"":""36"", ""City"":""Houston""} // false
// sameCaseKey {""STATE"":""NC"", ""ZIP"":""12345"" } // true
func sameCaseKey:bool m:{}string
    up := false
    low := false
    for key := range m
        lkey := lower key
        ukey := upper key
        if key == lkey and key != ukey
            low = true
        else if key == ukey and key != lkey
            up = true
        else
            return false // no letters in key
        end
    end
    return up != low
end

func testall
    test true (sameCaseKey {p:""pineapple"" b:""banana""})
    test false (sameCaseKey {p:""pineapple"" A:""banana"" B:""banana""})
    test false (sameCaseKey {p:""pineapple"" _:""banana"" a:""apple""})
    test false (sameCaseKey {Name:""John"" Age:""36"" City:""Houston""})
    test true (sameCaseKey {STATE:""NC"" ZIP:""12345""})
    test true (sameCaseKey {fruit:""Orange"" taste:""Sweet""})
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if wantType == ""[]"" or wantType == ""{}"" and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
081.evy,"//  It is the last week of the semester and the teacher has to give the grades
//  to students. The teacher has been making her own algorithm for grading.
//  The only problem is, she has lost the code she used for grading.
//  She has given you an array of GPAs for some students and you have to write
//  a function that can output an array of letter grades using the following table:
//           GPA       |    Letter grade
//            4.0                A+
//          > 3.7                A
//          > 3.3                A-
//          > 3.0                B+
//          > 2.7                B
//          > 2.3                B-
//          > 2.0                C+
//          > 1.7                C
//          > 1.3                C-
//          > 1.0                D+
//          > 0.7                D
//          > 0.0                D-
//            0.0                E
//  Example:
//  grade_equation [4.0, 3, 1.7, 2, 3.5]  ==> [""A+"", ""B"", ""C-"", ""C"", ""A-""]
func grades:[]string gpas:[]num
    result:[]string
    for gpa := range gpas
        result = result + [(grade gpa)]
    end
    return result
end

func grade:string gpa:num
    if gpa == 4
        return ""A+""
    else if gpa > 3.7
        return ""A""
    else if gpa > 3.3
        return ""A-""
    else if gpa > 3
        return ""B+""
    else if gpa > 2.7
        return ""B""
    else if gpa > 2.3
        return ""B-""
    else if gpa > 2
        return ""C+""
    else if gpa > 1.7
        return ""C""
    else if gpa > 1.3
        return ""C-""
    else if gpa > 1
        return ""D+""
    else if gpa > 0.7
        return ""D""
    else if gpa > 0
        return ""D-""
    else if gpa == 0
        return ""E""
    end
    return sprint ""invalid gpa"" gpa
end

func testall
    test [""A+"" ""B"" ""C-"" ""C"" ""A-""] (grades [4 3 1.7 2 3.5])
    test [""D+""] (grades [1.2])
    test [""D-""] (grades [0.5])
    test [""E""] (grades [0])
    test [""D"" ""D-"" ""C-"" ""B"" ""B+""] (grades [1 0.3 1.5 2.8 3.3])
    test [""E"" ""D-""] (grades [0 0.7])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if wantType == ""[]"" or wantType == ""{}"" and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
056.evy,"// brackets is a string of ""<"" and "">"". return true if every opening bracket
// has a corresponding closing bracket.
//
// correctBracketing ""<"" // false
// correctBracketing ""<>"" // true
// correctBracketing ""<<><>>"" // true
// correctBracketing ""><<>"" // false
func checkBrackets:bool str:string
    depth := 0
    for ch := range str
        if ch == ""<""
            depth = depth + 1
        else
            depth = depth - 1
        end
        if depth < 0
            return false
        end
    end
    return depth == 0
end

func testall
    test true (checkBrackets """")
    test true (checkBrackets ""<>"")
    test true (checkBrackets ""<<><>>"")
    test true (checkBrackets ""<><><<><>><>"")
    test true (checkBrackets ""<><><<<><><>><>><<><><<>>>"")
    test false (checkBrackets ""<<<><>>>>"")
    test false (checkBrackets ""><<>"")
    test false (checkBrackets ""<"")
    test false (checkBrackets ""<<<<"")
    test false (checkBrackets "">"")
    test false (checkBrackets ""<<>"")
    test false (checkBrackets ""<><><<><>><>><<>"")
    test false (checkBrackets ""<><><<><>><>>><>"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
042.evy,"//""Return list with elements incremented by 1.
// inc [1 2 3] // [2 3 4]
// inc [5 3 5 2 3 3 9 0 123] // [6 4 6 3 4 4 10 1 124]
func inc:[]num nums:[]num
    result := nums[:]
    for i := range (len result)
        result[i] = result[i] + 1
    end
    return result
end

func testall
    test [] (inc [])
    test [4 3 2] (inc [3 2 1])
    test [6 3 6 3 4 4 10 1 124] (inc [5 2 5 2 3 3 9 0 123])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
043.evy,"// sumZero takes an array of integers as an input.
// it returns True if there are two distinct elements in the list that
// sum to zero, and False otherwise.
// sumZero [1 3 5 0] // false
// sumZero [1 3 -2 1] // false
// sumZero [1 2 3 7] // false
// sumZero [2 4 -5 3 5 7] // true
// sumZero [1] // false
func sumZero:bool nums:[]num
    length := len nums
    for i := range length
        for j := range i+1 length
            if nums[i] + nums[j] == 0
                return true
            end
        end
    end
    return false
end

func testall
    test false (sumZero [1 3 5 0])
    test false (sumZero [1 3 -2 1])
    test false (sumZero [1 2 3 7])
    test true (sumZero [2 4 -5 3 5 7])
    test false (sumZero [1])
    test true (sumZero [-3 9 -1 3 2 30])
    test true (sumZero [-3 9 -1 3 2 31])
    test false (sumZero [-3 9 -1 4 2 30])
    test false (sumZero [-3 9 -1 4 2 31])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
057.evy,"// Return true if list elements are monotonically increasing or decreasing.
// monotonic([1, 2, 4, 20]) // true
// monotonic([1, 20, 4, 10]) // false
// monotonic([4, 1, 0, -10]) // true
func monotonic:bool nums:[]num
    numsInc := nums[:]
    numsDec := nums[:]
    sort numsInc true
    sort numsDec false
    return nums == numsInc or nums == numsDec
end

func sort arr:[]num inc:bool
    // bubble sort
    for endIdx := range (len arr)-1 0 -1
        for i := range endIdx
            if (inc and arr[i] > arr[i + 1]) or (!inc and arr[i] < arr[i + 1])
                tmp := arr[i]
                arr[i] = arr[i + 1]
                arr[i + 1] = tmp
            end
        end
    end
end

func testall
    test true (monotonic [1 2 4 10])
    test true (monotonic [1 2 4 20])
    test false (monotonic [1 20 4 10])
    test true (monotonic [4 1 0 -10])
    test true (monotonic [4 1 1 0])
    test false (monotonic [1 2 3 2 5 60])
    test true (monotonic [1 2 3 4 5 60])
    test true (monotonic [9 9 9 9])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
080.evy,"//  You are given a string s. Your task is to check if the string is happy or
//  not. A string is happy if its length is at least 3 and every 3
//  consecutive letters are distinct
//
//  For example:
//  happy ""a"" // false
//  happy ""aa"" // false
//  happy ""abcd"" // true
//  happy ""aabb"" // false
//  happy ""adb"" // true
//  happy ""xyy"" // false
func happy:bool s:string
    length := len s
    if length < 3
        return false
    end
    for i := range length-2
        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]
            return false
        end
    end
    return true
end

func testall
    test false (happy ""a"")
    test false (happy ""aa"")
    test true (happy ""abcd"")
    test false (happy ""aabb"")
    test true (happy ""adb"")
    test false (happy ""xyy"")
    test true (happy ""iopaxpoi"")
    test false (happy ""iopaxioi"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if wantType == ""[]"" or wantType == ""{}"" and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
094.evy,"// Given an array of integers find the largest prime value and return the sum
// of its digits.
// largestPrimeSumOfDigits [0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3] // 10
// largestPrimeSumOfDigits [1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1] // 25
// largestPrimeSumOfDigits [1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3] // 13
// largestPrimeSumOfDigits [0 724 32 71 99 32 6 0 5 91 83 0 5 6] // 11
// largestPrimeSumOfDigits [0 81 12 3 1 21] // 3
// largestPrimeSumOfDigits [0 8 1 2 1 7] // 7
func largestPrimeSumOfDigits:num nums:[]num
    largest := 0
    for n := range nums
        if (isPrime n) and n > largest
            largest = n
        end
    end
    return sumOfDigits largest
end

func isPrime:bool n:num
    if n < 2
        return false
    end
    for i := range 2 n
        if n % i == 0
            return false
        end
    end
    return true
end

func sumOfDigits:num n:num
    result := 0
    while n > 0
        result = result + n % 10
        n = floor n/10
    end
    return result
end

func testall
    test 10 (largestPrimeSumOfDigits [0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3])
    test 25 (largestPrimeSumOfDigits [1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1])
    test 13 (largestPrimeSumOfDigits [1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3])
    test 11 (largestPrimeSumOfDigits [0 724 32 71 99 32 6 0 5 91 83 0 5 6])
    test 3 (largestPrimeSumOfDigits [0 81 12 3 1 21])
    test 7 (largestPrimeSumOfDigits [0 8 1 2 1 7])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if wantType == ""[]"" or wantType == ""{}"" and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
109.evy,"// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The
// numbers in the array will be randomly ordered. Your task is to determine if
// it is possible to get an array sorted in non-decreasing order by performing
// the following operation on the given array:
//     You are allowed to perform right shift operation any number of times.
//
// One right shift operation means shifting all elements of the array by one
// position in the right direction. The last element of the array will be moved to
// the starting position in the array i.e. 0th index.
//
// If it is possible to obtain the sorted array by performing the above operation
// then return true else return false.
// If the given array is empty then return true.
//
// Note: The given list is guaranteed to have unique elements.
//
// For Example:
//
// sortedWithShift [3 4 5 1 2] // true
// Explanation: By performing 2 right shift operations non-decreasing order can
//              be achieved for the given array.
// sortedWithShift [3 5 4 1 2]) // false
// Explanation:It is not possible to get non-decreasing order for the given
//             array by performing any number of right shift operations.
func sortedWithShift:bool nums:[]num
    greaterThanNext := 0
    for i := range (len nums)-1
        if nums[i] > nums[i + 1]
            greaterThanNext = greaterThanNext + 1
        end
    end
    return greaterThanNext == 0 or (greaterThanNext == 1 and nums[-1] < nums[0])
end

func testall
    test true (sortedWithShift [3 4 5 1 2])
    test true (sortedWithShift [3 5 10 1 2])
    test false (sortedWithShift [4 3 1 2])
    test false (sortedWithShift [3 5 4 1 2])
    test true (sortedWithShift [])
    test true (sortedWithShift [1])
    test true (sortedWithShift [1 2])
    test true (sortedWithShift [2 1])
    test true (sortedWithShift [2 3 1])
    test false (sortedWithShift [2 1 3])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
082.evy,"//  Write a function that takes a string and returns true if the string
//  length is a prime number or false otherwise
//  Examples
//  primeLength ""Hello"" // true
//  primeLength ""abcdcba"" // true
//  primeLength ""kittens"" // true
//  primeLength ""orange"" // false
func primeLength:bool s:string
    length := len s
    if length <= 1
        return false
    end
    for i := range 2 (sqrt length+1)
        if length % i == 0
            return false
        end
    end
    return true
end

func testall
    test true (primeLength ""Hello"")
    test true (primeLength ""abcdcba"")
    test true (primeLength ""kittens"")
    test false (primeLength ""orange"")
    test true (primeLength ""wow"")
    test true (primeLength ""world"")
    test true (primeLength ""MadaM"")
    test true (primeLength ""Wow"")
    test false (primeLength """")
    test true (primeLength ""HI"")
    test true (primeLength ""go"")
    test false (primeLength ""gogo"")
    test false (primeLength ""aaaaaaaaaaaaaaa"")
    test true (primeLength ""Madam"")
    test false (primeLength ""M"")
    test false (primeLength ""0"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if wantType == ""[]"" or wantType == ""{}"" and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
096.evy,"// Implement a function that takes an non-negative integer and returns an array of the first n
// integers that are prime numbers and less than n.
// for example:
// primesTo 5)// [2 3]
// primesTo 11 // [2 3 5 7]
// primesTo 0 // []
// primesTo 20 // [2 3 5 7 11 13 17 19]
// primesTo 1 // []
// primesTo 18 // [2 3 5 7 11 13 17]
func primesTo:[]num n:num
    result:[]num
    for i := range 2 n
        if (isPrime i)
            result = result + [i]
        end
    end
    return result
end

func isPrime:bool n:num
    if n < 2
        return false
    end
    for i := range 2 n
        if n % i == 0
            return false
        end
    end
    return true
end

func testall
    test [2 3] (primesTo 5)
    test [2 3 5] (primesTo 6)
    test [2 3 5] (primesTo 7)
    test [2 3 5 7] (primesTo 10)
    test [] (primesTo 0)
    test [2 3 5 7 11 13 17 19] (primesTo 22)
    test [] (primesTo 1)
    test [2 3 5 7 11 13 17] (primesTo 18)
    test [2 3 5 7 11 13 17 19 23 29 31 37 41 43] (primesTo 47)
    test [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97] (primesTo 101)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if wantType == ""[]"" or wantType == ""{}"" and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
041.evy,"//  Imagine a road that's a perfectly straight infinitely long line.
//  n cars are driving left to right;  simultaneously, a different set of n cars
//  are driving right to left.   The two sets of cars start out being very far from
//  each other.  All cars move in the same speed.  Two cars are said to collide
//  when a car that's moving left to right hits a car that's moving right to left.
//  However, the cars are infinitely sturdy and strong; as a result, they continue moving
//  in their trajectory as if they did not collide.
//
//  This function outputs the number of such collisions.
func collisions:num n:num
    return n * n
end

func testall
    test 4 (collisions 2)
    test 9 (collisions 3)
    test 16 (collisions 4)
    test 64 (collisions 8)
    test 100 (collisions 10)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
055.evy,"// Return n-th Fibonacci number.
// fib 10  // 55
// fib 1  // 1
// fib 8  // 21
func fib:num n:num
    if n < 2
        return n
    end
    return (fib n-1) + (fib n-2)
end

func testall
    test 55 (fib 10)
    test 1 (fib 1)
    test 21 (fib 8)
    test 89 (fib 11)
    test 144 (fib 12)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
069.evy,"// You are given a non-empty list of positive integers. Return the  greatest
// integer that is greater than zero, and has a frequency greater than or
// equal to the value of the integer itself. The frequency of an integer is
// the number of times it appears in the list. If no such a value exist,
// return -1.
// Examples:
//     (search [4 1 2 2 3 1]) == 2
//     (search [1 2 2 3 3 3 4 4 4]) == 3
//     (search [5 5 4 4 4]) == -1
func search:num nums:[]num
    freq:{}num
    for n := range nums
        ns := sprint n
        if has freq ns
            freq[ns] = freq[ns] + 1
        else
            freq[ns] = 1
        end
    end

    result := -1
    for ns := range freq
        f := freq[ns]
        n := str2num ns
        if f >= n and n > result
            result = n
        end
    end
    return result
end

func testall
    test 1 (search [5 5 5 5 1])
    test 4 (search [4 1 4 1 4 4])
    test -1 (search [3 3])
    test 8 (search [8 8 8 8 8 8 8 8])
    test 2 (search [2 3 3 2 2])
    test 1 (search [2 7 8 8 4 8 7 3 9 6 5 10 4 3 6 7 1 7 4 10 8 1])
    test 2 (search [3 2 8 2])
    test 1 (search [6 7 1 8 8 10 5 8 5 3 10])
    test -1 (search [8 8 3 6 5 6 4])
    test 1 (search [6 9 6 7 1 4 7 1 8 8 9 8 10 10 8 4 10 4 10 1 2 9 5 7 9])
    test 1 (search [1 9 10 1 3])
    test 5 (search [6 9 7 5 8 7 5 3 7 5 10 10 3 6 10 2 8 6 5 4 9 5 3 10])
    test 1 (search [1])
    test 4 (search [8 8 10 6 4 3 5 8 2 4 2 8 4 6 10 4 2 1 10 2 1 1 5])
    test 2 (search [2 10 4 8 2 10 5 1 2 9 5 5 6 3 8 6 4 10])
    test 1 (search [1 6 10 1 6 9 10 8 6 8 7 3])
    test 4 (search [9 2 4 1 5 1 5 2 5 7 7 7 3 10 1 5 4 2 8 4 1 9 10 7 10 2 8 10 9 4])
    test 4 (search [2 6 4 2 8 7 5 6 4 10 4 6 3 7 8 8 3 1 4 2 2 10 7])
    test 2 (search [9 8 6 10 2 6 10 2 7 8 10 3 8 2 6 2 3 1])
    test -1 (search [5 5 3 9 5 6 3 2 8 5 6 10 10 6 8 4 10 7 7 10 8])
    test -1 (search [10])
    test 2 (search [9 7 7 2 4 7 2 10 9 7 5 7 2])
    test 1 (search [5 4 10 2 1 1 10 3 6 1 8])
    test 1 (search [7 9 9 9 3 4 1 5 9 1 2 1 1 10 7 5 6 7 6 7 7 6])
    test -1 (search [3 10 10 9 2])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
068.evy,"// Given an array representing a branch of a tree that has non-negative
// integer nodes your task is to pluck one of the nodes and return it. The
// plucked node should be the node with the smallest even value. If multiple
// nodes with the same smallest even value are found return the node that has
// smallest index.
//
// The plucked node should be returned in an array, [ smalest_value, its index ],
// If there are no even values or the given array is empty, return [].
//
// Example 1:
//   Input: [4 2 3]
//   Output: [2 1]
//   Explanation: 2 has the smallest even value, and 2 has the smallest index.
//
// Example 2:
//   Input: [1 2 3]
//   Output: [2 1]
//   Explanation: 2 has the smallest even value, and 2 has the smallest index.
//
// Example 3:
//   Input: []
//   Output: []
//
// Example 4:
//   Input: [5, 0, 3, 0, 4, 2]
//   Output: [0, 1]
//   Explanation: 0 is the smallest value, but  there are two zeros,
//   so we will choose the first zero, which has the smallest index.
//
// Constraints:
//     1 <= len(nodes) <= 10000
//     0 <= val
func pluck:[]num nums:[]num
    idx := -1
    val := -1
    for i := range (len nums)
        n := nums[i]
        if n % 2 == 0 and (val == -1 or n < val)
            idx = i
            val = n
        end
    end
    if idx == -1
        return []
    end
    return [val idx]
end

func testall
    test [2 1] (pluck [4 2 3])
    test [2 1] (pluck [1 2 3])
    test [] (pluck [])
    test [0 1] (pluck [5 0 3 0 4 2])
    test [0 3] (pluck [1 2 3 0 5 3])
    test [4 1] (pluck [5 4 8 4 8])
    test [6 1] (pluck [7 6 7 1])
    test [] (pluck [7 9 7 1])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
054.evy,"// Check if two words have the same characters.
// sameChars ""eabcdzzzz"" ""dddzzzzzzzddeddabc"" // true
// sameChars ""abcd"" ""dddddddabc"" // true
// sameChars ""dddddddabc"" ""abcd"" // true
// sameChars ""eabcd"" ""dddddddabc"" // false
// sameChars ""abcd"" ""dddddddabce"" // false
// sameChars ""eabcdzzzz"" ""dddzzzzzzzddddabc"" // false
func sameChars:bool s1:string s2:string
    return (set s1) == (set s2)
end

func set:{}bool s:string
    result:{}bool
    for c := range s
        result[c] = true
    end
    return result
end

func testall
    test true (sameChars ""eabcdzzzz"" ""dddzzzzzzzddeddabc"")
    test true (sameChars ""abcd"" ""dddddddabc"")
    test true (sameChars ""dddddddabc"" ""abcd"")
    test false (sameChars ""eabcd"" ""dddddddabc"")
    test false (sameChars ""abcd"" ""dddddddabcf"")
    test false (sameChars ""eabcdzzzz"" ""dddzzzzzzzddddabc"")
    test false (sameChars ""aabb"" ""aaccc"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
040.evy,"// tripleSumZero takes an array of integers as an input.
// it returns True if there are three distinct elements in the list that
// sum to zero, and False otherwise.
// tripleSumZero [1 3 5 0] // false
// tripleSumZero [1 3 -2 1] // true
// tripleSumZero [1 2 3 7] // false
// tripleSumZero [2 4 -5 3 9 7] // true
// tripleSumZero [1] // false
func tripleSumZerol:bool nums:[]num
    length := len nums
    for i := range length
        for j := range i+1 length
            for k := range j+1 length
                if nums[i] + nums[j] + nums[k] == 0
                    return true
                end
            end
        end
    end
    return false
end

func testall
    test false (tripleSumZerol [1 3 5 0])
    test false (tripleSumZerol [1 3 5 -1])
    test true (tripleSumZerol [1 3 -2 1])
    test false (tripleSumZerol [1 2 3 7])
    test false (tripleSumZerol [1 2 5 7])
    test true (tripleSumZerol [2 4 -5 3 9 7])
    test false (tripleSumZerol [1])
    test false (tripleSumZerol [1 3 5 -100])
    test false (tripleSumZerol [100 3 5 -100])

end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
097.evy,"//  Complete the function that takes two integers and returns
//  the product of their unit digits.
//  Assume the input is always valid.
//  Examples:
//  multiply 148, 412  should return 16.
//  multiply 19, 28  should return 72.
//  multiply 2020, 1851  should return 0.
//  multiply 14,-15  should return 20.
func multiply:num a:num b:num
    result := (a % 10) * (b % 10)
    if result < 0
        return -result
    end
    return result
end

func testall
    test 16 (multiply 148 412)
    test 72 (multiply 19 28)
    test 0 (multiply 2020 1851)
    test 20 (multiply 14 -15)
    test 42 (multiply 76 67)
    test 49 (multiply 17 27)
    test 0 (multiply 0 1)
    test 0 (multiply 0 0)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if wantType == ""[]"" or wantType == ""{}"" and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
083.evy,"//  Given a positive integer n, return the count of the numbers of n-digit
//  positive integers that start or end with 1.
func count1:num n:num
    if n == 1
        return 1
    end
    return 18 * (pow 10 n-2)
end

func testall
    test 1 (count1 1)
    test 18 (count1 2)
    test 180 (count1 3)
    test 1800 (count1 4)
    test 18000 (count1 5)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if wantType == ""[]"" or wantType == ""{}"" and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
108.evy,"// Write a function countNums which takes an array of integers and returns
// the number of elements which has a sum of digits > 0.
// If a number is negative, then its first signed digit will be negative:
// e.g. -123 has signed digits -1, 2, and 3.
// countNums [] // 0
// countNums [-1, 11, -11] // 1
// countNums [1, 1, 2] // 3
func countNums:num nums:[]num
    result := 0
    for n := range nums
        if n > 0
            result = result + 1
        else
            sum := digitSum n
            if sum > 0
                result = result + 1
            end
        end
    end
    return result
end

func digitSum:num n:num
    if n >= 0
        return 0
    end
    s := (sprint n)
    sum := -(str2num s[1])
    for digit := range s[2:]
        sum = sum + (str2num digit)
    end
    return sum
end

func testall
    test 0 (countNums [])
    test 0 (countNums [-1 -2 0])
    test 6 (countNums [1 1 2 -2 3 4 5])
    test 5 (countNums [1 6 9 -6 0 1 5])
    test 4 (countNums [1 100 98 -7 1 -1])
    test 5 (countNums [12 23 34 -45 -56 0])
    test 1 (countNums [-0 1])
    test 1 (countNums [1])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
118.evy,"// You are given a word. Your task is to find the closest vowel that stands between
// two consonants from the right side of the word (case sensitive).
//
// Vowels in the beginning and ending don't count. Return empty string if you didn't
// find any vowel that met the above condition.
//
// You may assume that the given string contains English letter only.
//
// Example:
// get_closest_vowel(""yogurt"") ==> ""u""
// get_closest_vowel(""FULL"") ==> ""U""
// get_closest_vowel(""quick"") ==> """"
// get_closest_vowel(""ab"") ==> """"
func findVowel:string s:string
    if (len s) < 3
        return """"
    end
    vowels := {a:true e:true i:true o:true u:true A:true E:true O:true U:true I:true}
    for i := range (len s)-2 0 -1
        if (has vowels s[i]) and !(has vowels s[i + 1]) and !(has vowels s[i - 1])
            return s[i]
        end
    end
    return """"
end

func testall
    test ""u"" (findVowel ""yogurt"")
    test ""u"" (findVowel ""full"")
    test """" (findVowel ""easy"")
    test """" (findVowel ""eAsy"")
    test """" (findVowel ""ali"")
    test ""a"" (findVowel ""bad"")
    test ""o"" (findVowel ""most"")
    test """" (findVowel ""ab"")
    test """" (findVowel ""ba"")
    test """" (findVowel ""quick"")
    test ""i"" (findVowel ""anime"")
    test """" (findVowel ""Asia"")
    test ""o"" (findVowel ""Above"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
087.evy,"//  You are given a 2 dimensional data set  as a nested lists, which is
//  similar to a matrix, however, unlike matrices, each row may contain a
//  different number of columns. Given lst, and integer x, find integers x in
//  the list, and return list of tuples, [ x1, y1 ,  x2, y2  ...] such that
//  each tuple is a coordinate -  row, columns , starting with 0. Sort
//  coordinates initially by rows in ascending order. Also, sort coordinates
//  of the row by columns in descending order.
//
//  Examples:
//  coords [
//    [1 2 3 4 5 6]
//    [1 2 3 4 1 6]
//    [1 2 3 4 5 1]
//  ] 1 == [0 0 1 4 1 0 2 5 2 0]
//  coords []  1  == []
//  coords [[]  [1]  [1  2  3]]  3  == [ 2  2 ]
func coords:[]num m:[][]num n:num
    result:[]num
    for i := range (len m)
        row := m[i]
        for j := range (len row)-1 -1 -1
            if row[j] == n
                result = result + [i j]
            end
        end
    end
    return result
end

func testall
    test [[0 0] [1 4] [1 0] [2 5] [2 0]] (coords [[1 2 3 4 5 6] [1 2 3 4 1 6] [1 2 3 4 5 1]] 1)
    test [[0 1] [1 1] [2 1] [3 1] [4 1] [5 1]] (coords [[1 2 3 4 5 6] [1 2 3 4 5 6] [1 2 3 4 5 6] [1 2 3 4 5 6] [1 2 3 4 5 6] [1 2 3 4 5 6]] 2)
    test [[0 0] [1 0] [2 1] [2 0] [3 2] [3 0] [4 3] [4 0] [5 4] [5 0] [6 5] [6 0]] (coords [[1 2 3 4 5 6] [1 2 3 4 5 6] [1 1 3 4 5 6] [1 2 1 4 5 6] [1 2 3 1 5 6] [1 2 3 4 1 6] [1 2 3 4 5 1]] 1)
    test [] (coords [] 1)
    test [] (coords [[1]] 2)
    test [[2 2]] (coords [[] [1] [1 2 3]] 3)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if wantType == ""[]"" or wantType == ""{}"" and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
093.evy,"//  Write a function that takes a message, and encodes in such a way that it
//  swaps case of all letters, replaces all vowels in the message with the
//  letter that appears 2 places ahead of that vowel in the English alphabet.
//  Assume only letters.
//
//  Examples:
//  >>> encode ""test""
//  ""TGST""
//  >>> encode ""This is a message""
//  ""tHKS KS C MGSSCGG""
func encode:string str:string
    map := {a:""c"" e:""g"" i:""k"" o:""q"" u:""w"" A:""C"" E:""G"" I:""K"" O:""Q"" U:""W""}
    result:string
    for i := range (len str)
        ch := str[i]
        if has map ch
            ch = map[ch]
        end
        if ""a"" <= ch
            result = result + (upper ch)
        else
            result = result + (lower ch)
        end
    end
    return result
end

func testall
    test ""TGST"" (encode ""test"")
    test ""mWDCSKR"" (encode ""Mudasir"")
    test ""ygs"" (encode ""YES"")
    test ""tHKS KS C MGSSCGG"" (encode ""This is a message"")
    test ""k dQnT kNqW wHcT Tq wRkTg"" (encode ""I DoNt KnOw WhAt tO WrItE"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
078.evy,"// You have been tasked to write a function that receives
// a hexadecimal number as a string and counts the number of hexadecimal
// digits that are primes (prime number, or a prime, is a natural number
// greater than 1 that is not a product of two smaller natural numbers).
// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
// So you have to determine a number of the following digits: 2, 3, 5, 7,
// B (=decimal 11), D (=decimal 13).
// Note: you may assume the input is always correct or empty string,
// and symbols A,B,C,D,E,F are always uppercase.
// Examples:
// hexprimes ""AB"" // 1
// hexprimes ""1077E"" // 2
// hexprimes ""ABED1A33"" // 4
// hexprimes ""123456789ABCDEF0"" // 6
// hexprimes ""2020"" // 2
func hexprimes:num str:string
    primes := {}
    for p := range ""2357BD""
        primes[p] = true
    end
    result := 0
    for ch := range str
        if (has primes ch)
            result = result + 1
        end
    end
    return result
end

func testall
    test 1 (hexprimes ""AB"")
    test 2 (hexprimes ""1077E"")
    test 4 (hexprimes ""ABED1A33"")
    test 2 (hexprimes ""2020"")
    test 6 (hexprimes ""123456789ABCDEF0"")
    test 12 (hexprimes ""112233445566778899AABBCCDDEEFF00"")
    test 0 (hexprimes """")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
044.evy,"// Change numerical base of input number x to base.
// return string representation after the conversion.
// base numbers are less than 10.
// convertBase 8 3 // ""22""
// convertBase 8 2 // ""1000""
// convertBase 7 2 // ""111""
func convertBase:string n:num base:num
    if n == 0
        return ""0""
    end
    result := """"
    while n > 0
        result = (sprint n%base) + result
        n = floor n/base
    end
    return result
end

func testall
    test ""22"" (convertBase 8 3)
    test ""100"" (convertBase 9 3)
    test ""11101010"" (convertBase 234 2)
    test ""10000"" (convertBase 16 2)
    test ""1000"" (convertBase 8 2)
    test ""111"" (convertBase 7 2)
    for x := range 9
        test (sprint x) (convertBase x x+1)
    end
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
050.evy,"abc := ""abcdefghijklmnopqrstuvwxyz""
ord := {a:0 b:1 c:2 d:3 e:4 f:5 g:6 h:7 i:8 j:9 k:10 l:11 m:12 n:13 o:14 p:15 q:16 r:17 s:18 t:19 u:20 v:21 w:22 x:23 y:24 z:25}

// encode returns encoded string by shifting every character by 5 in the
// alphabet. Message is all lowercase ascii.
func encode:string str:string
    result := """"
    for ch := range str
        result = result + abc[(ord[ch] + 5) % 26]
    end
    return result
end

// decode takes as input string encoded with encode_shift function. Returns
// decoded string.
func decode:string str:string
    result := """"
    for ch := range str
        result = result + abc[(ord[ch] + 21) % 26]
    end
    return result
end

func testall
    test """" (encode """")
    test """" (decode """")
    test ""fg"" (encode ""ab"")
    test ""ab"" (decode ""fg"")
    test abc (decode (encode abc))
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
051.evy,"// removeVowels is a function that takes string and returns string without vowels.
// removeVowels """" // """"
// removeVowels ""abcdefghijklm""  // ""bcdfghjklm""
// removeVowels ""abcdef""  // ""bcdf""
// removeVowels ""aaaaa""  // ""
// removeVowels ""aaBAA""  // ""B""
// removeVowels ""zbcd""  // ""zbcd""
func removeVowels:string str:string
    vowels := {a:true e:true i:true o:true u:true A:true E:true I:true O:true U:true}
    result := """"
    for ch := range str
        if !(has vowels ch)
            result = result + ch
        end
    end
    return result
end

func testall
    test """" (removeVowels """")
    test ""bcdfghjklm"" (removeVowels ""abcdefghijklm"")
    test ""fdcb"" (removeVowels ""fedcba"")
    test """" (removeVowels ""eeeee"")
    test ""cB"" (removeVowels ""acBAA"")
    test ""cB"" (removeVowels ""EcBOO"")
    test ""ybcd"" (removeVowels ""ybcd"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
045.evy,"//""Given length of a side and high return area for a triangle.
//    >>> triangleArea(5, 3)
//    7.5
//    ""
func triangleArea:num s:num h:num
    return s * h / 2

end

func testall
    test 7.5 (triangleArea 5 3)
    test 2 (triangleArea 2 2)
    test 40 (triangleArea 10 8)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
079.evy,"// You will be given a number in decimal form and your task is to convert it
// to binary format. The function should return a string, with each character
// representing a binary number. Each character in the string will be '0'
// or '1'.
//
// There will be an extra couple of characters 'db' at the beginning and at
// the end of the string. The extra characters are there to help with the
// format.
//
// Examples:
// convert 15 // ""db1111db""
// convert 32 // ""db100000db""
func convert:string n:num
    if n == 0
        return ""db0db""
    end
    result := """"
    while n > 0
        if n % 2 == 0
            result = ""0"" + result
        else
            result = ""1"" + result
        end
        n = floor n/2
    end
    return ""db"" + result + ""db""
end

func testall
    test ""db0db"" (convert 0)
    test ""db100000db"" (convert 32)
    test ""db1100111db"" (convert 103)
    test ""db1111db"" (convert 15)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
092.evy,"//  Create a function that takes 3 numbers.
//  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.
//  Returns false in any other cases.
//
//  Examples
//  sum 5, 2, 7  // true
//  sum 3, 2, 2  // false
//  sum 3, -2, 1  // true
//  sum 3.6, -2.2, 2  // false
func sum:bool x:num y:num z:num
    return ((x + y == z) or (x + z == y) or (y + z == x)) and (int x) and (int y) and (int z)
end

func int:bool n:num
    return n == (round n)
end

func testall
    test true (sum 2 3 1)
    test false (sum 2.5 2 3)
    test false (sum 1.5 5 3.5)
    test false (sum 2 6 2)
    test true (sum 4 2 2)
    test false (sum 2.2 2.2 2.2)
    test true (sum -4 6 2)
    test true (sum 2 1 1)
    test true (sum 3 4 7)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if wantType == ""[]"" or wantType == ""{}"" and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
086.evy,"ascii := {A:65 B:66 C:67 D:68 E:69 F:70 G:71 H:72 I:73 J:74 K:75 L:76 M:77 N:78 O:79 P:80 Q:81 R:82 S:83 T:84 U:85 V:86 W:87 X:88 Y:89 Z:90 a:97 b:98 c:99 d:100 e:101 f:102 g:103 h:104 i:105 j:106 k:107 l:108 m:109 n:110 o:111 p:112 q:113 r:114 s:115 t:116 u:117 v:118 w:119 x:120 y:121 z:122}
ascii["" ""] = 32
ascii[""!""] = 33
ascii[""\""""] = 34
ascii[""#""] = 35
ascii[""$""] = 36
ascii[""%""] = 37
ascii[""&""] = 38
ascii[""'""] = 39
ascii[""(""] = 40
ascii["")""] = 41
ascii[""*""] = 42
ascii[""+""] = 43
ascii["",""] = 44
ascii[""-""] = 45
ascii["".""] = 46
ascii[""/""] = 47
ascii[""0""] = 48
ascii[""1""] = 49
ascii[""2""] = 50
ascii[""3""] = 51
ascii[""4""] = 52
ascii[""5""] = 53
ascii[""6""] = 54
ascii[""7""] = 55
ascii[""8""] = 56
ascii[""9""] = 57
ascii["":""] = 58
ascii["";""] = 59
ascii[""<""] = 60
ascii[""=""] = 61
ascii["">""] = 62
ascii[""?""] = 63
ascii[""@""] = 64
ascii[""[""] = 91
ascii[""\\""] = 92
ascii[""]""] = 93
ascii[""^""] = 94
ascii[""_""] = 95
ascii[""`""] = 96
ascii[""{""] = 123
ascii[""|""] = 124
ascii[""}""] = 125
ascii[""~""] = 126

//  Write a function that takes a string and returns an ordered version of it.
//  Ordered version of string, is a string where all words  separated by space
//  are replaced by a new word where all the characters arranged in
//  ascending order based on ascii value.
//  Note: You should keep the order of words and blank spaces in the sentence.
//  For example:
//  antiShuffle ""Hi""  returns ""Hi""
//  antiShuffle ""hello""  returns ""ehllo""
//  antiShuffle ""Hello World!!!""  returns ""Hello !!!Wdlor""
func antiShuffle:string s:string
    words := split s "" ""
    for i := range (len words)
        words[i] = sort words[i]
    end
    return join words "" ""
end

func sort:string str:string
    s := str
    // bubble sort
    for endIdx := range (len s)-1 0 -1
        for i := range endIdx
            if ascii[s[i]] > ascii[s[i + 1]]
                s = s[:i] + s[i + 1] + s[i] + s[i + 2:]
            end
        end
    end
    return s
end

func testall
    test ""Hi"" (antiShuffle ""Hi"")
    test ""ehllo"" (antiShuffle ""hello"")
    test ""bemnru"" (antiShuffle ""number"")
    test ""abcd"" (antiShuffle ""abcd"")
    test ""Hello !!!Wdlor"" (antiShuffle ""Hello World!!!"")
    test """" (antiShuffle """")
    test "".Hi My aemn is Meirst .Rboot How aer ?ouy"" (antiShuffle ""Hi. My name is Mister Robot. How are you?"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if wantType == ""[]"" or wantType == ""{}"" and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
119.evy,"// You are given a list of two strings, both strings consist of open
// parentheses '(' or close parentheses ')' only.
// Your job is to check if it is possible to concatenate the two strings in
// some order, that the resulting string will be good.
// A string S is considered to be good if and only if all parentheses in S
// are balanced. For example: the string '(())()' is good, while the string
// '())' is not.
// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
// Examples:
// matchParens(['()(', ')']) == 'Yes'
// matchParens([')', ')']) == 'No'
func matchParens:string s:[]string
    s1 := s[0] + s[1]
    s2 := s[1] + s[0]
    if (valid s1) or (valid s2)
        return ""Yes""
    end
    return ""No""
end

func valid:bool s:string
    depth := 0
    for c := range s
        if c == ""(""
            depth = depth + 1
        else
            depth = depth - 1
        end
        if depth < 0
            return false
        end
    end
    return depth == 0
end

func testall
    test ""Yes"" (matchParens [""()("" "")""])
    test ""No"" (matchParens ["")"" "")""])
    test ""No"" (matchParens [""(()(())"" ""())())""])
    test ""Yes"" (matchParens ["")())"" ""(()()(""])
    test ""Yes"" (matchParens [""(())))"" ""(()())((""])
    test ""No"" (matchParens [""()"" ""())""])
    test ""Yes"" (matchParens [""(()("" ""()))()""])
    test ""No"" (matchParens [""(((("" ""((())""])
    test ""No"" (matchParens ["")(()"" ""(()(""])
    test ""No"" (matchParens ["")("" "")(""])
    test ""Yes"" (matchParens [""("" "")""])
    test ""Yes"" (matchParens ["")"" ""(""])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
090.evy,"// You are given a array of numbers.
// Write a function nextSmallest that returns the 2nd smallest element of the list.
// Return false if there is no such element.
// nextSmallest [1 2 3 4 5]) == 2
// nextSmallest [5 1 4 3 2]) == 2
// nextSmallest []) == false
// nextSmallest [1 1]) == false
func nextSmallest:any nums:[]num
    if (len nums) < 2
        return false
    end
    nums = nums[:] // copy
    sort nums
    smallest := nums[0]
    for i := range 1 (len nums)
        if nums[i] > smallest
            return nums[i]
        end
    end
    return false
end

func sort arr:[]num
    // bubble sort
    for endIdx := range (len arr)-1 0 -1
        for i := range endIdx
            if arr[i] > arr[i + 1]
                tmp := arr[i]
                arr[i] = arr[i + 1]
                arr[i + 1] = tmp
            end
        end
    end
end

func testall
    test 2 (nextSmallest [1 2 3 4 5])
    test 2 (nextSmallest [5 1 4 3 2])
    test false (nextSmallest [])
    test false (nextSmallest [1 1])
    test 1 (nextSmallest [1 1 1 1 0])
    test -35 (nextSmallest [-35 34 12 -45])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if wantType == ""[]"" or wantType == ""{}"" and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
084.evy,"// Given a positive integer n, return the total sum of its digits in binary.
// solve 1000 // ""1""
// solve 150 // ""110""
// solve 147 // ""1100""
func solve:string n:num
    sum := 0
    while n > 0
        sum = sum + n % 10
        n = floor n/10
    end
    result := """"
    while sum > 0
        result = (sprint sum%2) + result
        sum = floor sum/2
    end
    return result
end

func testall
    test ""1"" (solve 1000)
    test ""110"" (solve 150)
    test ""1100"" (solve 147)
    test ""1001"" (solve 333)
    test ""10010"" (solve 963)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if wantType == ""[]"" or wantType == ""{}"" and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
053.evy,"// Add two numbers x and y
// add 2 3 // 5
// add 5 7 // 12
func add:num x:num y:num
    return x + y
end

func testall
    test 1 (add 0 1)
    test 1 (add 1 0)
    test 5 (add 2 3)
    test 12 (add 5 7)
    test 12 (add 7 5)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
047.evy,"// Return median of elements in the list l.
// median [3 1 2 4 5] // 3
// median [-10 4 6 1000 10 20] // 15.0
func median:num nums:[]num
    length := len nums
    if length == 0
        return -1
    end
    result := nums[:]
    sort result
    if length % 2 == 1
        return result[floor length/2]
    else
        return (result[length / 2 - 1] + result[length / 2]) / 2
    end
end

func sort arr:[]num
    // bubble sort
    for endIdx := range (len arr)-1 0 -1
        for i := range endIdx
            if arr[i] > arr[i + 1]
                tmp := arr[i]
                arr[i] = arr[i + 1]
                arr[i + 1] = tmp
            end
        end
    end
end

func testall
    test 3 (median [3 1 2 4 5])
    test 8 (median [-10 4 6 1000 10 20])
    test 5 (median [5])
    test 5.5 (median [6 5])
    test 7 (median [8 1 3 9 9 2 7])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
046.evy,"// The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:
//    fib4(0) -> 0
//    fib4(1) -> 0
//    fib4(2) -> 2
//    fib4(3) -> 0
//    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
//    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
//    fib4 5 // 4
//    fib4 6 // 8
//    fib4 7 // 14
func fib4:num n:num
    result := [0 0 2 0]
    if n < 4
        return result[n]
    end
    for range n-3
        result = result + [result[-1]+result[-2]+result[-3]+result[-4]]
    end
    return result[-1]
end

func testall
    test 4 (fib4 5)
    test 28 (fib4 8)
    test 104 (fib4 10)
    test 386 (fib4 12)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
052.evy,"// Return true if all numbers in the list l are below threshold t.
// below [1 2 4 10] 100// true
// below [1 20 4 10] 5 // false
func below:bool nums:[]num t:num
    for n := range nums
        if n >= t
            return false
        end
    end
    return true
end

func testall
    test true (below [1 2 4 10] 100)
    test false (below [1 20 4 10] 5)
    test true (below [1 20 4 10] 21)
    test true (below [1 20 4 10] 22)
    test true (below [1 8 4 10] 11)
    test false (below [1 8 4 10] 10)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
085.evy,"//  Given a non-empty list of numbers add the even elements that are at odd indices.
//  add [4 2 6 7]  // 2
func add:num nums:[]num
    result := 0
    for i := range 1 (len nums) 2
        if nums[i] % 2 == 0
            result = result + nums[i]
        end
    end
    return result
end

func testall
    test 88 (add [4 88])
    test 122 (add [4 5 6 7 2 122])
    test 0 (add [4 0 6 7])
    test 12 (add [4 4 6 8])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if wantType == ""[]"" or wantType == ""{}"" and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
091.evy,"// You'll be given a string of words, and your task is to count the number
// of boredoms. A boredom is a sentence that starts with the word ""I"".
// Sentences are delimited by '.', '?' or '!'.
// boredoms ""Hello world"" // 0
// boredoms ""The sky is blue. The sun is shining. I love this weather"" // 1

func boredoms:num s:string
    result := 0
    sentences := splitText s
    for s := range sentences
        if (startswith s ""I "") or s == ""I."" or s == ""I!"" or s == ""I?""
            result = result + 1
        end
    end
    return result
end

func splitText:[]string s:string
    result:[]string
    start := 0
    for i := range (len s)
        c := s[i]
        if c == ""."" or c == ""?"" or c == ""!""
            sentence := trim s[start:i + 1] "" ""
            result = result + [sentence]
            start = i + 1
        end
    end
    return result
end

func testall
    test 0 (boredoms ""Hello world"")
    test 0 (boredoms ""Is the sky blue?"")
    test 1 (boredoms ""I love It !"")
    test 0 (boredoms ""I"")
    test 1 (boredoms ""I."")
    test 0 (boredoms ""what? I"")
    test 2 (boredoms ""I feel good today. I will be productive. will kill It"")
    test 0 (boredoms ""You and I are going for a walk"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if wantType == ""[]"" or wantType == ""{}"" and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
103.evy,"// You are given two positive integers n and m, and your task is to compute the
// average of the integers from n through m (including n and m).
// Round the answer to the nearest integer and convert that to binary.
// If n is greater than m, return -1.
// Example:
// avg 1 5 // ""0b11""
// avg 7 5 // -1
// avg 10 20 // ""0b1111""
// avg 20 33 // ""0b11010""
func avg:any n:num m:num
    if m < n
        return -1
    end
    a := round (m + n)/2
    result := """"
    while a > 0
        result = (sprint a%2) + result
        a = floor a/2
    end
    return ""0b"" + result
end

func testall
    test ""0b11"" (avg 1 5)
    test ""0b1010"" (avg 7 13)
    test ""0b1111001011"" (avg 964 977)
    test ""0b1111100101"" (avg 996 997)
    test ""0b1011000010"" (avg 560 851)
    test ""0b101101110"" (avg 185 546)
    test ""0b110101101"" (avg 362 496)
    test ""0b1001110010"" (avg 350 902)
    test ""0b11010111"" (avg 197 233)
    test -1 (avg 7 5)
    test -1 (avg 5 1)
    test ""0b101"" (avg 5 5)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
117.evy,"// Given a string s and a natural number n, you have been tasked to implement
// a function that returns a list of all words from string s that contain exactly
// n consonants, in the order in which these words appear in the string s.
// If the string s is empty then the function should return an empty list.
// Note: you may assume the input string contains only letters and spaces.
// Examples:
// selectWords ""Mary had a little lamb"" 4 // [""little""]
// selectWords ""Mary had a little lamb"" 3 // [""Mary"" ""lamb""]
// selectWords ""simple white space"" 2 // []
// selectWords ""Hello world"" 4 // [""world""]
// selectWords ""Uncle sam"" 3 // [""Uncle""]
func selectWords:[]string s:string targetConsonants:num
    words := split s "" ""
    vowels := {a:0 e:0 i:0 o:0 u:0}
    result:[]string
    for word := range words
        consonants := 0
        lword := lower word
        for c := range lword
            if !(has vowels c)
                consonants = consonants + 1
            end
        end
        if consonants == targetConsonants
            result = result + [word]
        end
    end
    return result
end

func testall
    test [""little""] (selectWords ""Mary had a little lamb"" 4)
    test [""Mary"" ""lamb""] (selectWords ""Mary had a little lamb"" 3)
    test [] (selectWords ""simple white space"" 2)
    test [""world""] (selectWords ""Hello world"" 4)
    test [""Uncle""] (selectWords ""Uncle sam"" 3)
    test [] (selectWords """" 4)
    test [""b"" ""c"" ""d"" ""f""] (selectWords ""a b c d e f"" 1)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
088.evy,"// Given an array of non-negative integers, return a copy of the given array
// after sorting, you will sort the given array in ascending order if the sum
// of first index value and last index value is odd, or sort it in descending
// order if the sum  of first index value and last index value is even.
//
// Note: don't change the given array.
// sortArray [] // []
// sortArray [5] // [5]
// sortArray [2 4 3 0 1 5] // [0 1 2 3 4 5]
// sortArray [2 4 3 0 1 5 6] // [6 5 4 3 2 1 0]
func sortArray:[]num nums:[]num
    if (len nums) <= 1
        return nums
    end
    result := nums[:]
    asc := (nums[0] + nums[-1]) % 2 == 1
    sort result asc
    return result
end

func sort arr:[]num asc:bool
    // bubble sort
    for endIdx := range (len arr)-1 0 -1
        for i := range endIdx
            if (asc and arr[i] > arr[i + 1]) or (!asc and arr[i] < arr[i + 1])
                tmp := arr[i]
                arr[i] = arr[i + 1]
                arr[i + 1] = tmp
            end
        end
    end
end

func testall
    test [] (sortArray [])
    test [5] (sortArray [5])
    test [0 1 2 3 4 5] (sortArray [2 4 3 0 1 5])
    test [6 5 4 3 2 1 0] (sortArray [2 4 3 0 1 5 6])
    test [1 2] (sortArray [2 1])
    test [0 11 15 32 42 87] (sortArray [15 42 87 32 11 0])
    test [23 21 14 11] (sortArray [21 14 23 11])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if wantType == ""[]"" or wantType == ""{}"" and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
077.evy,"// Write a function that takes an number a and returns true
// if this number is a cube of some integer number.
// Note: you may assume the input is always valid.
// Examples:
// iscube(1) ==> True
// iscube(2) ==> False
// iscube(-1) ==> True
// iscube(64) ==> True
// iscube(0) ==> True
// iscube(180) ==> False
func iscube:bool n:num
    if n < 0
        n = -n //abs
    end
    cuberoot := pow n 1/3
    n2 := pow (round cuberoot) 3
    return (round n2) == n
end

func testall
    test true (iscube 1)
    test false (iscube 2)
    test true (iscube -1)
    test true (iscube 64)
    test false (iscube 180)
    test true (iscube 1000)
    test true (iscube 0)
    test false (iscube 1729)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
063.evy,"// The fib3 number sequence is a sequence similar to the Fibonacci sequence
// that's defined as follows:
// (fib3 0) == 0
// (fib3 1) == 0
// (fib3 2) == 1
// (fib3 n) == (fib3 n-1) + (fib3 n-2) + fib3 n-3).
// Please write a function to efficiently compute the n-th element of the fib3
// number sequence.
// fib3 1 // 0
// fib3 5 // 4
// fib3 8 // 24
func fib3:num n:num
    result := [0 0 1]
    if n < 3
        return result[n]
    end
    for range n-2
        result = result + [result[-1]+result[-2]+result[-3]]
    end
    return result[-1]
end

func testall
    test 1 (fib3 2)
    test 0 (fib3 1)
    test 4 (fib3 5)
    test 24 (fib3 8)
    test 81 (fib3 10)
    test 274 (fib3 12)
    test 927 (fib3 14)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
062.evy,"// xs represent coefficients of a polynomial.
// xs[0] + xs[1] * x + xs[2] * x^2 + ....
// Return derivative of this polynomial in the same form.
// derivative [3 1 2 4 5] // [1 4 12 20]
// derivative [1 2 3] // [2 6]
func derivative:[]num xs:[]num
    result := xs[1:]
    for i := range 1 (len result)
        result[i] = result[i] * (i + 1)
    end
    return result
end

func testall
    test [1 4 12 20] (derivative [3 1 2 4 5])
    test [2 6] (derivative [1 2 3])
    test [2 2] (derivative [3 2 1])
    test [2 2 0 16] (derivative [3 2 1 0 4])
    test [] (derivative [1])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
076.evy,"// Your task is to write a function that returns true if a number x is a simple
// power of n and false in other cases.
// x is a simple power of n if n**int=x
// For example:
// isPower 1 4 // true: 4^0 == 1
// isPower 2 2 // true: 2^1 == 2
// isPower 8 2 // true: 2^3 == 8
// isPower 3 2 // false
// isPower 3 1 // false
// isPower 5 3 // false
func isPower:bool x:num n:num
    for exp := range x
        x2 := pow n exp
        if x == x2
            return true
        end
        if x2 > x
            return false
        end
    end
    return false
end

func testall
    test true (isPower 1 1)
    test true (isPower 1 12)
    test false (isPower 12 1)
    test true (isPower 16 2)
    test false (isPower 143214 16)
    test true (isPower 4 2)
    test true (isPower 9 3)
    test true (isPower 16 4)
    test false (isPower 24 2)
    test false (isPower 128 4)
    test false (isPower 12 6)
    test true (isPower 1 1)
    test true (isPower 1 12)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
089.evy,"abc := ""abcdefghijklmnopqrstuvwxyz""
ord := {a:0 b:1 c:2 d:3 e:4 f:5 g:6 h:7 i:8 j:9 k:10 l:11 m:12 n:13 o:14 p:15 q:16 r:17 s:18 t:19 u:20 v:21 w:22 x:23 y:24 z:25}

//  Create a function encrypt that takes a string as an argument and
//  returns a string encrypted with the alphabet being rotated.
//  The alphabet should be rotated in a manner such that the letters
//  shift down by two multiplied to two places.
//  For example:
//  encrypt ""hi""  returns ""lm""
//  encrypt ""asdfghjkl""  returns ""ewhjklnop""
//  encrypt ""gf""  returns ""kj""
//  encrypt ""et""  returns ""ix""
func encrypt:string s:string
    result := """"
    for ch := range s
        result = result + abc[(ord[ch] + 4) % 26]
    end
    return result
end

func testall
    test ""lm"" (encrypt ""hi"")
    test ""ewhjklnop"" (encrypt ""asdfghjkl"")
    test ""kj"" (encrypt ""gf"")
    test ""ix"" (encrypt ""et"")
    test ""jeiajeaijeiak"" (encrypt ""faewfawefaewg"")
    test ""lippsqcjvmirh"" (encrypt ""hellomyfriend"")
    test ""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"" (encrypt ""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")
    test ""e"" (encrypt ""a"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if wantType == ""[]"" or wantType == ""{}"" and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
116.evy,"// In this exercise you have to sort an array of non-negative integers according to
// number of ones in their binary representation in ascending order.
// For similar number of ones, sort based on decimal value.
//
// It must be implemented like this:
// >>> binSort [1 5 2 3 4] // [1 2 4 3 5]
// >>> binSort [-2 -3 -4 -5 -6] // [-6 -5 -4 -3 -2]
// >>> binSort [1 0 2 3 4] // [0 1 2 4 3]
func binSort:[]num nums:[]num
    arr := nums[:]
    for endIdx := range (len arr)-1 0 -1
        for i := range endIdx
            if moreOnes arr[i] arr[i + 1]
                tmp := arr[i]
                arr[i] = arr[i + 1]
                arr[i + 1] = tmp
            end
        end
    end
    return arr
end

func moreOnes:bool n1:num n2:num
    ones1 := binOnes n1
    ones2 := binOnes n2
    if ones1 == ones2
        return n1 > n2
    end
    return ones1 > ones2
end

func binOnes:num n:num
    n = abs n
    result := 0
    while n > 0
        if n % 2 == 1
            result = result + 1
        end
        n = floor n/2
    end
    return result
end

func abs:num n:num
    if n < 0
        return -n
    end
    return n
end

func testall
    test [1 2 4 3 5] (binSort [1 5 2 3 4])
    test [-4 -2 -6 -5 -3] (binSort [-2 -3 -4 -5 -6])
    test [0 1 2 4 3] (binSort [1 0 2 3 4])
    test [] (binSort [])
    test [2 2 4 4 3 3 5 5 5 7 77] (binSort [2 5 77 4 5 3 5 7 2 3 4])
    test [32 3 5 6 12 44] (binSort [3 6 44 12 32 5])
    test [2 4 8 16 32] (binSort [2 4 8 16 32])
    test [2 4 8 16 32] (binSort [2 4 8 16 32])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
102.evy,"// This function takes two positive numbers x and y and returns the
// biggest even integer number that is in the range [x, y] inclusive. If
// there's no such number, then the function should return -1.
// choose 12 15 // 14
// choose 13 12 // -1
func choose:num x:num y:num
    if x > y
        return -1
    end
    if y % 2 == 0
        return y
    end
    if x == y
        return -1
    end
    return y - 1
end

func testall
    test 14 (choose 12 15)
    test -1 (choose 13 12)
    test 12354 (choose 33 12354)
    test -1 (choose 5234 5233)
    test 28 (choose 6 29)
    test -1 (choose 27 10)
    test -1 (choose 7 7)
    test 546 (choose 546 546)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
114.evy,"// Given an array of nums, find the minimum sum of any non-empty sub-array
// of nums.
// Example
// minSum [2 3 4 1 2 4] // 1
// minSum [-1 -2 -3] // -6
func minSum:num nums:[]num
    ms := nums[0]
    runningSum := ms

    for n := range nums[1:]
        if n < runningSum + n
            runningSum = n
        else
            runningSum = runningSum + n
        end
        if runningSum < ms
            ms = runningSum
        end
    end
    return ms
end

func testall
    test -5 (minSum [2 3 -4 1 -2 4])
    test -7 (minSum [2 -1 1 -6 2 3 -4 1 -3 4])
    test 1 (minSum [2 3 4 1 2 4])
    test -6 (minSum [-1 -2 -3])
    test -14 (minSum [-1 -2 -3 2 -10])
    test -10000000000000000 (minSum [-10000000000000000])
    test 0 (minSum [0 10 20 1000000])
    test -6 (minSum [-1 -2 -3 10 -5])
    test -6 (minSum [100 -1 -2 -3 10 -5])
    test 3 (minSum [10 11 13 8 3 4])
    test -33 (minSum [100 -33 32 -1 0 -2])
    test -10 (minSum [-10])
    test 7 (minSum [7])
    test -1 (minSum [1 -1])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
100.evy,"//  Given a positive integer n, you have to make a pile of n levels of stones.
//  The first level has n stones.
//  The number of stones in the next level is:
//      - the next odd number if n is odd.
//      - the next even number if n is even.
//  Return the number of stones in each level in an array, where element at index
//  i represents the number of stones in the level (i+1).
//
//  makePile 3 //  [3, 5, 7]
func makePile:[]num n:num
    arr:[]num
    for i := range n
        arr = arr + [n+2*i]
    end
    return arr
end

func testall
    test [3 5 7] (makePile 3)
    test [4 6 8 10] (makePile 4)
    test [5 7 9 11 13] (makePile 5)
    test [6 8 10 12 14 16] (makePile 6)
    test [8 10 12 14 16 18 20 22] (makePile 8)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
060.evy,"// sum is a function that sums numbers from 1 to n.
// sum 30 // 465
// sum 100 // 5050
// sum 5 // 15
// sum 10 // 55
// sum 1 // 1
func sum:num n:num
    return n * (n + 1) / 2
end

func testall
    test 1 (sum 1)
    test 21 (sum 6)
    test 66 (sum 11)
    test 465 (sum 30)
    test 5050 (sum 100)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
074.evy,"// Write a function that accepts two lists of strings and returns the list that has
// the lower total number of characters of all the strings in the list combined.
//
// If the two lists have the same number of chars, return the first list.
//
// Examples
// findShorter [], []) ➞ []
// findShorter [""hi"" ""admin""] [""hI"" ""Hi""] // [""hI"" ""Hi""]
// findShorter [""hi"" ""admin""] [""hi"" ""hi"" ""admin"" ""project""] // [""hi"" ""admin""]
// findShorter [""hi"" ""admin""] [""hI"" ""hi"" ""hi""] // [""hI"" ""hi"" ""hi""]
// findShorter [""4""] [""1"" ""2"" ""3"" ""4"" ""5""] // [""4""]
func findShorter:[]string arr1:[]string arr2:[]string
    str1 := join arr1 """"
    str2 := join arr2 """"
    if (len str1) <= (len str2)
        return arr1
    end
    return arr2
end

func testall
    test [] (findShorter [] [])
    test [""hi"" ""hi""] (findShorter [""hi"" ""admin""] [""hi"" ""hi""])
    test [""hi"" ""admin""] (findShorter [""hi"" ""admin""] [""hi"" ""hi"" ""admin"" ""project""])
    test [""4""] (findShorter [""4""] [""1"" ""2"" ""3"" ""4"" ""5""])
    test [""hI"" ""Hi""] (findShorter [""hi"" ""admin""] [""hI"" ""Hi""])
    test [""hI"" ""hi"" ""hi""] (findShorter [""hi"" ""admin""] [""hI"" ""hi"" ""hi""])
    test [""hi"" ""admin""] (findShorter [""hi"" ""admin""] [""hI"" ""hi"" ""hii""])
    test [] (findShorter [] [""this""])
    test [] (findShorter [""this""] [])

end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
048.evy,"// Checks if given string is a palindrome
// isPalindrome """" // true
// isPalindrome ""aba"" // true
// isPalindrome ""aaaaa"" // true
// isPalindrome ""zbcd"" // false
func isPalindrome:bool str:string
    length := len str
    for i := range (floor length/2)
        if str[i] != str[-(i + 1)]
            return false
        end
    end
    return true
end

func testall
    test true (isPalindrome """")
    test true (isPalindrome ""aba"")
    test true (isPalindrome ""aaaaa"")
    test false (isPalindrome ""zbcd"")
    test true (isPalindrome ""xywyx"")
    test false (isPalindrome ""xywyz"")
    test false (isPalindrome ""xywzx"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
049.evy,"// Return 2^n modulo p. (careful with overflow!)
// modp 3 5 // 3
// modp 1101 101 // 2
// modp 0 101 // 1
// modp 3 11 // 8
// modp 100 101 // 1
func modpn:num n:num p:num
    result := 1
    for range n
        result = (2 * result) % p
    end
    return result
end

func testall
    test 3 (modpn 3 5)
    test 2 (modpn 1101 101)
    test 1 (modpn 0 101)
    test 8 (modpn 3 11)
    test 1 (modpn 100 101)
    test 4 (modpn 30 5)
    test 3 (modpn 31 5)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
075.evy,"// Write a function that returns true if the given number is the
// multiplication of 3 prime numbers and false otherwise. Knowing that each
// prime number is less then 100.
//
// prime3 30 // true: 30 = 2 * 3 * 5
func prime3:bool n:num
    primes := calcPrimes 100
    length := len primes
    for i := range length
        for j := range i length
            for k := range j length
                if n == primes[i] * primes[j] * primes[k]
                    return true
                end
            end
        end
    end
    return false
end

func calcPrimes:[]num n:num
    // Sieve of Eratosthenes
    // input: an integer n > 1.
    // output: all prime numbers from 2 through n.
    sieve := [true] * n

    for i := range 2 (sqrt n+1)
        if sieve[i]
            for j := range i*i n i
                sieve[j] = false
            end
        end
    end
    result:[]num
    for i := range 2 n
        if sieve[i]
            result = result + [i]
        end
    end
    return result
end

func testall
    test false (prime3 5)
    test true (prime3 30)
    test true (prime3 8)
    test false (prime3 10)
    test true (prime3 125)
    test true (prime3 3*5*7)
    test false (prime3 3*6*7)
    test false (prime3 9*9*9)
    test false (prime3 11*9*9)
    test true (prime3 11*13*7)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
061.evy,"// checkBrackets returns true if the if every opening bracket
// has a corresponding closing bracket in the  input string.
//
// checkBrackets ""("" // false
// checkBrackets ""()"" // true
// checkBrackets ""(()())"" // true
// checkBrackets "")(()"" // false
func checkBrackets:bool input:string
    depth := 0
    for c := range input
        if c == ""(""
            depth = depth + 1
        else
            depth = depth - 1
        end
        if depth < 0
            return false
        end
    end
    return depth == 0
end

func testall
    test true (checkBrackets ""()"")
    test true (checkBrackets ""(()())"")
    test true (checkBrackets ""()()(()())()"")
    test true (checkBrackets ""()()((()()())())(()()(()))"")
    test false (checkBrackets ""((()())))"")
    test false (checkBrackets "")(()"")
    test false (checkBrackets ""("")
    test false (checkBrackets ""(((("")
    test false (checkBrackets "")"")
    test false (checkBrackets ""(()"")
    test false (checkBrackets ""()()(()())())(()"")
    test false (checkBrackets ""()()(()())()))()"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
101.evy,"// Given a string of words separated by commas or spaces. Your task is
// to split the string into words and return an array of the words.
// words ""Hi, my name is John"" // [""Hi"" ""my"" ""name"" ""is"" ""John""]
// words ""One, two, three, four, five, six"" // [""One"" ""two"" ""three"" ""four"" ""five"" ""six""]
func words:[]string s:string
    wordArr := split s "" ""
    result:[]string
    for word := range wordArr
        w := trim word "", ""
        if w != """"
            result = result + [w]
        end
    end
    return result
end

func testall
    test [""Hi"" ""my"" ""name"" ""is"" ""John""] (words ""Hi, my name is John"")
    test [""One"" ""two"" ""three"" ""four"" ""five"" ""six""] (words ""One, two, three, four, five, six"")
    test [""Hi"" ""my"" ""name""] (words ""Hi, my name"")
    test [""One"" ""two"" ""three"" ""four"" ""five"" ""six""] (words ""One,, two, three, four, five, six,"")
    test [] (words """")
    test [""ahmed"" ""gamal""] (words ""ahmed     , gamal"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
115.evy,"// You are given a rectangular grid of wells. Each row represents a single well,
// and each 1 in a row represents a single unit of water.
// Each well has a corresponding bucket that can be used to extract water from it,
// and all buckets have the same capacity.
// Your task is to use the buckets to empty the wells.
// Output the number of times you need to lower the buckets.
//
// Example 1:
//     Input:
//         grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]
//         bucket_capacity : 1
//     Output: 6
//
// Example 2:
//     Input:
//         grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]
//         bucket_capacity : 2
//     Output: 5
//
// Example 3:
//     Input:
//         grid : [[0,0,0], [0,0,0]]
//         bucket_capacity : 5
//     Output: 0
//
// Constraints:
//     * all wells have the same length
//     * 1 <= grid.length <= 10^2
//     * 1 <= grid[1].length <= 10^2
//     * grid[i][j] -> 0 | 1
//     * 1 <= capacity <= 10
func lowerCount:num wells:[][]num capacity:num
    result := 0
    for well := range wells
        size := 0
        for unit := range well
            size = size + unit
        end
        result = result + (ceil size/capacity)
    end
    return result
end

func testall
    test 6 (lowerCount [[0 0 1 0] [0 1 0 0] [1 1 1 1]] 1)
    test 5 (lowerCount [[0 0 1 1] [0 0 0 0] [1 1 1 1] [0 1 1 1]] 2)
    test 0 (lowerCount [[0 0 0] [0 0 0]] 5)
    test 4 (lowerCount [[1 1 1 1] [1 1 1 1]] 2)
    test 2 (lowerCount [[1 1 1 1] [1 1 1 1]] 9)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
111.evy,"// Given a string representing a space separated lowercase letters, return a dictionary
// of the letters with the most repetition and containing the corresponding count.
// If several letters have the same occurrence, return all of them.
//
// Example:
// histogram ""a b c"" // {a: 1, b: 1, c: 1}
// histogram ""a b b a"" // {a: 2, b: 2}
// histogram ""a b c a b"" // {a: 2, b: 2}
// histogram ""b b b b a"" // {b: 4}
// histogram """" // {}
func histogram:{}num s:string
    if s == """"
        return {}
    end

    m:{}num
    arr := split s "" ""
    for s := range arr
        if has m s
            m[s] = m[s] + 1
        else
            m[s] = 1
        end
    end
    lmax := 0
    for k := range m
        if m[k] > lmax
            lmax = m[k]
        end
    end
    result:{}num
    for k := range m
        if m[k] == lmax
            result[k] = lmax
        end
    end
    return result
end

func testall
    test {a:2 b:2} (histogram ""a b b a"")
    test {a:2 b:2} (histogram ""a b c a b"")
    test {a:1 b:1 c:1 d:1 g:1} (histogram ""a b c d g"")
    test {r:1 t:1 g:1} (histogram ""r t g"")
    test {b:4} (histogram ""b b b b a"")
    test {r:1 t:1 g:1} (histogram ""r t g"")
    test {} (histogram """")
    test {a:1} (histogram ""a"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
105.evy,"// Given an array of integers, sort the integers that are between 1 and 9 inclusive,
// reverse the resulting array, and then replace each digit by its corresponding name from
// ""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine"".
// For example:
//   arr = [2 1 1 4 5 8 2 3]
//         -> sort arr -> [1 1 2 2 3 4 5 8]
//         -> reverse arr -> [8 5 4 3 2 2 1 1]
//   return [""Eight"" ""Five"" ""Four"" ""Three"" ""Two"" ""Two"" ""One"" ""One""]

//   If the array is empty return an empty array:
//   arr = []
//   return []

//   If the array has any strange number ignore it:
//   arr = [1 -1  55]
//         -> sort arr -> [-1 1 55]
//         -> reverse arr -> [55 1 -1]
//   return = ['One']
func solve:[]string nums:[]num
    names := [""Zero"" ""One"" ""Two"" ""Three"" ""Four"" ""Five"" ""Six"" ""Seven"" ""Eight"" ""Nine""]
    nums2:[]num
    for n := range nums
        if n > 0 and n < 10
            nums2 = nums2 + [n]
        end
    end
    sort nums2
    result:[]string
    for n := range nums2
        result = result + [names[n]]
    end
    return result
end

func sort arr:[]num
    // bubble sort, descending
    for endIdx := range (len arr)-1 0 -1
        for i := range endIdx
            if arr[i] < arr[i + 1]
                tmp := arr[i]
                arr[i] = arr[i + 1]
                arr[i + 1] = tmp
            end
        end
    end
end

func testall
    test [""Eight"" ""Five"" ""Four"" ""Three"" ""Two"" ""Two"" ""One"" ""One""] (solve [2 1 1 4 5 8 2 3])
    test [] (solve [])
    test [""One""] (solve [1 -1 55])
    test [""Three"" ""Two"" ""One""] (solve [1 -1 3 2])
    test [""Nine"" ""Eight"" ""Four""] (solve [9 4 8])

end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
059.evy,"// Return the largest prime factor of n. Assume n > 1 and is not a prime.
// largestPrimeFactor 13195 // 29
// largestPrimeFactor 2048 // 2
func largestPrimeFactor:num n:num
    result := -1
    for i := range 2 n
        if n % i == 0 and (isPrime i)
            result = i
        end
    end
    return result
end

func isPrime:bool n:num
    if n < 2
        return false
    end
    for i := range 2 (sqrt n)+1
        if n % i == 0
            return false
        end
    end
    return true
end

func testall
    test 5 (largestPrimeFactor 15)
    test 3 (largestPrimeFactor 27)
    test 7 (largestPrimeFactor 63)
    test 11 (largestPrimeFactor 330)
    test 29 (largestPrimeFactor 13195)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
065.evy,"// Circular shift the digits of the integer x, shift the digits right by shift
// and return the result as a string.
// If shift > number of digits, return digits reversed.
// shift 12 1 // ""21""
// shift 12 2 // ""12""
func shift:string x:num n:num
    str := sprint x
    result := """"
    if n > (len str)
        for c := range str
            result = c + result
        end
    else
        result = str[-n:] + str[:-n]
    end
    return result
end

func testall
    test ""1"" (shift 1 1)
    test ""1"" (shift 1 3)
    test ""0111"" (shift 1110 30)
    test ""001"" (shift 100 2)
    test ""12"" (shift 12 2)
    test ""79"" (shift 97 8)
    test ""21"" (shift 12 1)
    test ""11"" (shift 11 101)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
071.evy,"// Given the lengths of the three sides of a triangle. Return the area of the
// triangle rounded to 2 decimal points if the three sides form a valid
// triangle. Otherwise return -1 Three sides make a valid triangle when the
// sum of any two sides is greater than the third side.
// Use Heron's formula.
//
// Example:
// triangleArea 3 4 5 // 6.00
// triangleArea 1 2 10 // -1
func triangleArea:num a:num b:num c:num
    if a + b <= c or a + c <= b or b + c <= a
        return -1
    end
    result := (a + b + c) * (-a + b + c) * (a - b + c) * (a + b - c)
    result = 0.25 * (pow result 0.5)
    return (round result*100) / 100 // round to 2 decimals
end

func testall
    test 6 (triangleArea 3 4 5)
    test -1 (triangleArea 1 2 10)
    test 8.18 (triangleArea 4 8 5)
    test 1.73 (triangleArea 2 2 2)
    test -1 (triangleArea 1 2 3)
    test 16.25 (triangleArea 10 5 7)
    test -1 (triangleArea 2 6 3)
    test 0.43 (triangleArea 1 1 1)
    test -1 (triangleArea 2 2 10)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
070.evy,"// Given list of integers, return list in strange order.
// Strange sorting, is when you start with the minimum value,
// then maximum of the remaining integers, then minimum and so on.

// Examples:
// strangeSort [1 2 3 4] // [1 4 2 3]
// strangeSort [5 5 5 5] // [5 5 5 5]
// strangeSort [] // []
func strangeSort:[]num nums:[]num
    nums2 := nums[:]
    sort nums2
    result:[]num
    length := len nums2
    mid := floor length/2
    for i := range mid
        result = result + [nums2[i]] + [nums2[-i - 1]]
    end
    if length % 2 == 1
        result = result + [nums2[mid]]
    end
    return result
end

func sort arr:[]num
    // bubble sort
    for endIdx := range (len arr)-1 0 -1
        for i := range endIdx
            if arr[i] > arr[i + 1]
                tmp := arr[i]
                arr[i] = arr[i + 1]
                arr[i + 1] = tmp
            end
        end
    end
end

func testall
    test [1 4 2 3] (strangeSort [1 2 3 4])
    test [5 9 6 8 7] (strangeSort [5 6 7 8 9])
    test [1 5 2 4 3] (strangeSort [1 2 3 4 5])
    test [1 9 5 8 6 7] (strangeSort [5 6 7 8 9 1])
    test [5 5 5 5] (strangeSort [5 5 5 5])
    test [] (strangeSort [])
    test [1 8 2 7 3 6 4 5] (strangeSort [1 2 3 4 5 6 7 8])
    test [-5 5 -5 5 0 2 2 2] (strangeSort [0 2 2 2 5 5 -5 -5])
    test [111111] (strangeSort [111111])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
064.evy,"// Write a function vowelCount which takes a string representing
// a word as input and returns the number of vowels in the string.
// Vowels in this case are ""a"", ""e"", ""i"", ""o"", ""u"". Here, ""y"" is also a
// vowel, but only when it is at the end of the given word.
// Example:
// vowelCount(""abcde"") // 2
// vowelCount(""ACEDY"") // 3
func vowelCount:num str:string
    vowels := {a:0 e:0 i:0 o:0 u:0}
    result := 0
    str = lower str
    for c := range str
        if has vowels c
            result = result + 1
        end
    end
    if (len str) > 0 and str[-1] == ""y""
        result = result + 1
    end
    return result
end

func testall
    test 0 (vowelCount """")
    test 2 (vowelCount ""abcde"")
    test 3 (vowelCount ""Alone"")
    test 2 (vowelCount ""key"")
    test 1 (vowelCount ""bye"")
    test 2 (vowelCount ""keY"")
    test 1 (vowelCount ""bYe"")
    test 3 (vowelCount ""ACEDY"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
058.evy,"// Return sorted unique common elements for two lists.
// common [1 4 3 34 653 2 5] [5 7 1 5 9 653 121] // [1 5 653]
// common [5 3 2 8] [3 2] // [2 3]
func common:[]num nums1:[]num nums2:[]num
    s1 := set nums1
    s2 := set nums2
    s3 := intersection s1 s2
    result := numArr s3
    sort result
    return result
end

func set:{}bool nums:[]num
    result:{}bool
    for n := range nums
        result[sprint n] = true
    end
    return result
end

func intersection:{}bool s1:{}bool s2:{}bool
    result:{}bool
    for k := range s1
        if has s2 k
            result[k] = true
        end
    end
    return result
end

func numArr:[]num s:{}bool
    result:[]num
    for k := range s
        n := str2num k
        result = result + [n]
    end
    return result
end

func sort arr:[]num
    // bubble sort
    for endIdx := range (len arr)-1 0 -1
        for i := range endIdx
            if arr[i] > arr[i + 1]
                tmp := arr[i]
                arr[i] = arr[i + 1]
                arr[i + 1] = tmp
            end
        end
    end
end

func testall
    test [1 5 653] (common [1 4 3 34 653 2 5] [5 7 1 5 9 653 121])
    test [2 3] (common [5 3 2 8] [3 2])
    test [2 3 4] (common [4 3 2 8] [3 2 4])
    test [] (common [4 3 2 8] [])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
104.evy,"// Given an array of positive integers x. return a sorted array of all
// elements that doesn't have any even digits.
// Note: Returned list should be sorted in increasing order.
// oddDigits [15 33 1422 1] // [1 15 33]
// oddDigits [152 323 1422 10] // []

func oddDigits:[]num nums:[]num
    result:[]num
    for n := range nums
        if hasNoEvenDigits n
            result = result + [n]
        end
    end
    sort result
    return result
end

func hasNoEvenDigits:bool n:num
    while n > 0
        if n % 2 == 0
            return false
        end
        n = floor n/10
    end
    return true
end

func sort arr:[]num
    // bubble sort
    for endIdx := range (len arr)-1 0 -1
        for i := range endIdx
            if arr[i] > arr[i + 1]
                tmp := arr[i]
                arr[i] = arr[i + 1]
                arr[i + 1] = tmp
            end
        end
    end
end

func testall
    test [1 15 33] (oddDigits [15 33 1422 1])
    test [] (oddDigits [152 323 1422 10])
    test [111 151] (oddDigits [12345 2033 111 151])
    test [31 135] (oddDigits [135 103 31])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
110.evy,"// In this problem, you will implement a function that takes two lists of numbers,
// and determines whether it is possible to perform an exchange of elements
// between them to make nums1 a list of only even numbers.
// There is no limit on the number of exchanged elements between nums1 and nums2:.
// If it is possible to exchange elements between the nums1 and nums2: to make
// all the elements of nums1 to be even, return ""YES"".
// Otherwise, return ""NO"".
// For example:
// solve([1, 2, 3, 4], [1, 2, 3, 4]) => ""YES""
// solve([1, 2, 3, 4], [1, 5, 3, 4]) => ""NO""
// It is assumed that the input lists will be non-empty.
func solve:string nums1:[]num nums2:[]num
    odds1 := count nums1 1
    evens2 := count nums2 0
    if odds1 <= evens2
        return ""YES""
    end
    return ""NO""
end

func count:num nums:[]num remainderMod2:num
    result := 0
    for n := range nums
        if n % 2 == remainderMod2
            result = result + 1
        end
    end
    return result
end

func testall
    test ""YES"" (solve [1 2 3 4] [1 2 3 4])
    test ""NO"" (solve [1 2 3 4] [1 5 3 4])
    test ""YES"" (solve [1 2 3 4] [2 1 4 3])
    test ""YES"" (solve [5 7 3] [2 6 4])
    test ""NO"" (solve [5 7 3] [2 6 3])
    test ""NO"" (solve [3 2 6 1 8 9] [3 5 5 1 1 1])
    test ""YES"" (solve [100 200] [200 200])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
106.evy,"// Implement the function f that takes n as a parameter,
// and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even
// or the sum of numbers from 1 to i otherwise.
// i starts from 1.
// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
// Example:
// f 5 // [1, 2, 6, 24, 15]
func f:[]num n:num
    result:[]num
    sum := 0
    fact := 1
    for i := range 1 n+1
        sum = sum + i
        fact = fact * i
        if i % 2 == 0 // sum
            result = result + [fact]
        else
            result = result + [sum]
        end
    end
    return result
end

func testall
    test [1 2 6 24 15] (f 5)
    test [1 2 6 24 15 720 28] (f 7)
    test [1] (f 1)
    test [1 2 6] (f 3)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
112.evy,"// We are given two strings s and c, you have to deleted all the characters in
// s that are equal to any character in c then check if the result string is
// palindrome. A string is called palindrome if it reads the same backward as
// forward. You should return a tuple containing the result string and
// true/false for the check.
// For s = ""abcde"", c = ""ae"", the result should be ('bcd',False)
// For s = ""abcdef"", c = ""b""  the result should be ('acdef',False)
// For s = ""abcdedcba"", c = ""ab"", the result should be ('cdedc',True)
func delete:[]any s:string d:string
    m := {}
    for c := range d
        m[c] = true
    end
    result := """"
    for c := range s
        if !(has m c)
            result = result + c
        end
    end
    for i := range (len result)/2
        if result[i] != result[-1 - i]
            return [result false]
        end
    end
    return [result true]
end

func testall
    test [""bcd"" false] (delete ""abcde"" ""ae"")
    test [""acdef"" false] (delete ""abcdef"" ""b"")
    test [""cdedc"" true] (delete ""abcdedcba"" ""ab"")
    test [""dik"" false] (delete ""dwik"" ""w"")
    test ["""" true] (delete ""a"" ""a"")
    test [""abcdedcba"" true] (delete ""abcdedcba"" """")
    test [""abcdedcba"" true] (delete ""abcdedcba"" ""v"")
    test [""abba"" true] (delete ""vabba"" ""v"")
    test ["""" true] (delete ""mamma"" ""mia"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
099.evy,"//  Create a function that takes a string value representing a number
//  and returns the closest integer to it. If the number is equidistant
//  from two integers, round it away from zero.
//  closest ""10"" // 10
//  closest ""15.3"" // 15
//
//  Note:
//  Rounding away from zero means that if the given number is equidistant
//  from two integers, the one you should return is the one that is the
//  farthest from zero. For example closest ""14.5""  should
//  return 15 and closest ""-14.5""  should return -15.
func closest:num s:string
    n := str2num s
    return round n
end

func testall
    test 10 (closest ""10"")
    test 15 (closest ""14.5"")
    test -16 (closest ""-15.5"")
    test 15 (closest ""15.3"")
    test 0 (closest ""0"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if wantType == ""[]"" or wantType == ""{}"" and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
072.evy,"// Write a function that returns True if the object q will fly, and False
// otherwise. The object q will fly if it's balanced (it is a palindromic
// list) and the sum of its elements is less than or equal the maximum
// possible weight w.
//
// Example:
// willFly [1 2] 5 ➞ False
// 1+2 is less than the maximum possible weight, but it's unbalanced.
//
// willFly [3 2 3] 1 ➞ False
// # it's balanced, but 3+2+3 is more than the maximum possible weight.
//
// willFly [3 2 3] 9 ➞ True
// # 3+2+3 is less than the maximum possible weight, and it's balanced.
//
// willFly [3] 5 ➞ True
// # 3 is less than the maximum possible weight, and it's balanced.
func willFly:bool nums:[]num w:num
    length := len nums
    if length == 0
        return false
    end
    sum := 0
    for n := range nums
        sum = sum + n
    end
    if sum > w
        return false
    end
    for i := range (floor length/2)
        if nums[i] != nums[-i - 1]
            return false
        end
    end
    return true
end

func testall
    test true (willFly [3 2 3] 9)
    test false (willFly [1 2] 5)
    test true (willFly [3] 5)
    test false (willFly [3 2 3] 1)
    test false (willFly [1 2 3] 6)
    test true (willFly [5] 5)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
066.evy,"// Write a function that takes a string as input and returns the sum of the upper characters only'
// ASCII codes.
// Examples:
// asciiSum """" // 0
// asciiSum ""abAB"" // 131
// asciiSum ""abcCd"" // 67
// asciiSum ""helloE"" // 69
// asciiSum ""woArBld"" // 131
// asciiSum ""aAaaaXa"" // 153
func asciiSum:num str:string
    abc := ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
    uppers:{}num
    for i := range (len abc)
        uppers[abc[i]] = i + 65
    end

    result := 0
    for c := range str
        if has uppers c
            result = result + uppers[c]
        end
    end
    return result
end

func testall
    test 0 (asciiSum """")
    test 131 (asciiSum ""abAB"")
    test 67 (asciiSum ""abcCd"")
    test 69 (asciiSum ""helloE"")
    test 131 (asciiSum ""woArBld"")
    test 153 (asciiSum ""aAaaaXa"")
    test 151 (asciiSum "" How are yOu?"")
    test 327 (asciiSum ""You arE Very Smart"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
067.evy,"// In this task, you will be given a string that represents a number of apples and oranges
// that are distributed in a basket of fruit this basket contains
// apples, oranges, and mango fruits. Given the string that represents the total number of
// the oranges and apples and an integer that represent the total number of the fruits
// in the basket return the number of the mango fruits in the basket.
// for example:
// mangoCount ""5 apples and 6 oranges"" 19 // 19 - 5 - 6 = 8
// mangoCount ""0 apples and 1 oranges""3 //  3 - 0 - 1 = 2
// mangoCount ""2 apples and 3 oranges"" 100 //  100 - 2 - 3 = 95
// mangoCount ""100 apples and 1 oranges""120 //  120 - 100 - 1 = 19
func mangoCount:num str:string total:num
    words := split str "" ""
    apples := str2num words[0]
    oranges := str2num words[3]
    return total - apples - oranges
end

func testall
    test 8 (mangoCount ""5 apples and 6 oranges"" 19)
    test 10 (mangoCount ""5 apples and 6 oranges"" 21)
    test 2 (mangoCount ""0 apples and 1 oranges"" 3)
    test 2 (mangoCount ""1 apples and 0 oranges"" 3)
    test 95 (mangoCount ""2 apples and 3 oranges"" 100)
    test 0 (mangoCount ""2 apples and 3 oranges"" 5)
    test 19 (mangoCount ""1 apples and 100 oranges"" 120)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
073.evy,"//  Given an array arr of integers, find the minimum number of elements that
//  need to be changed to make the array palindromic. A palindromic array is
//  an array that is read the same backwards and forwards. In one change, you
//  can change one element to any other element.
//
//  For example:
//  changeSize [1,2,3,5,4,7,9,6] //4
//  changeSize [1, 2, 3, 4, 3, 2, 2] //1
//  changeSize [1, 2, 3, 2, 1] //0
func changeSize:num nums:[]num
    result := 0
    length := len nums
    for i := range (floor length/2)
        if nums[i] != nums[-i - 1]
            result = result + 1
        end
    end
    return result
end

func testall
    test 4 (changeSize [1 2 3 5 4 7 9 6])
    test 1 (changeSize [1 2 3 4 3 2 2])
    test 1 (changeSize [1 4 2])
    test 1 (changeSize [1 4 4 2])
    test 0 (changeSize [1 2 3 2 1])
    test 0 (changeSize [3 1 1 3])
    test 0 (changeSize [1])
    test 1 (changeSize [0 1])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
098.evy,"//  Given a string s, count the number of uppercase vowels in even indices.
//
//  For example:
//  countUpper ""aBCdEf"" // 1
//  countUpper ""abcdefg"" // 0
//  countUpper ""dBBE"" // 0
func countUpper:num s:string
    m := {A:0 E:0 I:0 O:0 U:0}
    result := 0
    for i := range 0 (len s) 2
        if has m s[i]
            result = result + 1
        end
    end
    return result
end

func testall
    test 1 (countUpper ""aBCdEf"")
    test 0 (countUpper ""abcdefg"")
    test 0 (countUpper ""dBBE"")
    test 0 (countUpper ""B"")
    test 1 (countUpper ""U"")
    test 0 (countUpper """")
    test 2 (countUpper ""EEEE"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if wantType == ""[]"" or wantType == ""{}"" and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" total-fails total
end

testall
printResult
",
113.evy,"// Given a list of strings, where each string consists of only digits, return a list.
// Each element i of the output should be ""the number of odd elements in the
// string i of the input."" where all the i's should be replaced by the number
// of odd digits in the i'th string of the input.
//
// solve [""1234567""] // [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
// solve([""3"",""11111111""])
// [ ""the number of odd elements 1n the str1ng 1 of the 1nput."",
//  ""the number of odd elements 8n the str8ng 8 of the 8nput.""]
func solve:[]string arr:[]string
    result:[]string
    for s := range arr
        n := oddCount s
        r := sprintf ""the number of odd elements %vn the str%vng %v of the %vnput."" n n n n
        result = result + [r]
    end
    return result
end

func oddCount:num s:string
    result := 0
    for c := range s
        n := str2num c
        if n % 2 == 1
            result = result + 1
        end
    end
    return result
end

func testall
    test (solve [""1234567""]) [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
    test (solve [""3"" ""11111111""]) [
        ""the number of odd elements 1n the str1ng 1 of the 1nput.""
        ""the number of odd elements 8n the str8ng 8 of the 8nput.""
    ]
    test (solve [""271"" ""137"" ""314""]) [
        ""the number of odd elements 2n the str2ng 2 of the 2nput.""
        ""the number of odd elements 3n the str3ng 3 of the 3nput.""
        ""the number of odd elements 2n the str2ng 2 of the 2nput.""
    ]
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
107.evy,"// Given a positive integer n, return an array that has the number of even and odd
// integer palindromes that fall within the range(1, n), inclusive.
//
// Example 1:
//
//     Input: 3
//     Output: [1, 2]
//     Explanation:
//     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
//
// Example 2:
//
//     Input: 12
//     Output: [4, 6]
//     Explanation:
//     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
//
// Note:
//     1. 1 <= n <= 10^3
//     2. returned tuple has the number of even and odd integer palindromes respectively.
func palindromeCount:[]num n:num
    even := 0
    odd := 0
    for i := range 1 n+1
        if (isPalindrome i)
            if i % 2 == 1
                odd = odd + 1
            else
                even = even + 1
            end
        end
    end
    return [even odd]
end

func isPalindrome:bool n:num
    if n < 10
        return true
    end
    s := sprint n
    for i := range (len s)/2
        if s[i] != s[-i - 1]
            return false
        end
    end
    return true
end

func testall
    test [8 13] (palindromeCount 123)
    test [4 6] (palindromeCount 12)
    test [1 2] (palindromeCount 3)
    test [6 8] (palindromeCount 63)
    test [5 6] (palindromeCount 25)
    test [4 6] (palindromeCount 19)
    test [4 5] (palindromeCount 9)
    test [0 1] (palindromeCount 1)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
014.evy,"// Return list of all prefixes from shortest to longest of the input string
// allPrefixes('abc')
// ['a', 'ab', 'abc']
func allPrefixes:[]string str:string
    result:[]string
    for i := range (len str)
        result = result + [str[:i + 1]]
    end
    return result
end

empty_string_array:[]string

func testall
    test empty_string_array (allPrefixes """")
    test [""a"" ""as"" ""asd"" ""asdf"" ""asdfg"" ""asdfgh""] (allPrefixes ""asdfgh"")
    test [""W"" ""WW"" ""WWW""] (allPrefixes ""WWW"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
000.evy,"// Test if in given list of numbers, are any two numbers closer to each other than
// given threshold.
// hasCloseElements [1.0 2.0 3.0] 0.5 // false
// hasCloseElements [1.0 2.8 3.0 4.0 5.0 2.0] 0.3 // true
func hasCloseElements:bool numbers:[]num threshold:num
    for idx := range (len numbers)
        for idx2 := range (len numbers)
            if idx != idx2
                distance := abs (numbers[idx] - numbers[idx2])
                if distance < threshold
                    return true
                end
            end
        end
    end
    return false
end

func abs:num x:num
    if x < 0
        return -x
    end
    return x
end

func testall
    test true (hasCloseElements [1 2 3.9 4 5 2.2] 0.3)
    test false (hasCloseElements [1 2 3.9 4 5 2.2] 0.05)
    test true (hasCloseElements [1 2 5.9 4 5] 0.95)
    test false (hasCloseElements [1 2 5.9 4 5] 0.8)
    test true (hasCloseElements [1 2 3 4 5 2] 0.1)
    test true (hasCloseElements [1.1 2.2 3.1 4.1 5.1] 1)
    test false (hasCloseElements [1.1 2.2 3.1 4.1 5.1] 0.5)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
028.evy,"// Concatenate list of strings into a single string
// concatenate []  // """"
// concatenate [""a"", ""b"", ""c""] ""abc""
func concatenate:string strings:[]string
    return (join strings """")
end

func testall
    test """" (concatenate [])
    test ""xyz"" (concatenate [""x"" ""y"" ""z""])
    test ""xyzwk"" (concatenate [""x"" ""y"" ""z"" ""w"" ""k""])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult

",
029.evy,"// Filter an input list of strings only for ones that start with a given prefix.
// filterByPrefix([], ""a"") // []
// filterByPrefix([""abc"", ""bcd"", ""cde"", ""array""], ""a"") // [""abc"", ""array""]
func filterByPrefix:[]string strings:[]string prefix:string
    result:[]string
    for s := range strings
        if startswith s prefix
            result = result + [s]
        end
    end
    return result
end

func testall
    test [] (filterByPrefix [] ""john"")
    test [""xxx"" ""xxxAAA"" ""xxx""] (filterByPrefix [""xxx"" ""asd"" ""xxy"" ""john doe"" ""xxxAAA"" ""xxx""] ""xxx"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult

",
001.evy,"// Input to this function is a string containing multiple groups of nested
// parentheses. Your goal is to separate those group into separate strings
// and return the list of those. Separate groups are balanced (each open
// brace is properly closed) and not nested within each other Ignore any
// spaces in the input string.
//
//    separateParenGroups ""( ) (( )) (( )( ))""
//    // [""()"" ""(())"" ""(()())""]
//
func separateParenGroups:[]string paren_string:string
    result:[]string
    current_string:string
    current_depth:num
    current_depth = 0

    for c := range (len paren_string)
        if paren_string[c] == ""(""
            current_depth = current_depth + 1
            current_string = current_string + paren_string[c]
        else if paren_string[c] == "")""
            current_depth = current_depth - 1
            current_string = current_string + paren_string[c]

            if current_depth == 0
                result = result + [current_string]
                current_string = """"
            end
        end
    end

    return result
end

func testall
    test [""(()())"" ""((()))"" ""()"" ""((())()())""] (separateParenGroups ""(()()) ((())) () ((())()())"")
    test [""()"" ""(())"" ""((()))"" ""(((())))""] (separateParenGroups ""() (()) ((())) (((())))"")
    test [""(()(())((())))""] (separateParenGroups ""(()(())((())))"")
    test [""()"" ""(())"" ""(()())""] (separateParenGroups ""( ) (( )) (( )( ))"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
015.evy,"// Return a string containing space-delimited numbers starting from 0 up to n inclusive.
// stringSequence 0 // ""0""
// stringSequence 5 // ""0 1 2 3 4 5""
func stringSequence:string n:num
    str := ""0""
    for x := range n
        str = sprintf ""%s %v"" str x+1
    end
    return str
end

func testall
    test ""0"" (stringSequence 0)
    test ""0 1 2 3"" (stringSequence 3)
    test ""0 1 2 3 4 5 6 7 8 9 10"" (stringSequence 10)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
003.evy,"// You're given an array of deposit and withdrawal operations on a bank account that starts with
// zero balance. Your task is to detect if at any point the balance of account falls below zero, and
// at that point function should return true. Otherwise it should return False.
// belowZero [1 2 3] // false
// belowZero([1 2 -4 5] // true
func belowZero:bool operations:[]num
    balance := 0
    for op := range (len operations)
        balance = balance + operations[op]
        if balance < 0
            return true
        end
    end
    return false
end

func testall
    test false (belowZero [])
    test false (belowZero [1 2 -3 1 2 -3])
    test true (belowZero [1 2 -4 5 6])
    test false (belowZero [1 -1 2 -2 5 -5 4 -4])
    test true (belowZero [1 -1 2 -2 5 -5 4 -5])
    test true (belowZero [1 -2 2 -2 5 -5 4 -4])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
017.evy,"// Input to this function is a string representing musical notes in a special ASCII format.
// Your task is to parse this string and return list of integers corresponding to how many beats does each
// not last.
//
// Here is a legend:
//   ""o"" - whole note, lasts four beats
//   ""o|"" - half note, lasts two beats
//   "".|"" - quarter note, lasts one beat
//
// parseMusic ""o o| .| o| o| .| .| .| .| o o""
//    // [4 2 1 2 2 1 1 1 1 4 4]
//
func parseMusic:[]num music:string
    if music == """"
        return []
    end
    lookup:{}num
    lookup[""o""] = 4
    lookup[""o|""] = 2
    lookup["".|""] = 1
    notes := split music "" ""
    beats:[]num
    for note := range notes
        beats = beats + [lookup[note]]
    end
    return beats
end

func testall
    test [] (parseMusic """")
    test [4 4 4 4] (parseMusic ""o o o o"")
    test [1 1 1 1] (parseMusic "".| .| .| .|"")
    test [2 2 1 1 4 4 4 4] (parseMusic ""o| o| .| .| o o o o"")
    test [2 1 2 1 4 2 4 2] (parseMusic ""o| .| o| .| o o| o o|"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult

",
016.evy,"//  Given a string, find out how many distinct characters (regardless of case) does it consist of
//  countDistinctCharacters('xyzXYZ') // 3
//  countDistinctCharacters('Jerry') // 4
func countDistinctCharacters:num str:string
    set := {}
    for s := range str
        u := upper s
        set[u] = true
    end
    return len set
end

func testall
    test 0 (countDistinctCharacters """")
    test 5 (countDistinctCharacters ""abcde"")
    test 5 (countDistinctCharacters ""abcde""+""cade""+""CADE"")
    test 1 (countDistinctCharacters ""aaaaAAAAaaaa"")
    test 5 (countDistinctCharacters ""Jerry jERRY JeRRRY"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
002.evy,"// Given a positive floating point number, it can be decomposed into
// and integer part (largest integer smaller than given number) and decimals
// (leftover part always smaller than 1).
// Return the decimal part of the number.
// truncate_number 3.5 // 0.5
func truncateNumber:num number:num
    return number % 1
end

func testall
    test 0.5 (truncateNumber 3.5)
    test true (((abs (truncateNumber (1.33 - 0.33))) < 0.000001))
    test true (((abs (truncateNumber (123.456 - 0.456))) < 0.000001))
end

func abs:num x:num
    if x < 0
        return -x
    end
    return x
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
006.evy,"// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
// For each of the group, output the deepest level of nesting of parentheses.
// E.g. (()()) has maximum two levels of nesting while ((())) has three.
// parseNestedParens ""(()()) ((())) () ((())()())"" // [2 3 1 3]
func parse_paren_group:num s:string
    depth:num
    max_depth:num
    for c := range s
        if c == ""(""
            depth = depth + 1
            max_depth = max depth max_depth
        else
            depth = depth - 1
        end
    end
    return max_depth
end

func parseNestedParens:[]num paren_string:string
    result:[]num
    for x := range (split paren_string "" "")
        if x != """"
            result = result + [(parse_paren_group x)]
        end
    end
    return result
end

func testall
    test [2 3 1 3] (parseNestedParens ""(()()) ((())) () ((())()())"")
    test [1 2 3 4] (parseNestedParens ""() (()) ((())) (((())))"")
    test [4] (parseNestedParens ""(()(())((())))"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
012.evy,"// Out of list of strings, return the longest one. Return the first one in
// case of multiple strings of the same length. Return """" in case the input
// list is empty.
// longest [] // """"
// longest([""a"" ""b"" ""c""]) // ""a""
// longest([""a"" ""bb"" ""ccc""]) ""ccc""
func longest:string strings:[]string
    if (len strings) == 0
        return """"
    end
    maxlen := 0
    for s := range strings
        if (len s) > maxlen
            maxlen = (len s)
        end
    end
    for s := range strings
        if (len s) == maxlen
            return s
        end
    end
    return """"
end

func testall
    test """" (longest [])
    test ""x"" (longest [""x"" ""y"" ""z""])
    test ""zzzz"" (longest [""x"" ""yyy"" ""zzzz"" ""www"" ""kkkk"" ""abc""])
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
013.evy,"// Return a  greatest common divisor of two integers a and b
// gcd(3, 5) // 1
// gcd(25, 15) // 5
func gcd:num a:num b:num
    while b != 0
        tmp := a
        a = b
        b = tmp % b
    end
    return a
end

func testall
    test 1 (gcd 3 7)
    test 5 (gcd 10 15)
    test 7 (gcd 49 14)
    test 12 (gcd 144 60)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
007.evy,"// Filter an input list of strings only for ones that contain given substring
// filter [] ""a"" // []
// filter [""abc"" ""bacd"" ""cde"" ""array""] ""a""  // [""abc"" ""bacd"" ""array""]
func filter:[]string strings:[]string substring:string
    ans:[]string
    for str := range strings
        if (contains str substring)
            ans = ans + [str]
        end
    end
    return ans
end

func contains:bool haystack:string needle:string
    for i := range ((len haystack) - (len needle) + 1)
        if haystack[i:i + (len needle)] == needle
            return true
        end
    end
    return false
end

func testall
    test [] (filter [] ""john"")
    test [""xxx"" ""xxxAAA"" ""xxx""] (filter [""xxx"" ""asd"" ""xxy"" ""john doe"" ""xxxAAA"" ""xxx""] ""xxx"")
    test [""xxx"" ""aaaxxy"" ""xxxAAA"" ""xxx""] (filter [""xxx"" ""asd"" ""aaaxxy"" ""john doe"" ""xxxAAA"" ""xxx""] ""xx"")
    test [""grunt"" ""prune""] (filter [""grunt"" ""trumpet"" ""prune"" ""gruesome""] ""run"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
039.evy,"// primeFib returns n-th number that is a Fibonacci number and it's also
// prime.
// primeFib(1) // 2
// primeFib(2) // 3
// primeFib(3) // 5
// primeFib(4) // 13
// primeFib(5) // 89
func primeFib:num n:num
    f := [0 1]
    while true
        f = f + [f[-1]+f[-2]]
        if isPrime f[-1]
            n = n - 1
        end
        if n == 0
            return f[-1]
        end
    end
    return -1
end

func isPrime:bool n:num
    if n < 2
        return false
    end

    for k := range 2 (min (ceil (sqrt n))+1 n-1)
        if n % k == 0
            return false
        end
    end
    return true
end

func testall
    test 2 (primeFib 1)
    test 3 (primeFib 2)
    test 5 (primeFib 3)
    test 13 (primeFib 4)
    test 89 (primeFib 5)
    test 233 (primeFib 6)
    test 1597 (primeFib 7)
    test 28657 (primeFib 8)
    test 514229 (primeFib 9)
    test 433494437 (primeFib 10)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult

",
011.evy,"// Input are two strings a and b consisting only of 1s and 0s.
// Perform binary XOR on these inputs and return result also as a string.
//
//    stringXor ""010"" ""110"" //  100
func stringXor:string a:string b:string
    res:string
    for i := range (len a)
        if a[i] == b[i]
            res = res + ""0""
        else
            res = res + ""1""
        end
    end
    return res
end

func testall
    test ""010010"" (stringXor ""111000"" ""101010"")
    test ""0"" (stringXor ""1"" ""1"")
    test ""0101"" (stringXor ""0101"" ""0000"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
005.evy,"// Insert a number 'delimeter' between every two consecutive elements of input list `numbers'
// intersperse [] 4 //
// intersperse [1 2 3] 4 // [1 4 2 4 3]
func intersperse:[]num numbers:[]num delimeter:num
    if (len numbers) == 0
        return []
    end
    result:[]num
    for number := range numbers[:-1]
        result = result + [number] + [delimeter]
    end
    result = result + [numbers[-1]]
    return result
end

func testall
    test [] (intersperse [] 7)
    test [5 8 6 8 3 8 2] (intersperse [5 6 3 2] 8)
    test [2 2 2 2 2] (intersperse [2 2 2] 2)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
004.evy,"// For a given list of input numbers, calculate Mean Absolute Deviation around
// the mean of this dataset. Mean Absolute Deviation is the average absolute
// difference between each element and a centerpoint (mean in this case):
// MAD = average | x - x_mean |
// meanAbsoluteDeviation [1.0 2.0 3.0 4.0]
// 1.0
func meanAbsoluteDeviation:num numbers:[]num
    mean := (sum numbers) / (len numbers)
    stdev := 0
    for number := range numbers
        stdev = stdev + (abs (number - mean))
    end
    return stdev / (len numbers)
end

func sum:num numbers:[]num
    total := 0
    for number := range numbers
        total = total + number
    end
    return total
end

func abs:num x:num
    if x < 0
        return -x
    end
    return x
end

func testall
    test true ((abs ((meanAbsoluteDeviation [1 2 3]) - 2 / 3)) < 0.000001)
    test true ((abs ((meanAbsoluteDeviation [1 2 3 4]) - 1)) < 0.000001)
    test true ((abs ((meanAbsoluteDeviation [1 2 3 4 5]) - 6 / 5)) < 0.000001)
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
010.evy,"// Test if given string is a palindrome
func isPalindrome:bool str:string
    return str == (reverse str)
end

// Find the shortest palindrome that begins with a supplied string.
// Algorithm idea is simple:
// - Find the longest postfix of supplied string that is a palindrome.
// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
//
//    makePalindrome("""") // """"
//    makePalindrome(""cat"") // ""catac""
//    makePalindrome(""cata"") // ""catac""
func makePalindrome:string str:string
    if str == """"
        return """"
    end
    beginning_of_suffix := 0
    while !(isPalindrome str[beginning_of_suffix:])
        beginning_of_suffix = beginning_of_suffix + 1
    end
    return str + (reverse str[:beginning_of_suffix])
end

func reverse:string str:string
    reversed := """"
    for i := range (len str)
        reversed = str[i] + reversed
    end
    return reversed
end

func testall
    test """" (makePalindrome """")
    test ""x"" (makePalindrome ""x"")
    test ""xyzyx"" (makePalindrome ""xyz"")
    test ""xyx"" (makePalindrome ""xyx"")
    test ""catac"" (makePalindrome ""cata"")
    test ""jerryrrej"" (makePalindrome ""jerry"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult
",
038.evy,"//  returns encoded string by cycling groups of three characters.
func encode:string s:string
    // split string to groups. Each of length 3.
    groups := group3 s
    for i := range (len groups)
        if (len groups[i]) == 3
            g := groups[i]
            groups[i] = g[1:] + g[0]
        end
    end
    return join groups """"
end

//  takes as input string encoded with encode function. Returns decoded string.
func decode:string s:string
    groups := group3 s
    for i := range (len groups)
        if (len groups[i]) == 3
            g := groups[i]
            groups[i] = g[-1] + g[:-1]
        end
    end
    return join groups """"
end

func group3:[]string s:string
    result:[]string
    for i := range (floor ((len s) + 2)/3)
        startIdx := 3 * i
        endIdx := min 3*i+3 (len s)
        g := s[startIdx:endIdx]
        result = result + [g]
    end
    return result
end

func testall
    s := ""lorem ipsum""
    test s (decode (encode s))
    test ""bca"" (encode ""abc"")
    test ""abc"" (decode ""bca"")
    test ""bcad"" (encode ""abcd"")
    test ""abcd"" (decode ""bcad"")
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult

",
32.evy,"// Evaluates polynomial with coefficients xs at point x.
// return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n
func polyxs:num xs:[]num x:num
    print xs x
    return 0
end

// xs are coefficients of a polynomial.
// find_zero find x such that poly(x) = 0.
// find_zero returns only only zero point, even if there are many.
// Moreover, find_zero only takes list xs having even number of coefficients
// and largest non zero coefficient as it guarantees
// a solution.
// round(find_zero([1, 2]), 2) # f(x) = 1 + 2x // -0.5
// round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 // 1.0
func find_zero:num xs:[]num
    print xs
    // [begin end_ ] := [-1.0 1.0 ]
    // while .poly (xs begin) * .poly (xs end_) > 0
    //     begin = begin * 2.0
    //     end_ = end_ * 2.0
    // end
    // while end_ - begin > 1e-10
    //     center := begin + end_ / 2.0
    //     if .poly (xs center) * .poly (xs begin) > 0
    //         begin := center
    //         center
    //     else
    //         end_ := center
    //     end
    // end
    // return begin
    return 0
end

func testall
    // rng := random.Random (42)
    //     ncoeff := 2 * rng.randint (1 4)
    //     coeffs := []
    //         coeff := rng.randint (-10 10)
    //         if coeff == 0
    //             coeff = 1
    //         end
    //         coeffs = coeffs + [coeff]
    //     end
    //     solution := .candidate (copy.deepcopy (coeffs))
    //      test math.fabs (.poly (coeffs solution)) < 0.0001
    // end
end

// Test boilerplate
fails := 0
total := 0

func test want:any got:any
    total = total + 1
    if want == got
        return
    end
    wantType := (typeof want)[:2]
    gotType := (typeof got)[:2]
    if (wantType == ""[]"" or wantType == ""{}"") and wantType == gotType and (len want) == 0 and (len got) == 0
        return
    end
    fails = fails + 1
    printf ""want != got:\n want: %v\n got:  %v\n"" want got
end

func printResult
    printf ""%2.f of %2.f tests passed\n"" (total - fails) total
end

testall
printResult

",
HumanEval_91_convert.evy,,
HumanEval_140_convert.evy,"func fix_spacestext
    //""
    //    Given a string text, replace all spaces in it with underscores, 
    //    and if a string has more than 2 consecutive spaces, 
    //    then replace all consecutive spaces with - 
    //    
    //    fix_spaces(""Example"") == ""Example""
    //    fix_spaces(""Example 1"") == ""Example_1""
    //    fix_spaces("" Example 2"") == ""_Example_2""
    //    fix_spaces("" Example   3"") == ""_Example-3""
    //    ""
    new_text := """"
    i := 0
    [start end_ ] := [0 0 ]
    while i < .len (text)
        if texti == "" ""
            end_ = end_ + 1
        else if end_ - start > 2
            new_text = new_text + ""-"" + texti
            [i + 1 i + 1 ]
        else
            if end_ - start > 2
                new_text = new_text + ""-"" + texti
            else if end_ - start > 0
                new_text = new_text + ""_"" * end_ - start + texti
            else
                if end_ - start > 0
                    new_text = new_text + ""_"" * end_ - start + texti
                    texti
                else
                    new_text = new_text + texti
                end
            end
            [start end_ ] = [i + 1 i + 1 ]
        end
        i = i + 1
    end
    if end_ - start > 2
        new_text = new_text + ""-""
    else if end_ - start > 0
        new_text = new_text + ""_""
    else
        if end_ - start > 0
            new_text = new_text + ""_""
        end
    end
    return new_text

end
func checkcandidate
    assert .candidate (""Example"") == ""Example""
    assert .candidate (""Mudasir Hanif "") == ""Mudasir_Hanif_""
    assert .candidate (""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow""
    assert .candidate (""Exa   mple"") == ""Exa-mple""
    assert .candidate (""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple""

end
.check (fix_spaces)",
HumanEval_42_convert.evy,"func incr_listl:list
    //""Return list with elements incremented by 1.
    //    >>> incr_list([1, 2, 3])
    //    [2, 3, 4]
    //    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])
    //    [6, 4, 6, 3, 4, 4, 10, 1, 124]
    //    ""
    return __evy_listcomp_ := []
    for e := l:

end
METADATA := {}
func checkcandidate
    assert .candidate ([]) == []
    assert .candidate ([3 2 1 ]) == [4 3 2 ]
    assert .candidate ([5 2 5 2 3 3 9 0 123 ]) == [6 3 6 3 4 4 10 1 124 ]

end
.check (incr_list)",
HumanEval_7_convert.evy,"func filter_by_substring:[]string strings:[]string substring:string
    //"" Filter an input list of strings only for ones that contain given substring
    //    >>> filter_by_substring([], 'a')
    //    []
    //    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')
    //    ['abc', 'bacd', 'array']
    //    ""
    return __evy_listcomp_ := []
    for x := strings:
    if (has x substring)

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate ([] ""john"") == []
    assert .candidate ([""xxx"" ""asd"" ""xxy"" ""john doe"" ""xxxAAA"" ""xxx"" ] ""xxx"") == [""xxx"" ""xxxAAA"" ""xxx"" ]
    assert .candidate ([""xxx"" ""asd"" ""aaaxxy"" ""john doe"" ""xxxAAA"" ""xxx"" ] ""xx"") == [""xxx"" ""aaaxxy"" ""xxxAAA"" ""xxx"" ]
    assert .candidate ([""grunt"" ""trumpet"" ""prune"" ""gruesome"" ] ""run"") == [""grunt"" ""prune"" ]

end
.check (filter_by_substring)",
HumanEval_32_convert.evy,"func polyxs:list x:float
    //""
    //    Evaluates polynomial with coefficients xs at point x.
    //    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n
    //    ""
    return .sum (__evy_listcomp_ := []
    for [i coeff ] := .enumerate (xs):
    )

end
func find_zeroxs:list
    //"" xs are coefficients of a polynomial.
    //    find_zero find x such that poly(x) = 0.
    //    find_zero returns only only zero point, even if there are many.
    //    Moreover, find_zero only takes list xs having even number of coefficients
    //    and largest non zero coefficient as it guarantees
    //    a solution.
    //    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x
    //    -0.5
    //    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3
    //    1.0
    //    ""
    [begin end_ ] := [-1.0 1.0 ]
    while .poly (xs begin) * .poly (xs end_) > 0
        begin = begin * 2.0
        end_ = end_ * 2.0
    end
    while end_ - begin > 1e-10
        center := begin + end_ / 2.0
        if .poly (xs center) * .poly (xs begin) > 0
            begin := center
            center
        else
            end_ := center
        end
    end
    return begin

end
METADATA := {}
func checkcandidate
    
    
    rng := random.Random (42)
    
        ncoeff := 2 * rng.randint (1 4)
        coeffs := []
            coeff := rng.randint (-10 10)
            if coeff == 0
                coeff = 1
            end
            coeffs = coeffs + [coeff]
        end
        solution := .candidate (copy.deepcopy (coeffs))
        assert math.fabs (.poly (coeffs solution)) < 0.0001
    end

end
.check (find_zero)",
HumanEval_130_convert.evy,"func trin
    //""Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
    //    the last couple centuries. However, what people don't know is Tribonacci sequence.
    //    Tribonacci sequence is defined by the recurrence:
    //    tri(1) = 3
    //    tri(n) = 1 + n / 2, if n is even.
    //    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
    //    For example:
    //    tri(2) = 1 + (2 / 2) = 2
    //    tri(4) = 3
    //    tri(3) = tri(2) + tri(1) + tri(4)
    //           = 2 + 3 + 3 = 8 
    //    You are given a non-negative integer number n, you have to a return a list of the 
    //    first n + 1 numbers of the Tribonacci sequence.
    //    Examples:
    //    tri(3) = [1, 3, 2, 8]
    //    ""
    if n == 0
        return [1 ]
    end
    my_tri := [1 3 ]
        if i % 2 == 0
            my_tri = my_tri + [i / 2 + 1]
            my_tri = my_tri + [my_trii - 1 + my_trii - 2 + i + 3 / 2]
        else
            my_tri = my_tri + [my_trii - 1 + my_trii - 2 + i + 3 / 2]
        end
    end
    return my_tri

end
func checkcandidate
    assert .candidate (3) == [1 3 2.0 8.0 ]
    assert .candidate (4) == [1 3 2.0 8.0 3.0 ]
    assert .candidate (5) == [1 3 2.0 8.0 3.0 15.0 ]
    assert .candidate (6) == [1 3 2.0 8.0 3.0 15.0 4.0 ]
    assert .candidate (7) == [1 3 2.0 8.0 3.0 15.0 4.0 24.0 ]
    assert .candidate (8) == [1 3 2.0 8.0 3.0 15.0 4.0 24.0 5.0 ]
    assert .candidate (9) == [1 3 2.0 8.0 3.0 15.0 4.0 24.0 5.0 35.0 ]
    assert .candidate (20) == [1 3 2.0 8.0 3.0 15.0 4.0 24.0 5.0 35.0 6.0 48.0 7.0 63.0 8.0 80.0 9.0 99.0 10.0 120.0 11.0 ]
    assert .candidate (0) == [1 ]
    assert .candidate (1) == [1 3 ]

end
.check (tri)",
HumanEval_102_convert.evy,"func choose_numx y
    //""This function takes two positive numbers x and y and returns the
    //    biggest even integer number that is in the range [x, y] inclusive. If 
    //    there's no such number, then the function should return -1.
    //
    //    For example:
    //    choose_num(12, 15) = 14
    //    choose_num(13, 12) = -1
    //    ""
    if x > y
        return -1
    end
    if y % 2 == 0
        return y
    end
    if x == y
        return -1
    end
    return y - 1

end
func checkcandidate
    assert .candidate (12 15) == 14
    assert .candidate (13 12) == -1
    assert .candidate (33 12354) == 12354
    assert .candidate (5234 5233) == -1
    assert .candidate (6 29) == 28
    assert .candidate (27 10) == -1
    assert .candidate (7 7) == -1
    assert .candidate (546 546) == 546

end
.check (choose_num)",
HumanEval_70_convert.evy,,
HumanEval_117_convert.evy,"func select_wordss n
    //""Given a string s and a natural number n, you have been tasked to implement 
    //    a function that returns a list of all words from string s that contain exactly 
    //    n consonants, in order these words appear in the string s.
    //    If the string s is empty then the function should return an empty list.
    //    Note: you may assume the input string contains only letters and spaces.
    //    Examples:
    //    select_words(""Mary had a little lamb"", 4) ==> [""little""]
    //    select_words(""Mary had a little lamb"", 3) ==> [""Mary"", ""lamb""]
    //    select_words(""simple white space"", 2) ==> []
    //    select_words(""Hello world"", 4) ==> [""world""]
    //    select_words(""Uncle sam"", 3) ==> [""Uncle""]
    //    ""
    result := []
        n_consonants := 0
            if !(has [""a"" ""e"" ""i"" ""o"" ""u"" ] wordi.lower ())
                n_consonants = n_consonants + 1
            end
        end
        if n_consonants == n
            result = result + [word]
        end
    end
    return result

end
func checkcandidate
    assert .candidate (""Mary had a little lamb"" 4) == [""little"" ]
    assert .candidate (""Mary had a little lamb"" 3) == [""Mary"" ""lamb"" ]
    assert .candidate (""simple white space"" 2) == []
    assert .candidate (""Hello world"" 4) == [""world"" ]
    assert .candidate (""Uncle sam"" 3) == [""Uncle"" ]
    assert .candidate ("""" 4) == []
    assert .candidate (""a b c d e f"" 1) == [""b"" ""c"" ""d"" ""f"" ]

end
.check (select_words)",
HumanEval_15_convert.evy,"func string_sequence:string n:int
    //"" Return a string containing space-delimited numbers starting from 0 upto n inclusive.
    //    >>> string_sequence(0)
    //    '0'
    //    >>> string_sequence(5)
    //    '0 1 2 3 4 5'
    //    ""
    return (join __evy_listcomp_ := []
    for x := .range (n + 1):
     "" "")

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate (0) == ""0""
    assert .candidate (3) == ""0 1 2 3""
    assert .candidate (10) == ""0 1 2 3 4 5 6 7 8 9 10""

end
.check (string_sequence)",
HumanEval_65_convert.evy,"func circular_shiftx shift
    //""Circular shift the digits of the integer x, shift the digits right by shift
    //    and return the result as a string.
    //    If shift > number of digits, return digits reversed.
    //    >>> circular_shift(12, 1)
    //    ""21""
    //    >>> circular_shift(12, 2)
    //    ""12""
    //    ""
    s := .str (x)
    if shift > .len (s)
        return s[0:]
        s[.len (s) - shift:] + s[0:.len (s) - shift]
    else
        return s[.len (s) - shift:] + s[0:.len (s) - shift]
    end

end
func checkcandidate
    assert .candidate (100 2) == ""001""
    assert .candidate (12 2) == ""12""
    assert .candidate (97 8) == ""79""
    assert .candidate (12 1) == ""21""
    assert .candidate (11 101) == ""11""

end
.check (circular_shift)",
HumanEval_98_convert.evy,"func count_uppers
    //""
    //    Given a string s, count the number of uppercase vowels in even indices.
    //    
    //    For example:
    //    count_upper('aBCdEf') returns 1
    //    count_upper('abcdefg') returns 0
    //    count_upper('dBBE') returns 0
    //    ""
    count := 0
        if (has ""AEIOU"" si)
            count = count + 1
        end
    end
    return count

end
func checkcandidate
    assert .candidate (""aBCdEf"") == 1
    assert .candidate (""abcdefg"") == 0
    assert .candidate (""dBBE"") == 0
    assert .candidate (""B"") == 0
    assert .candidate (""U"") == 1
    assert .candidate ("""") == 0
    assert .candidate (""EEEE"") == 2
    assert true

end
.check (count_upper)",
HumanEval_139_convert.evy,"func special_factorialn
    //""The Brazilian factorial is defined as:
    //    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
    //    where n > 0
    //
    //    For example:
    //    >>> special_factorial(4)
    //    288
    //
    //    The function will receive an integer as input and should return the special
    //    factorial of this integer.
    //    ""
    fact_i := 1
    special_fact := 1
        fact_i = fact_i * i
        special_fact = special_fact * fact_i
    end
    return special_fact

end
func checkcandidate
    assert .candidate (4) == 288
    assert .candidate (5) == 34560
    assert .candidate (7) == 125411328000
    assert .candidate (1) == 1

end
.check (special_factorial)",
HumanEval_149_convert.evy,"func sorted_list_sumlst
    //""Write a function that accepts a list of strings as a parameter,
    //    deletes the strings that have odd lengths from it,
    //    and returns the resulted list with a sorted order,
    //    The list is always a list of strings and never an array of numbers,
    //    and it may contain duplicates.
    //    The order of the list should be ascending by length of each word, and you
    //    should return the list sorted by that rule.
    //    If two words have the same length, sort the list alphabetically.
    //    The function should return a list of strings in sorted order.
    //    You may assume that all words will have the same length.
    //    For example:
    //    assert list_sort([""aa"", ""a"", ""aaa""]) => [""aa""]
    //    assert list_sort([""ab"", ""a"", ""aaa"", ""cd""]) => [""ab"", ""cd""]
    //    ""
    lst.sort ()
    new_lst := []
        if .len (i) % 2 == 0
            new_lst = new_lst + [i]
        end
    end
    return .sorted (new_lst)

end
func checkcandidate
    assert .candidate ([""aa"" ""a"" ""aaa"" ]) == [""aa"" ]
    assert .candidate ([""school"" ""AI"" ""asdf"" ""b"" ]) == [""AI"" ""asdf"" ""school"" ]
    assert .candidate ([""d"" ""b"" ""c"" ""a"" ]) == []
    assert .candidate ([""d"" ""dcba"" ""abcd"" ""a"" ]) == [""abcd"" ""dcba"" ]
    assert .candidate ([""AI"" ""ai"" ""au"" ]) == [""AI"" ""ai"" ""au"" ]
    assert .candidate ([""a"" ""b"" ""b"" ""c"" ""c"" ""a"" ]) == []
    assert .candidate ([""aaaa"" ""bbbb"" ""dd"" ""cc"" ]) == [""cc"" ""dd"" ""aaaa"" ""bbbb"" ]

end
.check (sorted_list_sum)",
HumanEval_155_convert.evy,"func even_odd_countnum
    //""Given an integer. return a tuple that has the number of even and odd digits respectively.
    //
    //     Example:
    //        even_odd_count(-12) ==> (1, 1)
    //        even_odd_count(123) ==> (1, 2)
    //    ""
    even_count := 0
    odd_count := 0
        if .int (i) % 2 == 0
            even_count = even_count + 1
            1
        else
            odd_count = odd_count + 1
        end
    end
    return [even_count odd_count ]

end
func checkcandidate
    assert .candidate (7) == [0 1 ]
    assert .candidate (-78) == [1 1 ]
    assert .candidate (3452) == [2 2 ]
    assert .candidate (346211) == [3 3 ]
    assert .candidate (-345821) == [3 3 ]
    assert .candidate (-2) == [1 0 ]
    assert .candidate (-45347) == [2 3 ]
    assert .candidate (0) == [1 0 ]
    assert true

end
.check (even_odd_count)",
HumanEval_57_convert.evy,"func monotonicl:list
    //""Return True is list elements are monotonically increasing or decreasing.
    //    >>> monotonic([1, 2, 4, 20])
    //    True
    //    >>> monotonic([1, 20, 4, 10])
    //    False
    //    >>> monotonic([4, 1, 0, -10])
    //    True
    //    ""
    if l == .sorted (l) l == .sorted (l) or
        return true
    end
    return false

end
METADATA := {}
func checkcandidate
    assert .candidate ([1 2 4 10 ]) == true
    assert .candidate ([1 2 4 20 ]) == true
    assert .candidate ([1 20 4 10 ]) == false
    assert .candidate ([4 1 0 -10 ]) == true
    assert .candidate ([4 1 1 0 ]) == true
    assert .candidate ([1 2 3 2 5 60 ]) == false
    assert .candidate ([1 2 3 4 5 60 ]) == true
    assert .candidate ([9 9 9 9 ]) == true

end
.check (monotonic)",
HumanEval_27_convert.evy,"func flip_case:string string:string
    //"" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
    //    >>> flip_case('Hello')
    //    'hELLO'
    //    ""
    return string_.swapcase ()

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate ("""") == """"
    assert .candidate (""Hello!"") == ""hELLO!""
    assert .candidate (""These violent delights have violent ends"") == ""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS""

end
.check (flip_case)",
HumanEval_125_convert.evy,"func split_wordstxt
    //""
    //    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you
    //    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the
    //    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25
    //    Examples
    //    split_words(""Hello world!"") ➞ [""Hello"", ""world!""]
    //    split_words(""Hello,world!"") ➞ [""Hello"", ""world!""]
    //    split_words(""abcdef"") == 3 
    //    ""
    if (has txt "" "")
        return txt.split ()
    else if (has txt "","")
        return txt.replace ("","" "" "").split ()
    else
        if (has txt "","")
            return txt.replace ("","" "" "").split ()
            .len (__evy_listcomp_ := []
            for i := txt:
            if i.islower () .ord (i) % 2 == 0 and
            )
        else
            return .len (__evy_listcomp_ := []
            for i := txt:
            if i.islower () .ord (i) % 2 == 0 and
            )
        end
    end

end
func checkcandidate
    assert .candidate (""Hello world!"") == [""Hello"" ""world!"" ]
    assert .candidate (""Hello,world!"") == [""Hello"" ""world!"" ]
    assert .candidate (""Hello world,!"") == [""Hello"" ""world,!"" ]
    assert .candidate (""Hello,Hello,world !"") == [""Hello,Hello,world"" ""!"" ]
    assert .candidate (""abcdef"") == 3
    assert .candidate (""aaabb"") == 2
    assert .candidate (""aaaBb"") == 1
    assert .candidate ("""") == 0

end
.check (split_words)",
HumanEval_84_convert.evy,,
HumanEval_79_convert.evy,"func decimal_to_binarydecimal
    //""You will be given a number in decimal form and your task is to convert it to
    //    binary format. The function should return a string, with each character representing a binary
    //    number. Each character in the string will be '0' or '1'.
    //
    //    There will be an extra couple of characters 'db' at the beginning and at the end of the string.
    //    The extra characters are there to help with the format.
    //
    //    Examples:
    //    decimal_to_binary(15)   # returns ""db1111db""
    //    decimal_to_binary(32)   # returns ""db100000db""
    //    ""
    return ""db"" + .bin (decimal)[2:] + ""db""

end
func checkcandidate
    assert .candidate (0) == ""db0db""
    assert .candidate (32) == ""db100000db""
    assert .candidate (103) == ""db1100111db""
    assert .candidate (15) == ""db1111db""
    assert true

end
.check (decimal_to_binary)",
HumanEval_162_convert.evy,,
HumanEval_60_convert.evy,"func sum_to_nn:int
    //""sum_to_n is a function that sums numbers from 1 to n.
    //    >>> sum_to_n(30)
    //    465
    //    >>> sum_to_n(100)
    //    5050
    //    >>> sum_to_n(5)
    //    15
    //    >>> sum_to_n(10)
    //    55
    //    >>> sum_to_n(1)
    //    1
    //    ""
    return .sum (.range (n + 1))

end
METADATA := {}
func checkcandidate
    assert .candidate (1) == 1
    assert .candidate (6) == 21
    assert .candidate (11) == 66
    assert .candidate (30) == 465
    assert .candidate (100) == 5050

end
.check (sum_to_n)",
HumanEval_10_convert.evy,"func is_palindrome:bool string:string
    //"" Test if given string is a palindrome ""
    return string_ == string_[0:]

end
func make_palindrome:string string:string
    //"" Find the shortest palindrome that begins with a supplied string.
    //    Algorithm idea is simple:
    //    - Find the longest postfix of supplied string that is a palindrome.
    //    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
    //    >>> make_palindrome('')
    //    ''
    //    >>> make_palindrome('cat')
    //    'catac'
    //    >>> make_palindrome('cata')
    //    'catac'
    //    ""
    if !string_
        return """"
    end
    beginning_of_suffix := 0
    while !.is_palindrome (string_[beginning_of_suffix:])
        beginning_of_suffix = beginning_of_suffix + 1
    end
    return string_ + string_[0:beginning_of_suffix][0:]

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate ("""") == """"
    assert .candidate (""x"") == ""x""
    assert .candidate (""xyz"") == ""xyzyx""
    assert .candidate (""xyx"") == ""xyx""
    assert .candidate (""jerry"") == ""jerryrrej""

end
.check (make_palindrome)",
HumanEval_112_convert.evy,"func reverse_deletes c
    //""Task
    //    We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
    //    then check if the result string is palindrome.
    //    A string is called palindrome if it reads the same backward as forward.
    //    You should return a tuple containing the result string and True/False for the check.
    //    Example
    //    For s = ""abcde"", c = ""ae"", the result should be ('bcd',False)
    //    For s = ""abcdef"", c = ""b""  the result should be ('acdef',False)
    //    For s = ""abcdedcba"", c = ""ab"", the result should be ('cdedc',True)
    //    ""
    s := (join __evy_listcomp_ := []
    for char := s:
    if !(has c char)
     """")
    return [s s[0:] == s ]

end
func checkcandidate
    assert .candidate (""abcde"" ""ae"") == [""bcd"" false ]
    assert .candidate (""abcdef"" ""b"") == [""acdef"" false ]
    assert .candidate (""abcdedcba"" ""ab"") == [""cdedc"" true ]
    assert .candidate (""dwik"" ""w"") == [""dik"" false ]
    assert .candidate (""a"" ""a"") == ["""" true ]
    assert .candidate (""abcdedcba"" """") == [""abcdedcba"" true ]
    assert .candidate (""abcdedcba"" ""v"") == [""abcdedcba"" true ]
    assert .candidate (""vabba"" ""v"") == [""abba"" true ]
    assert .candidate (""mamma"" ""mia"") == ["""" true ]

end
.check (reverse_delete)",
HumanEval_81_convert.evy,"func numerical_letter_gradegrades
    //""It is the last week of the semester and the teacher has to give the grades
    //    to students. The teacher has been making her own algorithm for grading.
    //    The only problem is, she has lost the code she used for grading.
    //    She has given you a list of GPAs for some students and you have to write 
    //    a function that can output a list of letter grades using the following table:
    //             GPA       |    Letter grade
    //              4.0                A+
    //            > 3.7                A 
    //            > 3.3                A- 
    //            > 3.0                B+
    //            > 2.7                B 
    //            > 2.3                B-
    //            > 2.0                C+
    //            > 1.7                C
    //            > 1.3                C-
    //            > 1.0                D+ 
    //            > 0.7                D 
    //            > 0.0                D-
    //              0.0                E
    //    
    //
    //    Example:
    //    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']
    //    ""
    letter_grade := []
        if gpa == 4.0
            letter_grade = letter_grade + [""A+""]
        else if gpa > 3.7
            letter_grade = letter_grade + [""A""]
        else
            if gpa > 3.7
                letter_grade = letter_grade + [""A""]
            else if gpa > 3.3
                letter_grade = letter_grade + [""A-""]
            else
                if gpa > 3.3
                    letter_grade = letter_grade + [""A-""]
                else if gpa > 3.0
                    letter_grade = letter_grade + [""B+""]
                else
                    if gpa > 3.0
                        letter_grade = letter_grade + [""B+""]
                    else if gpa > 2.7
                        letter_grade = letter_grade + [""B""]
                    else
                        if gpa > 2.7
                            letter_grade = letter_grade + [""B""]
                        else if gpa > 2.3
                            letter_grade = letter_grade + [""B-""]
                        else
                            if gpa > 2.3
                                letter_grade = letter_grade + [""B-""]
                            else if gpa > 2.0
                                letter_grade = letter_grade + [""C+""]
                            else
                                if gpa > 2.0
                                    letter_grade = letter_grade + [""C+""]
                                else if gpa > 1.7
                                    letter_grade = letter_grade + [""C""]
                                else
                                    if gpa > 1.7
                                        letter_grade = letter_grade + [""C""]
                                    else if gpa > 1.3
                                        letter_grade = letter_grade + [""C-""]
                                    else
                                        if gpa > 1.3
                                            letter_grade = letter_grade + [""C-""]
                                        else if gpa > 1.0
                                            letter_grade = letter_grade + [""D+""]
                                        else
                                            if gpa > 1.0
                                                letter_grade = letter_grade + [""D+""]
                                            else if gpa > 0.7
                                                letter_grade = letter_grade + [""D""]
                                            else
                                                if gpa > 0.7
                                                    letter_grade = letter_grade + [""D""]
                                                else if gpa > 0.0
                                                    letter_grade = letter_grade + [""D-""]
                                                else
                                                    if gpa > 0.0
                                                        letter_grade = letter_grade + [""D-""]
                                                        letter_grade = letter_grade + [""E""]
                                                    else
                                                        letter_grade = letter_grade + [""E""]
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    return letter_grade

end
func checkcandidate
    assert .candidate ([4.0 3 1.7 2 3.5 ]) == [""A+"" ""B"" ""C-"" ""C"" ""A-"" ]
    assert .candidate ([1.2 ]) == [""D+"" ]
    assert .candidate ([0.5 ]) == [""D-"" ]
    assert .candidate ([0.0 ]) == [""E"" ]
    assert .candidate ([1 0.3 1.5 2.8 3.3 ]) == [""D"" ""D-"" ""C-"" ""B"" ""B+"" ]
    assert .candidate ([0 0.7 ]) == [""E"" ""D-"" ]
    assert true

end
.check (numerical_letter_grade)",
HumanEval_120_convert.evy,"func maximumarr k
    //""
    //    Given an array arr of integers and a positive integer k, return a sorted list 
    //    of length k with the maximum k numbers in arr.
    //
    //    Example 1:
    //
    //        Input: arr = [-3, -4, 5], k = 3
    //        Output: [-4, -3, 5]
    //
    //    Example 2:
    //
    //        Input: arr = [4, -4, 4], k = 2
    //        Output: [4, 4]
    //
    //    Example 3:
    //
    //        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1
    //        Output: [2]
    //
    //    Note:
    //        1. The length of the array will be in the range of [1, 1000].
    //        2. The elements in the array will be in the range of [-1000, 1000].
    //        3. 0 <= k <= len(arr)
    //    ""
    if k == 0
        return []
    end
    arr.sort ()
    ans := arr[-k:]
    return ans

end
func checkcandidate
    assert .candidate ([-3 -4 5 ] 3) == [-4 -3 5 ]
    assert .candidate ([4 -4 4 ] 2) == [4 4 ]
    assert .candidate ([-3 2 1 2 -1 -2 1 ] 1) == [2 ]
    assert .candidate ([123 -123 20 0 1 2 -3 ] 3) == [2 20 123 ]
    assert .candidate ([-123 20 0 1 2 -3 ] 4) == [0 1 2 20 ]
    assert .candidate ([5 15 0 3 -13 -8 0 ] 7) == [-13 -8 0 0 3 5 15 ]
    assert .candidate ([-1 0 2 5 3 -10 ] 2) == [3 5 ]
    assert .candidate ([1 0 5 -7 ] 1) == [5 ]
    assert .candidate ([4 -4 ] 2) == [-4 4 ]
    assert .candidate ([-10 10 ] 2) == [-10 10 ]
    assert .candidate ([1 2 3 -23 243 -400 0 ] 0) == []

end
.check (maximum)",
HumanEval_22_convert.evy,"func filter_integers:[]int values:[]Any
    //"" Filter given list of any python values only for integers
    //    >>> filter_integers(['a', 3.14, 5])
    //    [5]
    //    >>> filter_integers([1, 2, 3, 'abc', {}, []])
    //    [1, 2, 3]
    //    ""
    return __evy_listcomp_ := []
    for x := values:
    if .isinstance (x int)

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate ([]) == []
    assert .candidate ([4 {} [] 23.2 9 ""adasd"" ]) == [4 9 ]
    assert .candidate ([3 ""c"" 3 3 ""a"" ""b"" ]) == [3 3 3 ]

end
.check (filter_integers)",
HumanEval_52_convert.evy,"func below_thresholdl:list t:int
    //""Return True if all numbers in the list l are below threshold t.
    //    >>> below_threshold([1, 2, 4, 10], 100)
    //    True
    //    >>> below_threshold([1, 20, 4, 10], 5)
    //    False
    //    ""
        if e >= t
            return false
        end
    end
    return true

end
METADATA := {}
func checkcandidate
    assert .candidate ([1 2 4 10 ] 100)
    assert !.candidate ([1 20 4 10 ] 5)
    assert .candidate ([1 20 4 10 ] 21)
    assert .candidate ([1 20 4 10 ] 22)
    assert .candidate ([1 8 4 10 ] 11)
    assert !.candidate ([1 8 4 10 ] 10)

end
.check (below_threshold)",
HumanEval_150_convert.evy,,
HumanEval_2_convert.evy,"func truncate_number:float number:float
    //"" Given a positive floating point number, it can be decomposed into
    //    and integer part (largest integer smaller than given number) and decimals
    //    (leftover part always smaller than 1).
    //
    //    Return the decimal part of the number.
    //    >>> truncate_number(3.5)
    //    0.5
    //    ""
    return number % 1.0

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate (3.5) == 0.5
    assert .abs (.candidate (1.33) - 0.33) < 1e-06
    assert .abs (.candidate (123.456) - 0.456) < 1e-06

end
.check (truncate_number)",
HumanEval_135_convert.evy,"func can_arrangearr
    //""Create a function which returns the largest index of an element which
    //    is not greater than or equal to the element immediately preceding it. If
    //    no such element exists then return -1. The given array will not contain
    //    duplicate values.
    //
    //    Examples:
    //    can_arrange([1,2,4,3,5]) = 3
    //    can_arrange([1,2,3]) = -1
    //    ""
    ind := -1
    i := 1
    while i < .len (arr)
        if arri < arri - 1
            ind = i
        end
        i = i + 1
    end
    return ind

end
func checkcandidate
    assert .candidate ([1 2 4 3 5 ]) == 3
    assert .candidate ([1 2 4 5 ]) == -1
    assert .candidate ([1 4 2 5 6 7 8 9 10 ]) == 2
    assert .candidate ([4 8 5 7 3 ]) == 4
    assert .candidate ([]) == -1

end
.check (can_arrange)",
HumanEval_37_convert.evy,"func sort_evenl:list
    //""This function takes a list l and returns a list l' such that
    //    l' is identical to l in the odd indicies, while its values at the even indicies are equal
    //    to the values of the even indicies of l, but sorted.
    //    >>> sort_even([1, 2, 3])
    //    [1, 2, 3]
    //    >>> sort_even([5, 6, 3, 4])
    //    [3, 6, 5, 4]
    //    ""
    evens := l[0:]
    odds := l[1:]
    evens.sort ()
    ans := []
        ans.extend ([e o ])
    end
    if .len (evens) > .len (odds)
        ans = ans + [evens-1]
    end
    return ans

end
METADATA := {}
func checkcandidate
    assert .tuple (.candidate ([1 2 3 ])) == .tuple ([1 2 3 ])
    assert .tuple (.candidate ([5 3 -5 2 -3 3 9 0 123 1 -10 ])) == .tuple ([-10 3 -5 2 -3 3 5 0 9 1 123 ])
    assert .tuple (.candidate ([5 8 -12 4 23 2 3 11 12 -10 ])) == .tuple ([-12 8 3 4 5 2 12 11 23 -10 ])

end
.check (sort_even)",
HumanEval_47_convert.evy,"func medianl:list
    //""Return median of elements in the list l.
    //    >>> median([3, 1, 2, 4, 5])
    //    3
    //    >>> median([-10, 4, 6, 1000, 10, 20])
    //    15.0
    //    ""
    l := .sorted (l)
    if .len (l) % 2 == 1
        return lNone .len (l) 2
        lNone .len (l) 2 - 1 + lNone .len (l) 2 / 2.0
    else
        return lNone .len (l) 2 - 1 + lNone .len (l) 2 / 2.0
    end

end
METADATA := {}
func checkcandidate
    assert .candidate ([3 1 2 4 5 ]) == 3
    assert .candidate ([-10 4 6 1000 10 20 ]) == 8.0
    assert .candidate ([5 ]) == 5
    assert .candidate ([6 5 ]) == 5.5
    assert .candidate ([8 1 3 9 9 2 7 ]) == 7

end
.check (median)",
HumanEval_145_convert.evy,"func order_by_pointsnums
    //""
    //    Write a function which sorts the given list of integers
    //    in ascending order according to the sum of their digits.
    //    Note: if there are several items with similar sum of their digits,
    //    order them based on their index in original list.
    //
    //    For example:
    //    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    //    >>> order_by_points([]) == []
    //    ""
    func digits_sumn
        neg := 1
        if n < 0
            [n neg ] := [-1 * n -1 ]
        end
        n := __evy_listcomp_ := []
        for i := .str (n):
        n0 := n0 * neg
        return .sum (n)
    
    end
    return .sorted (nums)

end
func checkcandidate
    assert .candidate ([1 11 -1 -11 -12 ]) == [-1 -11 1 -12 11 ]
    assert .candidate ([1234 423 463 145 2 423 423 53 6 37 3457 3 56 0 46 ]) == [0 2 3 6 53 423 423 423 1234 145 37 46 56 463 3457 ]
    assert .candidate ([]) == []
    assert .candidate ([1 -11 -32 43 54 -98 2 -3 ]) == [-3 -32 -98 -11 1 2 43 54 ]
    assert .candidate ([1 2 3 4 5 6 7 8 9 10 11 ]) == [1 10 2 11 3 4 5 6 7 8 9 ]
    assert .candidate ([0 6 6 -76 -21 23 4 ]) == [-76 -21 0 4 23 6 6 ]
    assert true

end
.check (order_by_points)",
HumanEval_19_convert.evy,"func sort_numbers:string numbers:string
    //"" Input is a space-delimited string of numberals from 'zero' to 'nine'.
    //    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
    //    Return the string with numbers sorted from smallest to largest
    //    >>> sort_numbers('three one five')
    //    'one three five'
    //    ""
    value_map := {""zero"":0 ""one"":1 ""two"":2 ""three"":3 ""four"":4 ""five"":5 ""six"":6 ""seven"":7 ""eight"":8 ""nine"":9}
    return (join .sorted (__evy_listcomp_ := []
    for x := numbers.split ("" ""):
    if x
    ) "" "")

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate ("""") == """"
    assert .candidate (""three"") == ""three""
    assert .candidate (""three five nine"") == ""three five nine""
    assert .candidate (""five zero four seven nine eight"") == ""zero four five seven eight nine""
    assert .candidate (""six five four three two one zero"") == ""zero one two three four five six""

end
.check (sort_numbers)",
HumanEval_69_convert.evy,"func searchlst
    //""
    //    You are given a non-empty list of positive integers. Return the greatest integer that is greater than 
    //    zero, and has a frequency greater than or equal to the value of the integer itself. 
    //    The frequency of an integer is the number of times it appears in the list.
    //    If no such a value exist, return -1.
    //    Examples:
    //        search([4, 1, 2, 2, 3, 1]) == 2
    //        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3
    //        search([5, 5, 4, 4, 4]) == -1
    //    ""
    frq := [0 ] * .max (lst) + 1
        frqi = frqi + 1
    end
    ans := -1
        if frqi >= i
            ans = i
        end
    end
    return ans

end
func checkcandidate
    assert .candidate ([5 5 5 5 1 ]) == 1
    assert .candidate ([4 1 4 1 4 4 ]) == 4
    assert .candidate ([3 3 ]) == -1
    assert .candidate ([8 8 8 8 8 8 8 8 ]) == 8
    assert .candidate ([2 3 3 2 2 ]) == 2
    assert .candidate ([2 7 8 8 4 8 7 3 9 6 5 10 4 3 6 7 1 7 4 10 8 1 ]) == 1
    assert .candidate ([3 2 8 2 ]) == 2
    assert .candidate ([6 7 1 8 8 10 5 8 5 3 10 ]) == 1
    assert .candidate ([8 8 3 6 5 6 4 ]) == -1
    assert .candidate ([6 9 6 7 1 4 7 1 8 8 9 8 10 10 8 4 10 4 10 1 2 9 5 7 9 ]) == 1
    assert .candidate ([1 9 10 1 3 ]) == 1
    assert .candidate ([6 9 7 5 8 7 5 3 7 5 10 10 3 6 10 2 8 6 5 4 9 5 3 10 ]) == 5
    assert .candidate ([1 ]) == 1
    assert .candidate ([8 8 10 6 4 3 5 8 2 4 2 8 4 6 10 4 2 1 10 2 1 1 5 ]) == 4
    assert .candidate ([2 10 4 8 2 10 5 1 2 9 5 5 6 3 8 6 4 10 ]) == 2
    assert .candidate ([1 6 10 1 6 9 10 8 6 8 7 3 ]) == 1
    assert .candidate ([9 2 4 1 5 1 5 2 5 7 7 7 3 10 1 5 4 2 8 4 1 9 10 7 10 2 8 10 9 4 ]) == 4
    assert .candidate ([2 6 4 2 8 7 5 6 4 10 4 6 3 7 8 8 3 1 4 2 2 10 7 ]) == 4
    assert .candidate ([9 8 6 10 2 6 10 2 7 8 10 3 8 2 6 2 3 1 ]) == 2
    assert .candidate ([5 5 3 9 5 6 3 2 8 5 6 10 10 6 8 4 10 7 7 10 8 ]) == -1
    assert .candidate ([10 ]) == -1
    assert .candidate ([9 7 7 2 4 7 2 10 9 7 5 7 2 ]) == 2
    assert .candidate ([5 4 10 2 1 1 10 3 6 1 8 ]) == 1
    assert .candidate ([7 9 9 9 3 4 1 5 9 1 2 1 1 10 7 5 6 7 6 7 7 6 ]) == 1
    assert .candidate ([3 10 10 9 2 ]) == -1

end
.check (search)",
HumanEval_94_convert.evy,,
HumanEval_88_convert.evy,,
HumanEval_75_convert.evy,,
HumanEval_107_convert.evy,"func even_odd_palindromen
    //""
    //    Given a positive integer n, return a tuple that has the number of even and odd
    //    integer palindromes that fall within the range(1, n), inclusive.
    //
    //    Example 1:
    //
    //        Input: 3
    //        Output: (1, 2)
    //        Explanation:
    //        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
    //
    //    Example 2:
    //
    //        Input: 12
    //        Output: (4, 6)
    //        Explanation:
    //        Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
    //
    //    Note:
    //        1. 1 <= n <= 10^3
    //        2. returned tuple has the number of even and odd integer palindromes respectively.
    //    ""
    func is_palindromen
        return .str (n) == .str (n)[0:]
    
    end
    even_palindrome_count := 0
    odd_palindrome_count := 0
        if i % 2 == 1 .is_palindrome (i) and
            odd_palindrome_count = odd_palindrome_count + 1
        else if i % 2 == 0 .is_palindrome (i) and
            even_palindrome_count = even_palindrome_count + 1
        else
            if i % 2 == 0 .is_palindrome (i) and
                even_palindrome_count = even_palindrome_count + 1
            end
        end
    end
    return [even_palindrome_count odd_palindrome_count ]

end
func checkcandidate
    assert .candidate (123) == [8 13 ]
    assert .candidate (12) == [4 6 ]
    assert .candidate (3) == [1 2 ]
    assert .candidate (63) == [6 8 ]
    assert .candidate (25) == [5 6 ]
    assert .candidate (19) == [4 6 ]
    assert .candidate (9) == [4 5 ]
    assert .candidate (1) == [0 1 ]

end
.check (even_odd_palindrome)",
HumanEval_159_convert.evy,"func eatnumber need remaining
    //""
    //    You're a hungry rabbit, and you already have eaten a certain number of carrots,
    //    but now you need to eat more carrots to complete the day's meals.
    //    you should return an array of [ total number of eaten carrots after your meals,
    //                                    the number of carrots left after your meals ]
    //    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.
    //    
    //    Example:
    //    * eat(5, 6, 10) -> [11, 4]
    //    * eat(4, 8, 9) -> [12, 1]
    //    * eat(1, 10, 10) -> [11, 0]
    //    * eat(2, 11, 5) -> [7, 0]
    //    
    //    Variables:
    //    @number : integer
    //        the number of carrots that you have eaten.
    //    @need : integer
    //        the number of carrots that you need to eat.
    //    @remaining : integer
    //        the number of remaining carrots thet exist in stock
    //    
    //    Constrain:
    //    * 0 <= number <= 1000
    //    * 0 <= need <= 1000
    //    * 0 <= remaining <= 1000
    //
    //    Have fun :)
    //    ""
    if need <= remaining
        return [number + need remaining - need ]
        [number + remaining 0 ]
    else
        return [number + remaining 0 ]
    end

end
func checkcandidate
    assert true
    assert .candidate (5 6 10) == [11 4 ]
    assert .candidate (4 8 9) == [12 1 ]
    assert .candidate (1 10 10) == [11 0 ]
    assert .candidate (2 11 5) == [7 0 ]
    assert true
    assert .candidate (4 5 7) == [9 2 ]
    assert .candidate (4 5 1) == [5 0 ]

end
.check (eat)",
HumanEval_129_convert.evy,"func minPathgrid k
    //""
    //    Given a grid with N rows and N columns (N >= 2) and a positive integer k, 
    //    each cell of the grid contains a value. Every integer in the range [1, N * N]
    //    inclusive appears exactly once on the cells of the grid.
    //
    //    You have to find the minimum path of length k in the grid. You can start
    //    from any cell, and in each step you can move to any of the neighbor cells,
    //    in other words, you can go to cells which share an edge with you current
    //    cell.
    //    Please note that a path of length k means visiting exactly k cells (not
    //    necessarily distinct).
    //    You CANNOT go off the grid.
    //    A path A (of length k) is considered less than a path B (of length k) if
    //    after making the ordered lists of the values on the cells that A and B go
    //    through (let's call them lst_A and lst_B), lst_A is lexicographically less
    //    than lst_B, in other words, there exist an integer index i (1 <= i <= k)
    //    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have
    //    lst_A[j] = lst_B[j].
    //    It is guaranteed that the answer is unique.
    //    Return an ordered list of the values on the cells that the minimum path go through.
    //
    //    Examples:
    //
    //        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3
    //        Output: [1, 2, 1]
    //
    //        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1
    //        Output: [1]
    //    ""
    n := .len (grid)
    val := n * n + 1
            if gridij == 1
                temp := []
                if i != 0
                    temp = temp + [gridi - 1j]
                end
                if j != 0
                    temp = temp + [gridij - 1]
                end
                if i != n - 1
                    temp = temp + [gridi + 1j]
                end
                if j != n - 1
                    temp = temp + [gridij + 1]
                end
                val = .min (temp)
            end
        end
    end
    ans := []
        if i % 2 == 0
            ans = ans + [1]
            ans = ans + [val]
        else
            ans = ans + [val]
        end
    end
    return ans

end
func checkcandidate
    print
    assert .candidate ([[1 2 3 ] [4 5 6 ] [7 8 9 ] ] 3) == [1 2 1 ]
    assert .candidate ([[5 9 3 ] [4 1 6 ] [7 8 2 ] ] 1) == [1 ]
    assert .candidate ([[1 2 3 4 ] [5 6 7 8 ] [9 10 11 12 ] [13 14 15 16 ] ] 4) == [1 2 1 2 ]
    assert .candidate ([[6 4 13 10 ] [5 7 12 1 ] [3 16 11 15 ] [8 14 9 2 ] ] 7) == [1 10 1 10 1 10 1 ]
    assert .candidate ([[8 14 9 2 ] [6 4 13 15 ] [5 7 1 12 ] [3 10 11 16 ] ] 5) == [1 7 1 7 1 ]
    assert .candidate ([[11 8 7 2 ] [5 16 14 4 ] [9 3 15 6 ] [12 13 10 1 ] ] 9) == [1 6 1 6 1 6 1 6 1 ]
    assert .candidate ([[12 13 10 1 ] [9 3 15 6 ] [5 16 14 4 ] [11 8 7 2 ] ] 12) == [1 6 1 6 1 6 1 6 1 6 1 6 ]
    assert .candidate ([[2 7 4 ] [3 1 5 ] [6 8 9 ] ] 8) == [1 3 1 3 1 3 1 3 ]
    assert .candidate ([[6 1 5 ] [3 8 9 ] [2 7 4 ] ] 8) == [1 5 1 5 1 5 1 5 ]
    assert .candidate ([[1 2 ] [3 4 ] ] 10) == [1 2 1 2 1 2 1 2 1 2 ]
    assert .candidate ([[1 3 ] [3 2 ] ] 10) == [1 3 1 3 1 3 1 3 1 3 ]

end
.check (minPath)",
HumanEval_58_convert.evy,"func commonl1:list l2:list
    //""Return sorted unique common elements for two lists.
    //    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])
    //    [1, 5, 653]
    //    >>> common([5, 3, 2, 8], [3, 2])
    //    [2, 3]
    //
    //    ""
    ret := .set ()
            if e1 == e2
                ret.add (e1)
            end
        end
    end
    return .sorted (.list (ret))

end
METADATA := {}
func checkcandidate
    assert .candidate ([1 4 3 34 653 2 5 ] [5 7 1 5 9 653 121 ]) == [1 5 653 ]
    assert .candidate ([5 3 2 8 ] [3 2 ]) == [2 3 ]
    assert .candidate ([4 3 2 8 ] [3 2 4 ]) == [2 3 4 ]
    assert .candidate ([4 3 2 8 ] []) == []

end
.check (common)",
HumanEval_28_convert.evy,"func concatenate:string strings:[]string
    //"" Concatenate list of strings into a single string
    //    >>> concatenate([])
    //    ''
    //    >>> concatenate(['a', 'b', 'c'])
    //    'abc'
    //    ""
    return (join strings """")

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate ([]) == """"
    assert .candidate ([""x"" ""y"" ""z"" ]) == ""xyz""
    assert .candidate ([""x"" ""y"" ""z"" ""w"" ""k"" ]) == ""xyzwk""

end
.check (concatenate)",
HumanEval_76_convert.evy,"func is_simple_powerx n
    //""Your task is to write a function that returns true if a number x is a simple
    //    power of n and false in other cases.
    //    x is a simple power of n if n**int=x
    //    For example:
    //    is_simple_power(1, 4) => true
    //    is_simple_power(2, 2) => true
    //    is_simple_power(8, 2) => true
    //    is_simple_power(3, 2) => false
    //    is_simple_power(3, 1) => false
    //    is_simple_power(5, 3) => false
    //    ""
    if n == 1
        return x == 1
    end
    power := 1
    while power < x
        power = power * n
    end
    return power == x

end
func checkcandidate
    assert .candidate (16 2) == true
    assert .candidate (143214 16) == false
    assert .candidate (4 2) == true
    assert .candidate (9 3) == true
    assert .candidate (16 4) == true
    assert .candidate (24 2) == false
    assert .candidate (128 4) == false
    assert .candidate (12 6) == false
    assert .candidate (1 1) == true
    assert .candidate (1 12) == true

end
.check (is_simple_power)",
HumanEval_104_convert.evy,,
HumanEval_118_convert.evy,"func get_closest_vowelword
    //""You are given a word. Your task is to find the closest vowel that stands between 
    //    two consonants from the right side of the word (case sensitive).
    //    
    //    Vowels in the beginning and ending doesn't count. Return empty string if you didn't
    //    find any vowel met the above condition. 
    //
    //    You may assume that the given string contains English letter only.
    //
    //    Example:
    //    get_closest_vowel(""yogurt"") ==> ""u""
    //    get_closest_vowel(""FULL"") ==> ""U""
    //    get_closest_vowel(""quick"") ==> """"
    //    get_closest_vowel(""ab"") ==> """"
    //    ""
    if .len (word) < 3
        return """"
    end
    vowels := {a :true e :true i :true o :true u :true A :true E :true O :true U :true I :true }
        if (has vowels wordi)
            if !(has vowels wordi + 1) !(has vowels wordi - 1) and
                return wordi
            end
        end
    end
    return """"

end
func checkcandidate
    assert .candidate (""yogurt"") == ""u""
    assert .candidate (""full"") == ""u""
    assert .candidate (""easy"") == """"
    assert .candidate (""eAsy"") == """"
    assert .candidate (""ali"") == """"
    assert .candidate (""bad"") == ""a""
    assert .candidate (""most"") == ""o""
    assert .candidate (""ab"") == """"
    assert .candidate (""ba"") == """"
    assert .candidate (""quick"") == """"
    assert .candidate (""anime"") == ""i""
    assert .candidate (""Asia"") == """"
    assert .candidate (""Above"") == ""o""
    assert true

end
.check (get_closest_vowel)",
HumanEval_97_convert.evy,"func multiplya b
    //""Complete the function that takes two integers and returns 
    //    the product of their unit digits.
    //    Assume the input is always valid.
    //    Examples:
    //    multiply(148, 412) should return 16.
    //    multiply(19, 28) should return 72.
    //    multiply(2020, 1851) should return 0.
    //    multiply(14,-15) should return 20.
    //    ""
    return .abs (a % 10) * .abs (b % 10)

end
func checkcandidate
    assert .candidate (148 412) == 16
    assert .candidate (19 28) == 72
    assert .candidate (2020 1851) == 0
    assert .candidate (14 -15) == 20
    assert .candidate (76 67) == 42
    assert .candidate (17 27) == 49
    assert .candidate (0 1) == 0
    assert .candidate (0 0) == 0

end
.check (multiply)",
HumanEval_1_convert.evy,"func separate_paren_groups:[]string paren_string:string
    //"" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
    //    separate those group into separate strings and return the list of those.
    //    Separate groups are balanced (each open brace is properly closed) and not nested within each other
    //    Ignore any spaces in the input string.
    //    >>> separate_paren_groups('( ) (( )) (( )( ))')
    //    ['()', '(())', '(()())']
    //    ""
    result := []
    current_string := []
    current_depth := 0
    for c := range paren_string
        if c == ""(""
            current_depth = current_depth + 1
            current_string = current_string + [c]
        else if c == "")""
            current_depth = current_depth - 1
            current_string = current_string + [c]
            if current_depth == 0
                result = result + [(join current_string """")]
                current_string = []
            end
        else
            if c == "")""
                current_depth = current_depth - 1
                current_string = current_string + [c]
                if current_depth == 0
                    result = result + [(join current_string """")]
                    current_string = []
                end
            end
        end
    end
    return result

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate (""(()()) ((())) () ((())()())"") == [""(()())"" ""((()))"" ""()"" ""((())()())"" ]
    assert .candidate (""() (()) ((())) (((())))"") == [""()"" ""(())"" ""((()))"" ""(((())))"" ]
    assert .candidate (""(()(())((())))"") == [""(()(())((())))"" ]
    assert .candidate (""( ) (( )) (( )( ))"") == [""()"" ""(())"" ""(()())"" ]

end
.check (separate_paren_groups)",
HumanEval_136_convert.evy,,
HumanEval_34_convert.evy,"func uniquel:list
    //""Return sorted unique elements in a list
    //    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])
    //    [0, 2, 3, 5, 9, 123]
    //    ""
    return .sorted (.list (.set (l)))

end
METADATA := {}
func checkcandidate
    assert .candidate ([5 3 5 2 3 3 9 0 123 ]) == [0 2 3 5 9 123 ]

end
.check (unique)",
HumanEval_44_convert.evy,"func change_basex:int base:int
    //""Change numerical base of input number x to base.
    //    return string representation after the conversion.
    //    base numbers are less than 10.
    //    >>> change_base(8, 3)
    //    '22'
    //    >>> change_base(8, 2)
    //    '1000'
    //    >>> change_base(7, 2)
    //    '111'
    //    ""
    ret := """"
    while x > 0
        ret = .str (x % base) + ret
        x = x None base
    end
    return ret

end
METADATA := {}
func checkcandidate
    assert .candidate (8 3) == ""22""
    assert .candidate (9 3) == ""100""
    assert .candidate (234 2) == ""11101010""
    assert .candidate (16 2) == ""10000""
    assert .candidate (8 2) == ""1000""
    assert .candidate (7 2) == ""111""
        assert .candidate (x x + 1) == .str (x)
    end

end
.check (change_base)",
HumanEval_146_convert.evy,"func specialFilternums
    //""Write a function that takes an array of numbers as input and returns 
    //    the number of elements in the array that are greater than 10 and both 
    //    first and last digits of a number are odd (1, 3, 5, 7, 9).
    //    For example:
    //    specialFilter([15, -73, 14, -15]) => 1 
    //    specialFilter([33, -2, -3, 45, 21, 109]) => 2
    //    ""
    count := 0
        if num_ > 10
            odd_digits := [1 3 5 7 9 ]
            number_as_string := .str (num_)
            if (has odd_digits .int (number_as_string0)) (has odd_digits .int (number_as_string-1)) and
                count = count + 1
            end
        end
    end
    return count

end
func checkcandidate
    assert .candidate ([5 -2 1 -5 ]) == 0
    assert .candidate ([15 -73 14 -15 ]) == 1
    assert .candidate ([33 -2 -3 45 21 109 ]) == 2
    assert .candidate ([43 -12 93 125 121 109 ]) == 4
    assert .candidate ([71 -2 -33 75 21 19 ]) == 3
    assert .candidate ([1 ]) == 0
    assert .candidate ([]) == 0

end
.check (specialFilter)",
HumanEval_123_convert.evy,"func get_odd_collatzn
    //""
    //    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.
    //
    //    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined
    //    as follows: start with any positive integer n. Then each term is obtained from the 
    //    previous term as follows: if the previous term is even, the next term is one half of 
    //    the previous term. If the previous term is odd, the next term is 3 times the previous
    //    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.
    //
    //    Note: 
    //        1. Collatz(1) is [1].
    //        2. returned list sorted in increasing order.
    //
    //    For example:
    //    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.
    //    ""
    if n % 2 == 0
        odd_collatz := []
        [n ]
    else
        odd_collatz = [n ]
    end
    while n > 1
        if n % 2 == 0
            n := n / 2
            n * 3 + 1
        else
            n = n * 3 + 1
        end
        if n % 2 == 1
            odd_collatz = odd_collatz + [.int (n)]
        end
    end
    return .sorted (odd_collatz)

end
func checkcandidate
    assert .candidate (14) == [1 5 7 11 13 17 ]
    assert .candidate (5) == [1 5 ]
    assert .candidate (12) == [1 3 5 ]
    assert .candidate (1) == [1 ]

end
.check (get_odd_collatz)",
HumanEval_21_convert.evy,"func rescale_to_unit:[]float numbers:[]float
    //"" Given list of numbers (of at least two elements), apply a linear transform to that list,
    //    such that the smallest number will become 0 and the largest will become 1
    //    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
    //    [0.0, 0.25, 0.5, 0.75, 1.0]
    //    ""
    min_number := .min (numbers)
    max_number := .max (numbers)
    return __evy_listcomp_ := []
    for x := numbers:

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate ([2.0 49.9 ]) == [0.0 1.0 ]
    assert .candidate ([100.0 49.9 ]) == [1.0 0.0 ]
    assert .candidate ([1.0 2.0 3.0 4.0 5.0 ]) == [0.0 0.25 0.5 0.75 1.0 ]
    assert .candidate ([2.0 1.0 5.0 3.0 4.0 ]) == [0.25 0.0 1.0 0.5 0.75 ]
    assert .candidate ([12.0 11.0 15.0 13.0 14.0 ]) == [0.25 0.0 1.0 0.5 0.75 ]

end
.check (rescale_to_unit)",
HumanEval_51_convert.evy,"func remove_vowelstext
    //""
    //    remove_vowels is a function that takes string and returns string without vowels.
    //    >>> remove_vowels('')
    //    ''
    //    >>> remove_vowels(""abcdef
    //ghijklm"")
    //    'bcdf
    //ghjklm'
    //    >>> remove_vowels('abcdef')
    //    'bcdf'
    //    >>> remove_vowels('aaaaa')
    //    ''
    //    >>> remove_vowels('aaBAA')
    //    'B'
    //    >>> remove_vowels('zbcd')
    //    'zbcd'
    //    ""
    return (join __evy_listcomp_ := []
    for s := text:
    if !(has [""a"" ""e"" ""i"" ""o"" ""u"" ] s.lower ())
     """")

end
METADATA := {}
func checkcandidate
    assert .candidate ("""") == """"
    assert .candidate (""abcdef
    ghijklm"") == ""bcdf
    ghjklm""
    assert .candidate (""fedcba"") == ""fdcb""
    assert .candidate (""eeeee"") == """"
    assert .candidate (""acBAA"") == ""cB""
    assert .candidate (""EcBOO"") == ""cB""
    assert .candidate (""ybcd"") == ""ybcd""

end
.check (remove_vowels)",
HumanEval_153_convert.evy,"func Strongest_Extensionclass_name extensions
    //""You will be given the name of a class (a string) and a list of extensions.
    //    The extensions are to be used to load additional classes to the class. The
    //    strength of the extension is as follows: Let CAP be the number of the uppercase
    //    letters in the extension's name, and let SM be the number of lowercase letters 
    //    in the extension's name, the strength is given by the fraction CAP - SM. 
    //    You should find the strongest extension and return a string in this 
    //    format: ClassName.StrongestExtensionName.
    //    If there are two or more extensions with the same strength, you should
    //    choose the one that comes first in the list.
    //    For example, if you are given ""Slices"" as the class and a list of the
    //    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
    //    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
    //    (its strength is -1).
    //    Example:
    //    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'
    //    ""
    strong := extensions0
    my_val := .len (__evy_listcomp_ := []
    for x := extensions0:
    if x.isalpha () x.isupper () and
    ) - .len (__evy_listcomp_ := []
    for x := extensions0:
    if x.isalpha () x.islower () and
    )
        val := .len (__evy_listcomp_ := []
        for x := s:
        if x.isalpha () x.isupper () and
        ) - .len (__evy_listcomp_ := []
        for x := s:
        if x.isalpha () x.islower () and
        )
        if val > my_val
            strong = s
            my_val = val
        end
    end
    ans := class_name + ""."" + strong
    return ans

end
func checkcandidate
    assert .candidate (""Watashi"" [""tEN"" ""niNE"" ""eIGHt8OKe"" ]) == ""Watashi.eIGHt8OKe""
    assert .candidate (""Boku123"" [""nani"" ""NazeDa"" ""YEs.WeCaNe"" ""32145tggg"" ]) == ""Boku123.YEs.WeCaNe""
    assert .candidate (""__YESIMHERE"" [""t"" ""eMptY"" ""nothing"" ""zeR00"" ""NuLl__"" ""123NoooneB321"" ]) == ""__YESIMHERE.NuLl__""
    assert .candidate (""K"" [""Ta"" ""TAR"" ""t234An"" ""cosSo"" ]) == ""K.TAR""
    assert .candidate (""__HAHA"" [""Tab"" ""123"" ""781345"" ""-_-"" ]) == ""__HAHA.123""
    assert .candidate (""YameRore"" [""HhAas"" ""okIWILL123"" ""WorkOut"" ""Fails"" ""-_-"" ]) == ""YameRore.okIWILL123""
    assert .candidate (""finNNalLLly"" [""Die"" ""NowW"" ""Wow"" ""WoW"" ]) == ""finNNalLLly.WoW""
    assert .candidate (""_"" [""Bb"" ""91245"" ]) == ""_.Bb""
    assert .candidate (""Sp"" [""671235"" ""Bb"" ]) == ""Sp.671235""

end
.check (Strongest_Extension)",
HumanEval_82_convert.evy,"func prime_lengthstring
    //""Write a function that takes a string and returns True if the string
    //    length is a prime number or False otherwise
    //    Examples
    //    prime_length('Hello') == True
    //    prime_length('abcdcba') == True
    //    prime_length('kittens') == True
    //    prime_length('orange') == False
    //    ""
    l := .len (string_)
    if l == 0 l == 1 or
        return false
    end
        if l % i == 0
            return false
        end
    end
    return true

end
func checkcandidate
    assert .candidate (""Hello"") == true
    assert .candidate (""abcdcba"") == true
    assert .candidate (""kittens"") == true
    assert .candidate (""orange"") == false
    assert .candidate (""wow"") == true
    assert .candidate (""world"") == true
    assert .candidate (""MadaM"") == true
    assert .candidate (""Wow"") == true
    assert .candidate ("""") == false
    assert .candidate (""HI"") == true
    assert .candidate (""go"") == true
    assert .candidate (""gogo"") == false
    assert .candidate (""aaaaaaaaaaaaaaa"") == false
    assert .candidate (""Madam"") == true
    assert .candidate (""M"") == false
    assert .candidate (""0"") == false

end
.check (prime_length)",
HumanEval_161_convert.evy,"func solves
    //""You are given a string s.
    //    if s[i] is a letter, reverse its case from lower to upper or vise versa, 
    //    otherwise keep it as it is.
    //    If the string contains no letters, reverse the string.
    //    The function should return the resulted string.
    //    Examples
    //    solve(""1234"") = ""4321""
    //    solve(""ab"") = ""AB""
    //    solve(""#a@C"") = ""#A@c""
    //    ""
    flg := 0
    idx := 0
    new_str := .list (s)
        if i.isalpha ()
            new_stridx := i.swapcase ()
            flg = 1
        end
        idx = idx + 1
    end
    s := """"
        s = s + i
    end
    if flg == 0
        return s[.len (s):]
    end
    return s

end
func checkcandidate
    assert .candidate (""AsDf"") == ""aSdF""
    assert .candidate (""1234"") == ""4321""
    assert .candidate (""ab"") == ""AB""
    assert .candidate (""#a@C"") == ""#A@c""
    assert .candidate (""#AsdfW^45"") == ""#aSDFw^45""
    assert .candidate (""#6@2"") == ""2@6#""
    assert .candidate (""#$a^D"") == ""#$A^d""
    assert .candidate (""#ccc"") == ""#CCC""

end
.check (solve)",
HumanEval_63_convert.evy,"func fibfibn:int
    //""The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
    //    fibfib(0) == 0
    //    fibfib(1) == 0
    //    fibfib(2) == 1
    //    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
    //    Please write a function to efficiently compute the n-th element of the fibfib number sequence.
    //    >>> fibfib(1)
    //    0
    //    >>> fibfib(5)
    //    4
    //    >>> fibfib(8)
    //    24
    //    ""
    if n == 0
        return 0
    end
    if n == 1
        return 0
    end
    if n == 2
        return 1
    end
    return .fibfib (n - 1) + .fibfib (n - 2) + .fibfib (n - 3)

end
METADATA := {}
func checkcandidate
    assert .candidate (2) == 1
    assert .candidate (1) == 0
    assert .candidate (5) == 4
    assert .candidate (8) == 24
    assert .candidate (10) == 81
    assert .candidate (12) == 274
    assert .candidate (14) == 927

end
.check (fibfib)",
HumanEval_13_convert.evy,"func greatest_common_divisor:int a:int b:int
    //"" Return a greatest common divisor of two integers a and b
    //    >>> greatest_common_divisor(3, 5)
    //    1
    //    >>> greatest_common_divisor(25, 15)
    //    5
    //    ""
    while b
        [a b ] := [b a % b ]
    end
    return a

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate (3 7) == 1
    assert .candidate (10 15) == 5
    assert .candidate (49 14) == 7
    assert .candidate (144 60) == 12

end
.check (greatest_common_divisor)",
HumanEval_111_convert.evy,"func histogramtest
    //""Given a string representing a space separated lowercase letters, return a dictionary
    //    of the letter with the most repetition and containing the corresponding count.
    //    If several letters have the same occurrence, return all of them.
    //    
    //    Example:
    //    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}
    //    histogram('a b b a') == {'a': 2, 'b': 2}
    //    histogram('a b c a b') == {'a': 2, 'b': 2}
    //    histogram('b b b b a') == {'b': 4}
    //    histogram('') == {}
    //
    //    ""
    dict1 := {}
    list1 := test.split ("" "")
    t := 0
        if list1.count (i) > t i != """" and
            t = list1.count (i)
        end
    end
    if t > 0
            if list1.count (i) == t
                dict1i := t
            end
        end
    end
    return dict1

end
func checkcandidate
    assert .candidate (""a b b a"") == {""a"":2 ""b"":2}
    assert .candidate (""a b c a b"") == {""a"":2 ""b"":2}
    assert .candidate (""a b c d g"") == {""a"":1 ""b"":1 ""c"":1 ""d"":1 ""g"":1}
    assert .candidate (""r t g"") == {""r"":1 ""t"":1 ""g"":1}
    assert .candidate (""b b b b a"") == {""b"":4}
    assert .candidate (""r t g"") == {""r"":1 ""t"":1 ""g"":1}
    assert .candidate ("""") == {}
    assert .candidate (""a"") == {""a"":1}

end
.check (histogram)",
HumanEval_8_convert.evy,"func sum_product:Tuple[int int ] numbers:[]int
    //"" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
    //    Empty sum should be equal to 0 and empty product should be equal to 1.
    //    >>> sum_product([])
    //    (0, 1)
    //    >>> sum_product([1, 2, 3, 4])
    //    (10, 24)
    //    ""
    sum_value := 0
    prod_value := 1
        sum_value = sum_value + n
        prod_value = prod_value * n
    end
    return [sum_value prod_value ]

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate ([]) == [0 1 ]
    assert .candidate ([1 1 1 ]) == [3 1 ]
    assert .candidate ([100 0 ]) == [100 0 ]
    assert .candidate ([3 5 7 ]) == [3 + 5 + 7 3 * 5 * 7 ]
    assert .candidate ([10 ]) == [10 10 ]

end
.check (sum_product)",
HumanEval_87_convert.evy,"func get_rowlst x
    //""
    //    You are given a 2 dimensional data, as a nested lists,
    //    which is similar to matrix, however, unlike matrices,
    //    each row may contain a different number of columns.
    //    Given lst, and integer x, find integers x in the list,
    //    and return list of tuples, [(x1, y1), (x2, y2) ...] such that
    //    each tuple is a coordinate - (row, columns), starting with 0.
    //    Sort coordinates initially by rows in ascending order.
    //    Also, sort coordinates of the row by columns in descending order.
    //    
    //    Examples:
    //    get_row([
    //      [1,2,3,4,5,6],
    //      [1,2,3,4,1,6],
    //      [1,2,3,4,5,1]
    //    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    //    get_row([], 1) == []
    //    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]
    //    ""
    coords := __evy_listcomp_ := []
    for i := .range (.len (lst)):
    for j := .range (.len (lsti)):
    return .sorted (.sorted (coords))

end
func checkcandidate
    assert .candidate ([[1 2 3 4 5 6 ] [1 2 3 4 1 6 ] [1 2 3 4 5 1 ] ] 1) == [[0 0 ] [1 4 ] [1 0 ] [2 5 ] [2 0 ] ]
    assert .candidate ([[1 2 3 4 5 6 ] [1 2 3 4 5 6 ] [1 2 3 4 5 6 ] [1 2 3 4 5 6 ] [1 2 3 4 5 6 ] [1 2 3 4 5 6 ] ] 2) == [[0 1 ] [1 1 ] [2 1 ] [3 1 ] [4 1 ] [5 1 ] ]
    assert .candidate ([[1 2 3 4 5 6 ] [1 2 3 4 5 6 ] [1 1 3 4 5 6 ] [1 2 1 4 5 6 ] [1 2 3 1 5 6 ] [1 2 3 4 1 6 ] [1 2 3 4 5 1 ] ] 1) == [[0 0 ] [1 0 ] [2 1 ] [2 0 ] [3 2 ] [3 0 ] [4 3 ] [4 0 ] [5 4 ] [5 0 ] [6 5 ] [6 0 ] ]
    assert .candidate ([] 1) == []
    assert .candidate ([[1 ] ] 2) == []
    assert .candidate ([[] [1 ] [1 2 3 ] ] 3) == [[2 2 ] ]
    assert true

end
.check (get_row)",
HumanEval_108_convert.evy,"func count_numsarr
    //""
    //    Write a function count_nums which takes an array of integers and returns
    //    the number of elements which has a sum of digits > 0.
    //    If a number is negative, then its first signed digit will be negative:
    //    e.g. -123 has signed digits -1, 2, and 3.
    //    >>> count_nums([]) == 0
    //    >>> count_nums([-1, 11, -11]) == 1
    //    >>> count_nums([1, 1, 2]) == 3
    //    ""
    func digits_sumn
        neg := 1
        if n < 0
            [n neg ] := [-1 * n -1 ]
        end
        n := __evy_listcomp_ := []
        for i := .str (n):
        n0 := n0 * neg
        return .sum (n)
    
    end
    return .len (.list (.filter (__lambda_3 __evy_listcomp_ := []
    for i := arr:
    )))

end
func checkcandidate
    assert .candidate ([]) == 0
    assert .candidate ([-1 -2 0 ]) == 0
    assert .candidate ([1 1 2 -2 3 4 5 ]) == 6
    assert .candidate ([1 6 9 -6 0 1 5 ]) == 5
    assert .candidate ([1 100 98 -7 1 -1 ]) == 4
    assert .candidate ([12 23 34 -45 -56 0 ]) == 5
    assert .candidate ([-0 pow 1 0 ]) == 1
    assert .candidate ([1 ]) == 1
    assert true

end
.check (count_nums)",
HumanEval_156_convert.evy,"func int_to_mini_romannumber
    //""
    //    Given a positive integer, obtain its roman numeral equivalent as a string,
    //    and return it in lowercase.
    //    Restrictions: 1 <= num <= 1000
    //
    //    Examples:
    //    >>> int_to_mini_roman(19) == 'xix'
    //    >>> int_to_mini_roman(152) == 'clii'
    //    >>> int_to_mini_roman(426) == 'cdxxvi'
    //    ""
    num_ := [1 4 5 9 10 40 50 90 100 400 500 900 1000 ]
    sym := [""I"" ""IV"" ""V"" ""IX"" ""X"" ""XL"" ""L"" ""XC"" ""C"" ""CD"" ""D"" ""CM"" ""M"" ]
    i := 12
    res := """"
    while number
        div := None number num_i
        number = number % num_i
        while div
            res = res + symi
            div = div - 1
        end
        i = i - 1
    end
    return res.lower ()

end
func checkcandidate
    assert .candidate (19) == ""xix""
    assert .candidate (152) == ""clii""
    assert .candidate (251) == ""ccli""
    assert .candidate (426) == ""cdxxvi""
    assert .candidate (500) == ""d""
    assert .candidate (1) == ""i""
    assert .candidate (4) == ""iv""
    assert .candidate (43) == ""xliii""
    assert .candidate (90) == ""xc""
    assert .candidate (94) == ""xciv""
    assert .candidate (532) == ""dxxxii""
    assert .candidate (900) == ""cm""
    assert .candidate (994) == ""cmxciv""
    assert .candidate (1000) == ""m""
    assert true

end
.check (int_to_mini_roman)",
HumanEval_54_convert.evy,"func same_charss0:string s1:string
    //""
    //    Check if two words have the same characters.
    //    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
    //    True
    //    >>> same_chars('abcd', 'dddddddabc')
    //    True
    //    >>> same_chars('dddddddabc', 'abcd')
    //    True
    //    >>> same_chars('eabcd', 'dddddddabc')
    //    False
    //    >>> same_chars('abcd', 'dddddddabce')
    //    False
    //    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
    //    False
    //    ""
    return .set (s0) == .set (s1)

end
METADATA := {}
func checkcandidate
    assert .candidate (""eabcdzzzz"" ""dddzzzzzzzddeddabc"") == true
    assert .candidate (""abcd"" ""dddddddabc"") == true
    assert .candidate (""dddddddabc"" ""abcd"") == true
    assert .candidate (""eabcd"" ""dddddddabc"") == false
    assert .candidate (""abcd"" ""dddddddabcf"") == false
    assert .candidate (""eabcdzzzz"" ""dddzzzzzzzddddabc"") == false
    assert .candidate (""aabb"" ""aaccc"") == false

end
.check (same_chars)",
HumanEval_24_convert.evy,"func largest_divisor:int n:int
    //"" For a given number n, find the largest number that divides n evenly, smaller than n
    //    >>> largest_divisor(15)
    //    5
    //    ""
        if n % i == 0
            return i
        end
    end

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate (3) == 1
    assert .candidate (7) == 1
    assert .candidate (10) == 5
    assert .candidate (100) == 50
    assert .candidate (49) == 7

end
.check (largest_divisor)",
HumanEval_126_convert.evy,,
HumanEval_38_convert.evy,,
HumanEval_48_convert.evy,"func is_palindrometext:string
    //""
    //    Checks if given string is a palindrome
    //    >>> is_palindrome('')
    //    True
    //    >>> is_palindrome('aba')
    //    True
    //    >>> is_palindrome('aaaaa')
    //    True
    //    >>> is_palindrome('zbcd')
    //    False
    //    ""
        if texti != text.len (text) - 1 - i
            return false
        end
    end
    return true

end
METADATA := {}
func checkcandidate
    assert .candidate ("""") == true
    assert .candidate (""aba"") == true
    assert .candidate (""aaaaa"") == true
    assert .candidate (""zbcd"") == false
    assert .candidate (""xywyx"") == true
    assert .candidate (""xywyz"") == false
    assert .candidate (""xywzx"") == false

end
.check (is_palindrome)",
HumanEval_114_convert.evy,,
HumanEval_16_convert.evy,"func count_distinct_characters:int string:string
    //"" Given a string, find out how many distinct characters (regardless of case) does it consist of
    //    >>> count_distinct_characters('xyzXYZ')
    //    3
    //    >>> count_distinct_characters('Jerry')
    //    4
    //    ""
    return .len (.set (string_.lower ()))

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate ("""") == 0
    assert .candidate (""abcde"") == 5
    assert .candidate (""abcde"" + ""cade"" + ""CADE"") == 5
    assert .candidate (""aaaaAAAAaaaa"") == 1
    assert .candidate (""Jerry jERRY JeRRRY"") == 5

end
.check (count_distinct_characters)",
HumanEval_66_convert.evy,,
HumanEval_101_convert.evy,"func words_strings
    //""
    //    You will be given a string of words separated by commas or spaces. Your task is
    //    to split the string into words and return an array of the words.
    //    
    //    For example:
    //    words_string(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    //    words_string(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    //    ""
    if !s
        return []
    end
    s_list := []
        if letter == "",""
            s_list = s_list + ["" ""]
            s_list = s_list + [letter]
        else
            s_list = s_list + [letter]
        end
    end
    s_list = (join s_list """")
    return s_list.split ()

end
func checkcandidate
    assert true
    assert .candidate (""Hi, my name is John"") == [""Hi"" ""my"" ""name"" ""is"" ""John"" ]
    assert .candidate (""One, two, three, four, five, six"") == [""One"" ""two"" ""three"" ""four"" ""five"" ""six"" ]
    assert .candidate (""Hi, my name"") == [""Hi"" ""my"" ""name"" ]
    assert .candidate (""One,, two, three, four, five, six,"") == [""One"" ""two"" ""three"" ""four"" ""five"" ""six"" ]
    assert true
    assert .candidate ("""") == []
    assert .candidate (""ahmed     , gamal"") == [""ahmed"" ""gamal"" ]

end
.check (words_string)",
HumanEval_8.evy,"func sum_product:[]num numbers:[]num
    sum_value := 0
    prod_value := 1
    for number := range numbers
        sum_value = sum_value + number
        prod_value = prod_value * number
    end
    return [sum_value prod_value]
end
func check
    assert [0 1] (sum_product [])
    assert [3 1] (sum_product [1 1 1])
    assert [100 0] (sum_product [100 0])
    assert [15 105] (sum_product [3 5 7])
    assert [10 10] (sum_product [10])
end

func abs:num x:num
    if x < 0
        return -x
    end
    return x
end
fails := 0
total := 0
func assert want:any got:any
    total = total + 1
    if (sprintf ""%v"" want) != (sprintf ""%v"" got)
        fails = fails + 1
        printf ""want != got: want %v got %v\n"" want got
    end
end
func finished
    printf ""%v of %v tests passed\n"" (total - fails) total
end
check
finished
",
HumanEval_73_convert.evy,"func smallest_changearr
    //""
    //    Given an array arr of integers, find the minimum number of elements that
    //    need to be changed to make the array palindromic. A palindromic array is an array that
    //    is read the same backwards and forwards. In one change, you can change one element to any other element.
    //
    //    For example:
    //    smallest_change([1,2,3,5,4,7,9,6]) == 4
    //    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1
    //    smallest_change([1, 2, 3, 2, 1]) == 0
    //    ""
    ans := 0
        if arri != arr.len (arr) - i - 1
            ans = ans + 1
        end
    end
    return ans

end
func checkcandidate
    assert .candidate ([1 2 3 5 4 7 9 6 ]) == 4
    assert .candidate ([1 2 3 4 3 2 2 ]) == 1
    assert .candidate ([1 4 2 ]) == 1
    assert .candidate ([1 4 4 2 ]) == 1
    assert .candidate ([1 2 3 2 1 ]) == 0
    assert .candidate ([3 1 1 3 ]) == 0
    assert .candidate ([1 ]) == 0
    assert .candidate ([0 1 ]) == 1

end
.check (smallest_change)",
HumanEval_143_convert.evy,"func words_in_sentencesentence
    //""
    //    You are given a string representing a sentence,
    //    the sentence contains some words separated by a space,
    //    and you have to return a string that contains the words from the original sentence,
    //    whose lengths are prime numbers,
    //    the order of the words in the new string should be the same as the original one.
    //
    //    Example 1:
    //        Input: sentence = ""This is a test""
    //        Output: ""is""
    //
    //    Example 2:
    //        Input: sentence = ""lets go for swimming""
    //        Output: ""go for""
    //
    //    Constraints:
    //        * 1 <= len(sentence) <= 100
    //        * sentence contains only letters
    //    ""
    new_lst := []
        flg := 0
        if .len (word) == 1
            flg = 1
        end
            if .len (word) % i == 0
                flg = 1
            end
        end
        if flg == 0 .len (word) == 2 or
            new_lst = new_lst + [word]
        end
    end
    return (join new_lst "" "")

end
func checkcandidate
    assert .candidate (""This is a test"") == ""is""
    assert .candidate (""lets go for swimming"") == ""go for""
    assert .candidate (""there is no place available here"") == ""there is no place""
    assert .candidate (""Hi I am Hussein"") == ""Hi am Hussein""
    assert .candidate (""go for it"") == ""go for it""
    assert .candidate (""here"") == """"
    assert .candidate (""here is"") == ""is""

end
.check (words_in_sentence)",
HumanEval_41_convert.evy,"func car_race_collisionn:int
    //""
    //    Imagine a road that's a perfectly straight infinitely long line.
    //    n cars are driving left to right;  simultaneously, a different set of n cars
    //    are driving right to left.   The two sets of cars start out being very far from
    //    each other.  All cars move in the same speed.  Two cars are said to collide
    //    when a car that's moving left to right hits a car that's moving right to left.
    //    However, the cars are infinitely sturdy and strong; as a result, they continue moving
    //    in their trajectory as if they did not collide.
    //
    //    This function outputs the number of such collisions.
    //    ""
    return pow n 2

end
METADATA := {}
func checkcandidate
    assert .candidate (2) == 4
    assert .candidate (3) == 9
    assert .candidate (4) == 16
    assert .candidate (8) == 64
    assert .candidate (10) == 100

end
.check (car_race_collision)",
HumanEval_4_convert.evy,,
HumanEval_31_convert.evy,"func is_primen
    //""Return true if a given number is prime, and false otherwise.
    //    >>> is_prime(6)
    //    False
    //    >>> is_prime(101)
    //    True
    //    >>> is_prime(11)
    //    True
    //    >>> is_prime(13441)
    //    True
    //    >>> is_prime(61)
    //    True
    //    >>> is_prime(4)
    //    False
    //    >>> is_prime(1)
    //    False
    //    ""
    if n < 2
        return false
    end
        if n % k == 0
            return false
        end
    end
    return true

end
METADATA := {}
func checkcandidate
    assert .candidate (6) == false
    assert .candidate (101) == true
    assert .candidate (11) == true
    assert .candidate (13441) == true
    assert .candidate (61) == true
    assert .candidate (4) == false
    assert .candidate (1) == false
    assert .candidate (5) == true
    assert .candidate (11) == true
    assert .candidate (17) == true
    assert .candidate (5 * 17) == false
    assert .candidate (11 * 7) == false
    assert .candidate (13441 * 19) == false

end
.check (is_prime)",
HumanEval_133_convert.evy,"func sum_squareslst
    //""You are given a list of numbers.
    //    You need to return the sum of squared numbers in the given list,
    //    round each element in the list to the upper int(Ceiling) first.
    //    Examples:
    //    For lst = [1,2,3] the output should be 14
    //    For lst = [1,4,9] the output should be 98
    //    For lst = [1,3,5,7] the output should be 84
    //    For lst = [1.4,4.2,0] the output should be 29
    //    For lst = [-2.4,1,1] the output should be 6
    //    
    //
    //    ""
    
    squared := 0
        squared = squared + pow math.ceil (i) 2
    end
    return squared

end
func checkcandidate
    assert .candidate ([1 2 3 ]) == 14
    assert .candidate ([1.0 2 3 ]) == 14
    assert .candidate ([1 3 5 7 ]) == 84
    assert .candidate ([1.4 4.2 0 ]) == 29
    assert .candidate ([-2.4 1 1 ]) == 6
    assert .candidate ([100 1 15 2 ]) == 10230
    assert .candidate ([10000 10000 ]) == 200000000
    assert .candidate ([-1.4 4.6 6.3 ]) == 75
    assert .candidate ([-1.4 17.9 18.9 19.9 ]) == 1086
    assert .candidate ([0 ]) == 0
    assert .candidate ([-1 ]) == 1
    assert .candidate ([-1 1 0 ]) == 2

end
.check (sum_squares)",
HumanEval_92_convert.evy,"func any_intx y z
    //""
    //    Create a function that takes 3 numbers.
    //    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.
    //    Returns false in any other cases.
    //    
    //    Examples
    //    any_int(5, 2, 7) ➞ True
    //    
    //    any_int(3, 2, 2) ➞ False
    //
    //    any_int(3, -2, 1) ➞ True
    //    
    //    any_int(3.6, -2.2, 2) ➞ False
    //  
    //
    //    
    //    ""
    if .isinstance (x int) .isinstance (y int) .isinstance (z int) and
        if x + y == z x + z == y y + z == x or
            return true
        end
        return false
    end
    return false

end
func checkcandidate
    assert .candidate (2 3 1) == true
    assert .candidate (2.5 2 3) == false
    assert .candidate (1.5 5 3.5) == false
    assert .candidate (2 6 2) == false
    assert .candidate (4 2 2) == true
    assert .candidate (2.2 2.2 2.2) == false
    assert .candidate (-4 6 2) == true
    assert .candidate (2 1 1) == true
    assert .candidate (3 4 7) == true
    assert .candidate (3.0 4 7) == false

end
.check (any_int)",
HumanEval_9.evy,"func rolling_max:[]num numbers:[]num
    if numbers == []
        return []
    end
    running_max := numbers[0]
    result:[]num
    for number := range numbers
        if number > running_max
            running_max = number
        end
        result = result + [running_max]
    end
    return result
end
func check
    assert [] (rolling_max [])
    assert [1 2 3 4] (rolling_max [1 2 3 4])
    assert [4 4 4 4] (rolling_max [4 3 2 1])
    assert [3 3 3 100 100] (rolling_max [3 2 3 100 3])
end
func abs:num x:num
    if x < 0
        return -x
    end
    return x
end
fails := 0
total := 0
func assert want:any got:any
    total = total + 1
    if (sprintf ""%v"" want) != (sprintf ""%v"" got)
        fails = fails + 1
        printf ""want != got: want %v got %v\n"" want got
    end
end
func finished
    printf ""%v of %v tests passed\n"" (total - fails) total
end
check
finished
",
HumanEval_106_convert.evy,"func fn
    //"" Implement the function f that takes n as a parameter,
    //    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even
    //    or the sum of numbers from 1 to i otherwise.
    //    i starts from 1.
    //    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
    //    Example:
    //    f(5) == [1, 2, 6, 24, 15]
    //    ""
    ret := []
        if i % 2 == 0
            x := 1
                x = x * j
            end
            ret = ret + [x ]
            0
            x = x + j
            [x ]
        else
            x = 0
                x = x + j
            end
            ret = ret + [x ]
        end
    end
    return ret

end
func checkcandidate
    assert .candidate (5) == [1 2 6 24 15 ]
    assert .candidate (7) == [1 2 6 24 15 720 28 ]
    assert .candidate (1) == [1 ]
    assert .candidate (3) == [1 2 6 ]

end
.check (f)",
HumanEval_11.evy,"func string_xor:string a:string b:string
    res:string
    for i := range (len a)
        if a[i] == b[i]
            res = res + ""0""
        else
            res = res + ""1""
        end
    end
    return res
end
func check
    assert ""010010"" (string_xor ""111000"" ""101010"")
    assert ""0"" (string_xor ""1"" ""1"")
    assert ""0101"" (string_xor ""0101"" ""0000"")
end

func abs:num x:num
    if x < 0
        return -x
    end
    return x
end
fails := 0
total := 0
func assert want:any got:any
    total = total + 1
    if (sprintf ""%v"" want) != (sprintf ""%v"" got)
        fails = fails + 1
        printf ""want != got: want %v got %v\n"" want got
    end
end
func finished
    printf ""%v of %v tests passed\n"" (total - fails) total
end
check
finished
",
HumanEval_4.evy,"func mean_absolute_deviation:num numbers:[]num
    mean := (sum numbers) / (len numbers)
    stdev := 0
    for number := range numbers
        stdev = stdev + (abs (number - mean))
    end
    return stdev / (len numbers)
end
func check
    assert true ((abs ((mean_absolute_deviation [1.0 2.0 3.0]) - 2.0 / 3.0))< 0.000001)
    assert true ((abs ((mean_absolute_deviation [1.0 2.0 3.0 4.0]) - 1.0))< 0.000001)
    assert true ((abs ((mean_absolute_deviation [1.0 2.0 3.0 4.0 5.0]) - 6.0 / 5.0) )< 0.000001)
end
func sum:num numbers:[]num
    total := 0
    for number := range numbers
        total = total + number
    end
    return total
end
func abs:num x:num
    if x < 0
        return -x
    end
    return x
end
fails := 0
total := 0
func assert want:any got:any
    total = total + 1
    if want != got
        fails = fails + 1
        printf ""want != got: want %v got %v\n"" want got
    end
end
func finished
    printf ""%v of %v tests passed\n"" (total - fails) total
end
check
finished",
HumanEval_74_convert.evy,"func total_matchlst1 lst2
    //""
    //    Write a function that accepts two lists of strings and returns the list that has 
    //    total number of chars in the all strings of the list less than the other list.
    //
    //    if the two lists have the same number of chars, return the first list.
    //
    //    Examples
    //    total_match([], []) ➞ []
    //    total_match(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']
    //    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']
    //    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']
    //    total_match(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']
    //    ""
    l1 := 0
        l1 = l1 + .len (st)
    end
    l2 := 0
        l2 = l2 + .len (st)
    end
    if l1 <= l2
        return lst1
        lst2
    else
        return lst2
    end

end
func checkcandidate
    assert true
    assert .candidate ([] []) == []
    assert .candidate ([""hi"" ""admin"" ] [""hi"" ""hi"" ]) == [""hi"" ""hi"" ]
    assert .candidate ([""hi"" ""admin"" ] [""hi"" ""hi"" ""admin"" ""project"" ]) == [""hi"" ""admin"" ]
    assert .candidate ([""4"" ] [""1"" ""2"" ""3"" ""4"" ""5"" ]) == [""4"" ]
    assert .candidate ([""hi"" ""admin"" ] [""hI"" ""Hi"" ]) == [""hI"" ""Hi"" ]
    assert .candidate ([""hi"" ""admin"" ] [""hI"" ""hi"" ""hi"" ]) == [""hI"" ""hi"" ""hi"" ]
    assert .candidate ([""hi"" ""admin"" ] [""hI"" ""hi"" ""hii"" ]) == [""hi"" ""admin"" ]
    assert true
    assert .candidate ([] [""this"" ]) == []
    assert .candidate ([""this"" ] []) == []

end
.check (total_match)",
HumanEval_89_convert.evy,"func encrypts
    //""Create a function encrypt that takes a string as an argument and
    //    returns a string encrypted with the alphabet being rotated. 
    //    The alphabet should be rotated in a manner such that the letters 
    //    shift down by two multiplied to two places.
    //    For example:
    //    encrypt('hi') returns 'lm'
    //    encrypt('asdfghjkl') returns 'ewhjklnop'
    //    encrypt('gf') returns 'kj'
    //    encrypt('et') returns 'ix'
    //    ""
    d := ""abcdefghijklmnopqrstuvwxyz""
    out := """"
        if (has d c)
            out = out + dd.index (c) + 2 * 2 % 26
            c
        else
            out = out + c
        end
    end
    return out

end
func checkcandidate
    assert .candidate (""hi"") == ""lm""
    assert .candidate (""asdfghjkl"") == ""ewhjklnop""
    assert .candidate (""gf"") == ""kj""
    assert .candidate (""et"") == ""ix""
    assert .candidate (""faewfawefaewg"") == ""jeiajeaijeiak""
    assert .candidate (""hellomyfriend"") == ""lippsqcjvmirh""
    assert .candidate (""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"") == ""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl""
    assert .candidate (""a"") == ""e""

end
.check (encrypt)",
HumanEval_128_convert.evy,"func prod_signsarr
    //""
    //    You are given an array arr of integers and you need to return
    //    sum of magnitudes of integers multiplied by product of all signs
    //    of each number in the array, represented by 1, -1 or 0.
    //    Note: return None for empty arr.
    //
    //    Example:
    //    >>> prod_signs([1, 2, 2, -4]) == -9
    //    >>> prod_signs([0, 1]) == 0
    //    >>> prod_signs([]) == None
    //    ""
    if !arr
        return nil
    end
    prod := None
    if (has arr 0)
    prod = 0
    else 
       prod = pow -1 .len (.list (.filter (__lambda_0 arr)))
    end
    return prod * .sum (__evy_listcomp_ := []
    for i := arr:
    )

end
func checkcandidate
    assert true
    assert .candidate ([1 2 2 -4 ]) == -9
    assert .candidate ([0 1 ]) == 0
    assert .candidate ([1 1 1 2 3 -1 1 ]) == -10
    assert .candidate ([]) == nil
    assert .candidate ([2 4 1 2 -1 -1 9 ]) == 20
    assert .candidate ([-1 1 -1 1 ]) == 4
    assert .candidate ([-1 1 1 1 ]) == -4
    assert .candidate ([-1 1 1 0 ]) == 0
    assert true

end
.check (prod_signs)",
HumanEval_158_convert.evy,"func find_maxwords
    //""Write a function that accepts a list of strings.
    //    The list contains different words. Return the word with maximum number
    //    of unique characters. If multiple strings have maximum number of unique
    //    characters, return the one which comes first in lexicographical order.
    //
    //    find_max([""name"", ""of"", ""string""]) == ""string""
    //    find_max([""name"", ""enam"", ""game""]) == ""enam""
    //    find_max([""aaaaaaa"", ""bb"" ,""cc""]) == """"aaaaaaa""
    //    ""
    return .sorted (words)0

end
func checkcandidate
    assert .candidate ([""name"" ""of"" ""string"" ]) == ""string""
    assert .candidate ([""name"" ""enam"" ""game"" ]) == ""enam""
    assert .candidate ([""aaaaaaa"" ""bb"" ""cc"" ]) == ""aaaaaaa""
    assert .candidate ([""abc"" ""cba"" ]) == ""abc""
    assert .candidate ([""play"" ""this"" ""game"" ""of"" ""footbott"" ]) == ""footbott""
    assert .candidate ([""we"" ""are"" ""gonna"" ""rock"" ]) == ""gonna""
    assert .candidate ([""we"" ""are"" ""a"" ""mad"" ""nation"" ]) == ""nation""
    assert .candidate ([""this"" ""is"" ""a"" ""prrk"" ]) == ""this""
    assert .candidate ([""b"" ]) == ""b""
    assert .candidate ([""play"" ""play"" ""play"" ]) == ""play""

end
.check (find_max)",
HumanEval_46_convert.evy,"func fib4n:int
    //""The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
    //    fib4(0) -> 0
    //    fib4(1) -> 0
    //    fib4(2) -> 2
    //    fib4(3) -> 0
    //    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
    //    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
    //    >>> fib4(5)
    //    4
    //    >>> fib4(6)
    //    8
    //    >>> fib4(7)
    //    14
    //    ""
    results := [0 0 2 0 ]
    if n < 4
        return resultsn
    end
        results = results + [results-1 + results-2 + results-3 + results-4]
        results.pop (0)
    end
    return results-1

end
METADATA := {}
func checkcandidate
    assert .candidate (5) == 4
    assert .candidate (8) == 28
    assert .candidate (10) == 104
    assert .candidate (12) == 386

end
.check (fib4)",
HumanEval_144_convert.evy,"func simplifyx n
    //""Your task is to implement a function that will simplify the expression
    //    x * n. The function returns True if x * n evaluates to a whole number and False
    //    otherwise. Both x and n, are string representation of a fraction, and have the following format,
    //    <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    //
    //    You can assume that x, and n are valid fractions, and do not have zero as denominator.
    //
    //    simplify(""1/5"", ""5/1"") = True
    //    simplify(""1/6"", ""2/1"") = False
    //    simplify(""7/10"", ""10/2"") = False
    //    ""
    [a b ] := x.split (""/"")
    [c d ] := n.split (""/"")
    numerator := .int (a) * .int (c)
    denom := .int (b) * .int (d)
    if numerator / denom == .int (numerator / denom)
        return true
    end
    return false

end
func checkcandidate
    assert .candidate (""1/5"" ""5/1"") == true
    assert .candidate (""1/6"" ""2/1"") == false
    assert .candidate (""5/1"" ""3/1"") == true
    assert .candidate (""7/10"" ""10/2"") == false
    assert .candidate (""2/10"" ""50/10"") == true
    assert .candidate (""7/2"" ""4/2"") == true
    assert .candidate (""11/6"" ""6/1"") == true
    assert .candidate (""2/3"" ""5/2"") == false
    assert .candidate (""5/2"" ""3/5"") == false
    assert .candidate (""2/4"" ""8/4"") == true
    assert .candidate (""2/4"" ""4/2"") == true
    assert .candidate (""1/5"" ""5/1"") == true
    assert .candidate (""1/5"" ""1/5"") == false

end
.check (simplify)",
HumanEval_134_convert.evy,,
HumanEval_36_convert.evy,"func fizz_buzzn:int
    //""Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
    //    >>> fizz_buzz(50)
    //    0
    //    >>> fizz_buzz(78)
    //    2
    //    >>> fizz_buzz(79)
    //    3
    //    ""
    ns := []
        if i % 11 == 0 i % 13 == 0 or
            ns = ns + [i]
        end
    end
    s := (join .list (.map (string ns)) """")
    ans := 0
        ans = ans + c == ""7""
    end
    return ans

end
METADATA := {}
func checkcandidate
    assert .candidate (50) == 0
    assert .candidate (78) == 2
    assert .candidate (79) == 3
    assert .candidate (100) == 3
    assert .candidate (200) == 6
    assert .candidate (4000) == 192
    assert .candidate (10000) == 639
    assert .candidate (100000) == 8026

end
.check (fizz_buzz)",
HumanEval_3_convert.evy,"func below_zero:bool operations:[]int
    //"" You're given a list of deposit and withdrawal operations on a bank account that starts with
    //    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
    //    at that point function should return True. Otherwise it should return False.
    //    >>> below_zero([1, 2, 3])
    //    False
    //    >>> below_zero([1, 2, -4, 5])
    //    True
    //    ""
    balance := 0
        balance = balance + op
        if balance < 0
            return true
        end
    end
    return false

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate ([]) == false
    assert .candidate ([1 2 -3 1 2 -3 ]) == false
    assert .candidate ([1 2 -4 5 6 ]) == true
    assert .candidate ([1 -1 2 -2 5 -5 4 -4 ]) == false
    assert .candidate ([1 -1 2 -2 5 -5 4 -5 ]) == true
    assert .candidate ([1 -2 2 -2 5 -5 4 -4 ]) == true

end
.check (below_zero)",
HumanEval_95_convert.evy,,
HumanEval_68_convert.evy,"func pluckarr
    //""
    //    ""Given an array representing a branch of a tree that has non-negative integer nodes
    //    your task is to pluck one of the nodes and return it.
    //    The plucked node should be the node with the smallest even value.
    //    If multiple nodes with the same smallest even value are found return the node that has smallest index.
    //
    //    The plucked node should be returned in a list, [ smalest_value, its index ],
    //    If there are no even values or the given array is empty, return [].
    //
    //    Example 1:
    //        Input: [4,2,3]
    //        Output: [2, 1]
    //        Explanation: 2 has the smallest even value, and 2 has the smallest index.
    //
    //    Example 2:
    //        Input: [1,2,3]
    //        Output: [2, 1]
    //        Explanation: 2 has the smallest even value, and 2 has the smallest index. 
    //
    //    Example 3:
    //        Input: []
    //        Output: []
    //    
    //    Example 4:
    //        Input: [5, 0, 3, 0, 4, 2]
    //        Output: [0, 1]
    //        Explanation: 0 is the smallest value, but  there are two zeros,
    //                     so we will choose the first zero, which has the smallest index.
    //
    //    Constraints:
    //        * 1 <= nodes.length <= 10000
    //        * 0 <= node.value
    //    ""
    if .len (arr) == 0
        return []
    end
    evens := .list (.filter (__lambda_2 arr))
    if evens == []
        return []
    end
    return [.min (evens) arr.index (.min (evens)) ]

end
func checkcandidate
    assert true
    assert .candidate ([4 2 3 ]) == [2 1 ]
    assert .candidate ([1 2 3 ]) == [2 1 ]
    assert .candidate ([]) == []
    assert .candidate ([5 0 3 0 4 2 ]) == [0 1 ]
    assert true
    assert .candidate ([1 2 3 0 5 3 ]) == [0 3 ]
    assert .candidate ([5 4 8 4 8 ]) == [4 1 ]
    assert .candidate ([7 6 7 1 ]) == [6 1 ]
    assert .candidate ([7 9 7 1 ]) == []

end
.check (pluck)",
HumanEval_5.evy,"func intersperse:[]num numbers:[]num delimeter:num
    if (len numbers) == 0
        return []
    end
    result:[]num
    for number := range numbers[:-1]
        result = result + [number] + [delimeter]
    end
    result = result + [numbers[-1]]
    return result
end
func check
    assert [] (intersperse [] 7)
    assert [5 8 6 8 3 8 2] (intersperse [5 6 3 2] 8)
    assert [2 2 2 2 2] (intersperse [2 2 2] 2)
end
func abs:num x:num
    if x < 0
        return -x
    end
    return x
end
fails := 0
total := 0
func assert want:any got:any
    total = total + 1
    if (sprintf ""%v"" want) != (sprintf ""%v"" got)
        fails = fails + 1
        printf ""want != got: want %v got %v\n"" want got
    end
end
func finished
    printf ""%v of %v tests passed\n"" (total - fails) total
end
check
finished
",
HumanEval_10.evy,"func is_palindrome:bool str:string
    return str == (reverse str)
end
func make_palindrome:string str:string
    if str == """"
        return """"
    end
    beginning_of_suffix := 0
    while !(is_palindrome str[beginning_of_suffix:])
        beginning_of_suffix = beginning_of_suffix + 1
    end
    return str + (reverse str[:beginning_of_suffix])
end
func reverse:string str:string
    reversed := """"
    for i := range(len str)
        reversed = str[i] + reversed
    end
    return reversed
end
func check
    assert """" (make_palindrome """")
    assert ""x"" (make_palindrome ""x"")
    assert ""xyzyx"" (make_palindrome ""xyz"")
    assert ""xyx"" (make_palindrome ""xyx"")
    assert ""jerryrrej"" (make_palindrome ""jerry"")
end

func abs:num x:num
    if x < 0
        return -x
    end
    return x
end
fails := 0
total := 0
func assert want:any got:any
    total = total + 1
    if (sprintf ""%v"" want) != (sprintf ""%v"" got)
        fails = fails + 1
        printf ""want != got: want %v got %v\n"" want got
    end
end
func finished
    printf ""%v of %v tests passed\n"" (total - fails) total
end
check
finished
",
HumanEval_18_convert.evy,,
HumanEval_80_convert.evy,"func is_happys
    //""You are given a string s.
    //    Your task is to check if the string is happy or not.
    //    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct
    //    For example:
    //    is_happy(a) => False
    //    is_happy(aa) => False
    //    is_happy(abcd) => True
    //    is_happy(aabb) => False
    //    is_happy(adb) => True
    //    is_happy(xyy) => False
    //    ""
    if .len (s) < 3
        return false
    end
        if si == si + 1 si + 1 == si + 2 si == si + 2 or
            return false
        end
    end
    return true

end
func checkcandidate
    assert .candidate (""a"") == false
    assert .candidate (""aa"") == false
    assert .candidate (""abcd"") == true
    assert .candidate (""aabb"") == false
    assert .candidate (""adb"") == true
    assert .candidate (""xyy"") == false
    assert .candidate (""iopaxpoi"") == true
    assert .candidate (""iopaxioi"") == false

end
.check (is_happy)",
HumanEval_12.evy,"func longest:string strings:[]string
  if (len strings) == 0 
    return ""null""
  end
  maxlen := 0
  for s := range strings
    if (len s) > maxlen
      maxlen = (len s)
    end
  end
  for s := range strings
    if (len s) == maxlen
      return s
    end
  end
  return ""null""
end
func check
    assert (longest [])  ""null""
    assert (longest [""x"" ""y"" ""z""])  ""x""
    assert (longest [""x"" ""yyy"" ""zzzz"" ""www"" ""kkkk"" ""abc""])  ""zzzz""
end
func abs:num x:num
    if x < 0
        return -x
    end
    return x
end
fails := 0
total := 0
func assert want:any got:any
    total = total + 1
    if (sprintf ""%v"" want) != (sprintf ""%v"" got)
        fails = fails + 1
        printf ""want != got: want %v got %v\n"" want got
    end
end
func finished
    printf ""%v of %v tests passed\n"" (total - fails) total
end
check
finished
",
HumanEval_7.evy,"func filter_by_substring:[]string strings:[]string substring:string
    ans: []string
    for str := range strings
        if (contains str substring)
            ans = ans + [str]
        end
    end
    return ans
end
func check
    assert [] (filter_by_substring [] ""john"")
    assert [""xxx"" ""xxxAAA"" ""xxx""] (filter_by_substring [""xxx"" ""asd"" ""xxy"" ""john doe"" ""xxxAAA"" ""xxx""] ""xxx"")
    assert [""xxx"" ""aaaxxy"" ""xxxAAA"" ""xxx""] (filter_by_substring [""xxx"" ""asd"" ""aaaxxy"" ""john doe"" ""xxxAAA"" ""xxx""] ""xx"")
    assert [""grunt"" ""prune""] (filter_by_substring [""grunt"" ""trumpet"" ""prune"" ""gruesome""] ""run"")
end
func contains:bool haystack:string needle:string
    for i := range ((len haystack) - (len needle) + 1)
        if haystack[i:i + (len needle)] == needle
            return true
        end
    end
    return false
end
func abs:num x:num
    if x < 0
        return -x
    end
    return x
end
fails := 0
total := 0
func assert want:any got:any
    total = total + 1
    if (sprintf ""%v"" want) != (sprintf ""%v"" got)
        fails = fails + 1
        printf ""want != got: want %v got %v\n"" want got
    end
end
func finished
    printf ""%v of %v tests passed\n"" (total - fails) total
end
check
finished
",
HumanEval_53_convert.evy,"func addx:int y:int
    //""Add two numbers x and y
    //    >>> add(2, 3)
    //    5
    //    >>> add(5, 7)
    //    12
    //    ""
    return x + y

end
METADATA := {}
func checkcandidate
    
    assert .candidate (0 1) == 1
    assert .candidate (1 0) == 1
    assert .candidate (2 3) == 5
    assert .candidate (5 7) == 12
    assert .candidate (7 5) == 12
        [x y ] := [random.randint (0 1000) random.randint (0 1000) ]
        assert .candidate (x y) == x + y
    end

end
.check (add)",
HumanEval_151_convert.evy,"func double_the_differencelst
    //""
    //    Given a list of numbers, return the sum of squares of the numbers
    //    in the list that are odd. Ignore numbers that are negative or not integers.
    //    
    //    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10
    //    double_the_difference([-1, -2, 0]) == 0
    //    double_the_difference([9, -2]) == 81
    //    double_the_difference([0]) == 0  
    //   
    //    If the input list is empty, return 0.
    //    ""
    return .sum (__evy_listcomp_ := []
    for i := lst:
    if i > 0 i % 2 != 0 !(has .str (i) ""."") and
    )

end
func checkcandidate
    assert .candidate ([]) == 0
    assert .candidate ([5 4 ]) == 25
    assert .candidate ([0.1 0.2 0.3 ]) == 0
    assert .candidate ([-10 -20 -30 ]) == 0
    assert .candidate ([-1 -2 8 ]) == 0
    assert .candidate ([0.2 3 5 ]) == 34
    lst := .list (.range (-99 100 2))
    odd_sum := .sum (__evy_listcomp_ := []
    for i := lst:
    if i % 2 != 0 i > 0 and
    )
    assert .candidate (lst) == odd_sum

end
.check (double_the_difference)",
HumanEval_121_convert.evy,"func solutionlst
    //""Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.
    //    
    //
    //    Examples
    //    solution([5, 8, 7, 1]) ==> 12
    //    solution([3, 3, 3, 3, 3]) ==> 9
    //    solution([30, 13, 24, 321]) ==>0
    //    ""
    return .sum (__evy_listcomp_ := []
    for [idx x ] := .enumerate (lst):
    if idx % 2 == 0 x % 2 == 1 and
    )

end
func checkcandidate
    assert .candidate ([5 8 7 1 ]) == 12
    assert .candidate ([3 3 3 3 3 ]) == 9
    assert .candidate ([30 13 24 321 ]) == 0
    assert .candidate ([5 9 ]) == 5
    assert .candidate ([2 4 8 ]) == 0
    assert .candidate ([30 13 23 32 ]) == 23
    assert .candidate ([3 13 2 9 ]) == 3

end
.check (solution)",
HumanEval_23_convert.evy,"func strlen:int string:string
    //"" Return length of given string
    //    >>> strlen('')
    //    0
    //    >>> strlen('abc')
    //    3
    //    ""
    return .len (string_)

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate ("""") == 0
    assert .candidate (""x"") == 1
    assert .candidate (""asdasnakj"") == 9

end
.check (strlen)",
HumanEval_11_convert.evy,,
HumanEval_113_convert.evy,,
HumanEval_6.evy,"func parse_paren_group:num s:string
    depth:num
    max_depth:num
    for c := range s
        if c == ""(""
            depth = depth + 1
            max_depth = max depth max_depth
        else
            depth = depth - 1
        end
    end
    return max_depth
end
func parse_nested_parens:[]num paren_string:string
    result:[]num
    for x := range (split paren_string "" "")
        if x != """"
            result = result + [(parse_paren_group x)]
        end
    end
    return result
end
func check
    assert [2 3 1 3] (parse_nested_parens ""(()()) ((())) () ((())()())"")
    assert [1 2 3 4] (parse_nested_parens ""() (()) ((())) (((())))"")
    assert [4] (parse_nested_parens ""(()(())((())))"")
end

func abs:num x:num
    if x < 0
        return -x
    end
    return x
end
fails := 0
total := 0
func assert want:any got:any
    total = total + 1
    if (sprintf ""%v"" want) != (sprintf ""%v"" got)
        fails = fails + 1
        printf ""want != got: want %v got %v\n"" want got
    end
end
func finished
    printf ""%v of %v tests passed\n"" (total - fails) total
end
check
finished
",
HumanEval_13.evy,"func greatest_common_divisor:num a:num b:num
    while b != 0
        tmp := a
        a = b
        b = tmp % b
    end
    return a
end
func check
    assert 1 (greatest_common_divisor 3 7)
    assert 5 (greatest_common_divisor 10 15)
    assert 7 (greatest_common_divisor 49 14)
    assert 12 (greatest_common_divisor 144 60)
end
func abs:num x:num
    if x < 0
        return -x
    end
    return x
end
fails := 0
total := 0
func assert want:any got:any
    total = total + 1
    if (sprintf ""%v"" want) != (sprintf ""%v"" got)
        fails = fails + 1
        printf ""want != got: want %v got %v\n"" want got
    end
end
func finished
    printf ""%v of %v tests passed\n"" (total - fails) total
end
check
finished
",
HumanEval_163_convert.evy,"func generate_integersa b
    //""
    //    Given two positive integers a and b, return the even digits between a
    //    and b, in ascending order.
    //
    //    For example:
    //    generate_integers(2, 8) => [2, 4, 6, 8]
    //    generate_integers(8, 2) => [2, 4, 6, 8]
    //    generate_integers(10, 14) => []
    //    ""
    lower := .max (2 .min (a b))
    upper := .min (8 .max (a b))
    return __evy_listcomp_ := []
    for i := .range (lower upper + 1):
    if i % 2 == 0

end
func checkcandidate
    assert .candidate (2 10) == [2 4 6 8 ]
    assert .candidate (10 2) == [2 4 6 8 ]
    assert .candidate (132 2) == [2 4 6 8 ]
    assert .candidate (17 89) == []
    assert true

end
.check (generate_integers)",
HumanEval_61_convert.evy,"func correct_bracketingbrackets:string
    //"" brackets is a string of ""("" and "")"".
    //    return True if every opening bracket has a corresponding closing bracket.
    //
    //    >>> correct_bracketing(""("")
    //    False
    //    >>> correct_bracketing(""()"")
    //    True
    //    >>> correct_bracketing(""(()())"")
    //    True
    //    >>> correct_bracketing("")(()"")
    //    False
    //    ""
    depth := 0
        if b == ""(""
            depth = depth + 1
            1
        else
            depth = depth - 1
        end
        if depth < 0
            return false
        end
    end
    return depth == 0

end
METADATA := {}
func checkcandidate
    assert .candidate (""()"")
    assert .candidate (""(()())"")
    assert .candidate (""()()(()())()"")
    assert .candidate (""()()((()()())())(()()(()))"")
    assert !.candidate (""((()())))"")
    assert !.candidate ("")(()"")
    assert !.candidate (""("")
    assert !.candidate (""(((("")
    assert !.candidate ("")"")
    assert !.candidate (""(()"")
    assert !.candidate (""()()(()())())(()"")
    assert !.candidate (""()()(()())()))()"")

end
.check (correct_bracketing)",
HumanEval_26_convert.evy,"func remove_duplicates:[]int numbers:[]int
    //"" From a list of integers, remove all elements that occur more than once.
    //    Keep order of elements left the same as in the input.
    //    >>> remove_duplicates([1, 2, 3, 2, 4])
    //    [1, 3, 4]
    //    ""
    
    c := collections.Counter (numbers)
    return __evy_listcomp_ := []
    for n := numbers:
    if cn <= 1

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate ([]) == []
    assert .candidate ([1 2 3 4 ]) == [1 2 3 4 ]
    assert .candidate ([1 2 3 2 4 3 5 ]) == [1 4 5 ]

end
.check (remove_duplicates)",
HumanEval_124_convert.evy,,
HumanEval_2.evy,"func truncateNumber:num number:num
    return number % 1.0
end
func check
    assert 0.5 (truncateNumber 3.5)
    assert true (((abs (truncateNumber (1.33 - 0.33)))<0.000001))
    assert true (((abs (truncateNumber (123.456 - 0.456)))<0.000001))
end

func abs:num x:num
    if x < 0
        return -x
    end
    return x
end
fails := 0
total := 0
func assert want:any got:any
    total = total + 1
    if want != got
        fails = fails + 1
        printf ""want != got: want %v got %v\n"" want got
    end
end
func finished
    printf ""%v of %v tests passed\n"" (total - fails) total
end
check
finished
",
HumanEval_154_convert.evy,"func cycpattern_checka b
    //""You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word
    //    cycpattern_check(""abcd"",""abd"") => False
    //    cycpattern_check(""hello"",""ell"") => True
    //    cycpattern_check(""whassup"",""psus"") => False
    //    cycpattern_check(""abab"",""baa"") => True
    //    cycpattern_check(""efef"",""eeff"") => False
    //    cycpattern_check(""himenss"",""simen"") => True
    //
    //    ""
    l := .len (b)
    pat := b + b
            if a[i:i + l] == pat[j:j + l]
                return true
            end
        end
    end
    return false

end
func checkcandidate
    assert .candidate (""xyzw"" ""xyw"") == false
    assert .candidate (""yello"" ""ell"") == true
    assert .candidate (""whattup"" ""ptut"") == false
    assert .candidate (""efef"" ""fee"") == true
    assert .candidate (""abab"" ""aabb"") == false
    assert .candidate (""winemtt"" ""tinem"") == true

end
.check (cycpattern_check)",
HumanEval_56_convert.evy,"func correct_bracketingbrackets:string
    //"" brackets is a string of ""<"" and "">"".
    //    return True if every opening bracket has a corresponding closing bracket.
    //
    //    >>> correct_bracketing(""<"")
    //    False
    //    >>> correct_bracketing(""<>"")
    //    True
    //    >>> correct_bracketing(""<<><>>"")
    //    True
    //    >>> correct_bracketing(""><<>"")
    //    False
    //    ""
    depth := 0
        if b == ""<""
            depth = depth + 1
            1
        else
            depth = depth - 1
        end
        if depth < 0
            return false
        end
    end
    return depth == 0

end
METADATA := {}
func checkcandidate
    assert .candidate (""<>"")
    assert .candidate (""<<><>>"")
    assert .candidate (""<><><<><>><>"")
    assert .candidate (""<><><<<><><>><>><<><><<>>>"")
    assert !.candidate (""<<<><>>>>"")
    assert !.candidate (""><<>"")
    assert !.candidate (""<"")
    assert !.candidate (""<<<<"")
    assert !.candidate ("">"")
    assert !.candidate (""<<>"")
    assert !.candidate (""<><><<><>><>><<>"")
    assert !.candidate (""<><><<><>><>>><>"")

end
.check (correct_bracketing)",
HumanEval_78_convert.evy,"func hex_keynum
    //""You have been tasked to write a function that receives 
    //    a hexadecimal number as a string and counts the number of hexadecimal 
    //    digits that are primes (prime number, or a prime, is a natural number 
    //    greater than 1 that is not a product of two smaller natural numbers).
    //    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
    //    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
    //    So you have to determine a number of the following digits: 2, 3, 5, 7, 
    //    B (=decimal 11), D (=decimal 13).
    //    Note: you may assume the input is always correct or empty string, 
    //    and symbols A,B,C,D,E,F are always uppercase.
    //    Examples:
    //    For num = ""AB"" the output should be 1.
    //    For num = ""1077E"" the output should be 2.
    //    For num = ""ABED1A33"" the output should be 4.
    //    For num = ""123456789ABCDEF0"" the output should be 6.
    //    For num = ""2020"" the output should be 2.
    //    ""
    primes := [""2"" ""3"" ""5"" ""7"" ""B"" ""D"" ]
    total := 0
        if (has primes num_i)
            total = total + 1
        end
    end
    return total

end
func checkcandidate
    assert .candidate (""AB"") == 1
    assert .candidate (""1077E"") == 2
    assert .candidate (""ABED1A33"") == 4
    assert .candidate (""2020"") == 2
    assert .candidate (""123456789ABCDEF0"") == 6
    assert .candidate (""112233445566778899AABBCCDDEEFF00"") == 12
    assert .candidate ([]) == 0

end
.check (hex_key)",
HumanEval_85_convert.evy,"func addlst
    //""Given a non-empty list of integers lst. add the even elements that are at odd indices..
    //
    //
    //    Examples:
    //        add([4, 2, 6, 7]) ==> 2 
    //    ""
    return .sum (__evy_listcomp_ := []
    for i := .range (1 .len (lst) 2):
    if lsti % 2 == 0
    )

end
func checkcandidate
    assert .candidate ([4 88 ]) == 88
    assert .candidate ([4 5 6 7 2 122 ]) == 122
    assert .candidate ([4 0 6 7 ]) == 0
    assert .candidate ([4 4 6 8 ]) == 12

end
.check (add)",
HumanEval_99_convert.evy,"func closest_integervalue
    //""
    //    Create a function that takes a value (string) representing a number
    //    and returns the closest integer to it. If the number is equidistant
    //    from two integers, round it away from zero.
    //
    //    Examples
    //    >>> closest_integer(""10"")
    //    10
    //    >>> closest_integer(""15.3"")
    //    15
    //
    //    Note:
    //    Rounding away from zero means that if the given number is equidistant
    //    from two integers, the one you should return is the one that is the
    //    farthest from zero. For example closest_integer(""14.5"") should
    //    return 15 and closest_integer(""-14.5"") should return -15.
    //    ""
    
    if value.count (""."") == 1
        while value-1 == ""0""
            value := value[0:-1]
        end
    end
    num_ := .float (value)
    if value[-2:] == "".5""
        if num_ > 0
            res := .ceil (num_)
            .floor (num_)
        else
            res = .floor (num_)
        end
    else if .len (value) > 0
        res = .int (.round (num_))
    else
        if .len (value) > 0
            res = .int (.round (num_))
            0
        else
            res = 0
        end
    end
    return res

end
func checkcandidate
    assert .candidate (""10"") == 10
    assert .candidate (""14.5"") == 15
    assert .candidate (""-15.5"") == -16
    assert .candidate (""15.3"") == 15
    assert .candidate (""0"") == 0

end
.check (closest_integer)",
HumanEval_64_convert.evy,,
HumanEval_116_convert.evy,"func sort_arrayarr
    //""
    //    In this Kata, you have to sort an array of non-negative integers according to
    //    number of ones in their binary representation in ascending order.
    //    For similar number of ones, sort based on decimal value.
    //
    //    It must be implemented like this:
    //    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]
    //    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]
    //    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]
    //    ""
    return .sorted (.sorted (arr))

end
func checkcandidate
    assert true
    assert .candidate ([1 5 2 3 4 ]) == [1 2 4 3 5 ]
    assert .candidate ([-2 -3 -4 -5 -6 ]) == [-4 -2 -6 -5 -3 ]
    assert .candidate ([1 0 2 3 4 ]) == [0 1 2 4 3 ]
    assert .candidate ([]) == []
    assert .candidate ([2 5 77 4 5 3 5 7 2 3 4 ]) == [2 2 4 4 3 3 5 5 5 7 77 ]
    assert .candidate ([3 6 44 12 32 5 ]) == [32 3 5 6 12 44 ]
    assert .candidate ([2 4 8 16 32 ]) == [2 4 8 16 32 ]
    assert .candidate ([2 4 8 16 32 ]) == [2 4 8 16 32 ]
    assert true

end
.check (sort_array)",
HumanEval_14_convert.evy,,
HumanEval_148_convert.evy,"func bfplanet1 planet2
    //""
    //    There are eight planets in our solar system: the closerst to the Sun 
    //    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, 
    //    Uranus, Neptune.
    //    Write a function that takes two planet names as strings planet1 and planet2. 
    //    The function should return a tuple containing all planets whose orbits are 
    //    located between the orbit of planet1 and the orbit of planet2, sorted by 
    //    the proximity to the sun. 
    //    The function should return an empty tuple if planet1 or planet2
    //    are not correct planet names. 
    //    Examples
    //    bf(""Jupiter"", ""Neptune"") ==> (""Saturn"", ""Uranus"")
    //    bf(""Earth"", ""Mercury"") ==> (""Venus"")
    //    bf(""Mercury"", ""Uranus"") ==> (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"")
    //    ""
    planet_names := [""Mercury"" ""Venus"" ""Earth"" ""Mars"" ""Jupiter"" ""Saturn"" ""Uranus"" ""Neptune"" ]
    if !(has planet_names planet1) !(has planet_names planet2) planet1 == planet2 or
        return []
    end
    planet1_index := planet_names.index (planet1)
    planet2_index := planet_names.index (planet2)
    if planet1_index < planet2_index
        return planet_names[planet1_index + 1:planet2_index]
        planet_names[planet2_index + 1:planet1_index]
    else
        return planet_names[planet2_index + 1:planet1_index]
    end

end
func checkcandidate
    assert .candidate (""Jupiter"" ""Neptune"") == [""Saturn"" ""Uranus"" ]
    assert .candidate (""Earth"" ""Mercury"") == [""Venus"" ]
    assert .candidate (""Mercury"" ""Uranus"") == [""Venus"" ""Earth"" ""Mars"" ""Jupiter"" ""Saturn"" ]
    assert .candidate (""Neptune"" ""Venus"") == [""Earth"" ""Mars"" ""Jupiter"" ""Saturn"" ""Uranus"" ]
    assert .candidate (""Earth"" ""Earth"") == []
    assert .candidate (""Mars"" ""Earth"") == []
    assert .candidate (""Jupiter"" ""Makemake"") == []

end
.check (bf)",
HumanEval_3.evy,"func below_zero:bool operations:[]num
    balance := 0
    
    for op := range (len operations)
        balance = balance + operations[op]
        if balance < 0
            return true
        end
    end
    
    return false
end
func check
    assert false (below_zero [])
    assert false (below_zero [1 2 -3 1 2 -3])
    assert true (below_zero [1 2 -4 5 6])
    assert false (below_zero [1 -1 2 -2 5 -5 4 -4])
    assert true (below_zero [1 -1 2 -2 5 -5 4 -5])
    assert true (below_zero [1 -2 2 -2 5 -5 4 -4])
end

func abs:num x:num
    if x < 0
        return -x
    end
    return x
end
fails := 0
total := 0
func assert want:any got:any
    total = total + 1
    if want != got
        fails = fails + 1
        printf ""want != got: want %v got %v\n"" want got
    end
end
func finished
    printf ""%v of %v tests passed\n"" (total - fails) total
end
check
finished
",
HumanEval_138_convert.evy,"func is_equal_to_sum_evenn
    //""Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
    //    Example
    //    is_equal_to_sum_even(4) == False
    //    is_equal_to_sum_even(6) == False
    //    is_equal_to_sum_even(8) == True
    //    ""
    return n % 2 == 0 n >= 8 and

end
func checkcandidate
    assert .candidate (4) == false
    assert .candidate (6) == false
    assert .candidate (8) == true
    assert .candidate (10) == true
    assert .candidate (11) == false
    assert .candidate (12) == true
    assert .candidate (13) == false
    assert .candidate (16) == true

end
.check (is_equal_to_sum_even)",
HumanEval_14.evy,"func all_prefixes:[]string str:string
    result:[]string
    for i := range (len str)
        result = result + [str[:i+1]]
    end
    return result
end
func check
    assert [] (all_prefixes """")
    assert [""a"" ""as"" ""asd"" ""asdf"" ""asdfg"" ""asdfgh""] (all_prefixes ""asdfgh"")
    assert [""W"" ""WW"" ""WWW""] (all_prefixes ""WWW"")
end
func abs:num x:num
    if x < 0
        return -x
    end
    return x
end
fails := 0
total := 0
func assert want:any got:any
    total = total + 1
    if (sprintf ""%v"" want) != (sprintf ""%v"" got)
        fails = fails + 1
        printf ""want != got: want %v got %v\n"" want got
    end
end
func finished
    printf ""%v of %v tests passed\n"" (total - fails) total
end
check
finished
",
HumanEval_1.evy,"func separate_paren_groups:[]string paren_string:string
    result:[]string
        current_string:string
        current_depth:num
        current_depth = 0
    
        for c := range (len paren_string)
            if paren_string[c] == ""(""
                current_depth = current_depth + 1
                current_string = current_string + paren_string[c]
            else if paren_string[c] == "")""
                current_depth = current_depth - 1
                current_string = current_string + paren_string[c]
    
                if current_depth == 0
                    result = result + [current_string]
                    current_string = """"
                end
            end
        end
    
        return result
end
func check
    assert [""(()())"" ""((()))"" ""()"" ""((())()())""] (separate_paren_groups ""(()()) ((())) () ((())()())"")
    assert [""()"" ""(())"" ""((()))"" ""(((())))""] (separate_paren_groups ""() (()) ((())) (((())))"")
    assert [""(()(())((())))""] (separate_paren_groups ""(()(())((())))"")
    assert [""()"" ""(())"" ""(()())""] (separate_paren_groups ""( ) (( )) (( )( ))"")
end

func abs:num x:num
    if x < 0
        return -x
    end
    return x
end
fails := 0
total := 0
func assert want:any got:any
    total = total + 1
    if want != got
        fails = fails + 1
        printf ""want != got: want %v got %v\n"" want got
    end
end
func finished
    printf ""%v of %v tests passed\n"" (total - fails) total
end
check
finished
",
HumanEval_71_convert.evy,"func triangle_areaa b c
    //""
    //    Given the lengths of the three sides of a triangle. Return the area of
    //    the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
    //    Otherwise return -1
    //    Three sides make a valid triangle when the sum of any two sides is greater 
    //    than the third side.
    //    Example:
    //    triangle_area(3, 4, 5) == 6.00
    //    triangle_area(1, 2, 10) == -1
    //    ""
    if a + b <= c a + c <= b b + c <= a or
        return -1
    end
    s := a + b + c / 2
    area := pow s * s - a * s - b * s - c 0.5
    area = .round (area 2)
    return area

end
func checkcandidate
    assert .candidate (3 4 5) == 6.0
    assert .candidate (1 2 10) == -1
    assert .candidate (4 8 5) == 8.18
    assert .candidate (2 2 2) == 1.73
    assert .candidate (1 2 3) == -1
    assert .candidate (10 5 7) == 16.25
    assert .candidate (2 6 3) == -1
    assert .candidate (1 1 1) == 0.43
    assert .candidate (2 2 10) == -1

end
.check (triangle_area)",
HumanEval_103_convert.evy,"func rounded_avgn m
    //""You are given two positive integers n and m, and your task is to compute the
    //    average of the integers from n through m (including n and m). 
    //    Round the answer to the nearest integer and convert that to binary.
    //    If n is greater than m, return -1.
    //    Example:
    //    rounded_avg(1, 5) => ""0b11""
    //    rounded_avg(7, 5) => -1
    //    rounded_avg(10, 20) => ""0b1111""
    //    rounded_avg(20, 33) => ""0b11010""
    //    ""
    if m < n
        return -1
    end
    summation := 0
        summation = summation + i
    end
    return .bin (.round (summation / m - n + 1))

end
func checkcandidate
    assert .candidate (1 5) == ""0b11""
    assert .candidate (7 13) == ""0b1010""
    assert .candidate (964 977) == ""0b1111001010""
    assert .candidate (996 997) == ""0b1111100100""
    assert .candidate (560 851) == ""0b1011000010""
    assert .candidate (185 546) == ""0b101101110""
    assert .candidate (362 496) == ""0b110101101""
    assert .candidate (350 902) == ""0b1001110010""
    assert .candidate (197 233) == ""0b11010111""
    assert .candidate (7 5) == -1
    assert .candidate (5 1) == -1
    assert .candidate (5 5) == ""0b101""

end
.check (rounded_avg)",
HumanEval_90_convert.evy,,
HumanEval_0.evy,"func has_close_elements:bool numbers:[]num threshold:num
    for idx := range (len numbers)
        for idx2 := range (len numbers)
            if idx != idx2
                distance := abs ( numbers[idx] - numbers[idx2])
                if distance < threshold
                    return true
                end
            end
        end
    end
    return false
end
func check
    assert true (has_close_elements [1.0 2.0 3.9 4.0 5.0 2.2] 0.3)
    assert false (has_close_elements [1.0 2.0 3.9 4.0 5.0 2.2] 0.05)
    assert true (has_close_elements [1.0 2.0 5.9 4.0 5.0] 0.95)
    assert false (has_close_elements [1.0 2.0 5.9 4.0 5.0] 0.8)
    assert true (has_close_elements [1.0 2.0 3.0 4.0 5.0 2.0] 0.1)
    assert true (has_close_elements [1.1 2.2 3.1 4.1 5.1] 1.0)
    assert false (has_close_elements [1.1 2.2 3.1 4.1 5.1] 0.5)
end

func abs:num x:num
    if x < 0
        return -x
    end
    return x
end
fails := 0
total := 0
func assert want:any got:any
    total = total + 1
    if want != got
        fails = fails + 1
        printf ""want != got: want %v got %v\n"" want got
    end
end
func finished
    printf ""%v of %v tests passed\n"" (total - fails) total
end
check
finished
",
HumanEval_33_convert.evy,"func sort_thirdl:list
    //""This function takes a list l and returns a list l' such that
    //    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal
    //    to the values of the corresponding indicies of l, but sorted.
    //    >>> sort_third([1, 2, 3])
    //    [1, 2, 3]
    //    >>> sort_third([5, 6, 3, 4, 8, 9, 2])
    //    [2, 6, 3, 4, 8, 9, 5]
    //    ""
    l := .list (l)
    l[0:] := .sorted (l[0:])
    return l

end
METADATA := {}
func checkcandidate
    assert .tuple (.candidate ([1 2 3 ])) == .tuple (.sort_third ([1 2 3 ]))
    assert .tuple (.candidate ([5 3 -5 2 -3 3 9 0 123 1 -10 ])) == .tuple (.sort_third ([5 3 -5 2 -3 3 9 0 123 1 -10 ]))
    assert .tuple (.candidate ([5 8 -12 4 23 2 3 11 12 -10 ])) == .tuple (.sort_third ([5 8 -12 4 23 2 3 11 12 -10 ]))
    assert .tuple (.candidate ([5 6 3 4 8 9 2 ])) == .tuple ([2 6 3 4 8 9 5 ])
    assert .tuple (.candidate ([5 8 3 4 6 9 2 ])) == .tuple ([2 8 3 4 6 9 5 ])
    assert .tuple (.candidate ([5 6 9 4 8 3 2 ])) == .tuple ([2 6 9 4 8 3 5 ])
    assert .tuple (.candidate ([5 6 3 4 8 9 2 1 ])) == .tuple ([2 6 3 4 8 9 5 1 ])

end
.check (sort_third)",
HumanEval_131_convert.evy,"func digitsn
    //""Given a positive integer n, return the product of the odd digits.
    //    Return 0 if all digits are even.
    //    For example:
    //    digits(1)  == 1
    //    digits(4)  == 0
    //    digits(235) == 15
    //    ""
    product := 1
    odd_count := 0
        int_digit := .int (digit)
        if int_digit % 2 == 1
            product = product * int_digit
            odd_count = odd_count + 1
        end
    end
    if odd_count == 0
        return 0
        product
    else
        return product
    end

end
func checkcandidate
    assert .candidate (5) == 5
    assert .candidate (54) == 5
    assert .candidate (120) == 1
    assert .candidate (5014) == 5
    assert .candidate (98765) == 315
    assert .candidate (5576543) == 2625
    assert .candidate (2468) == 0

end
.check (digits)",
HumanEval_6_convert.evy,"func parse_nested_parens:[]int paren_string:string
    //"" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
    //    For each of the group, output the deepest level of nesting of parentheses.
    //    E.g. (()()) has maximum two levels of nesting while ((())) has three.
    //
    //    >>> parse_nested_parens('(()()) ((())) () ((())()())')
    //    [2, 3, 1, 3]
    //    ""
    func parse_paren_groups
        depth := 0
        max_depth := 0
            if c == ""(""
                depth = depth + 1
                max_depth = .max (depth max_depth)
                1
            else
                depth = depth - 1
            end
        end
        return max_depth
    
    end
    return __evy_listcomp_ := []
    for x := paren_string.split ("" ""):
    if x

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate (""(()()) ((())) () ((())()())"") == [2 3 1 3 ]
    assert .candidate (""() (()) ((())) (((())))"") == [1 2 3 4 ]
    assert .candidate (""(()(())((())))"") == [4 ]

end
.check (parse_nested_parens)",
HumanEval_141_convert.evy,"func file_name_checkfile_name
    //""Create a function which takes a string representing a file's name, and returns
    //    'Yes' if the the file's name is valid, and returns 'No' otherwise.
    //    A file's name is considered to be valid if and only if all the following conditions 
    //    are met:
    //    - There should not be more than three digits ('0'-'9') in the file's name.
    //    - The file's name contains exactly one dot '.'
    //    - The substring before the dot should not be empty, and it starts with a letter from 
    //    the latin alphapet ('a'-'z' and 'A'-'Z').
    //    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
    //    Examples:
    //    file_name_check(""example.txt"") # => 'Yes'
    //    file_name_check(""1example.dll"") # => 'No' (the name should start with a latin alphapet letter)
    //    ""
    suf := [""txt"" ""exe"" ""dll"" ]
    lst := file_name.split ()
    if .len (lst) != 2
        return ""No""
    end
    if !(has suf lst1)
        return ""No""
    end
    if .len (lst0) == 0
        return ""No""
    end
    if !lst00.isalpha ()
        return ""No""
    end
    t := .len (__evy_listcomp_ := []
    for x := lst0:
    if x.isdigit ()
    )
    if t > 3
        return ""No""
    end
    return ""Yes""

end
func checkcandidate
    assert .candidate (""example.txt"") == ""Yes""
    assert .candidate (""1example.dll"") == ""No""
    assert .candidate (""s1sdf3.asd"") == ""No""
    assert .candidate (""K.dll"") == ""Yes""
    assert .candidate (""MY16FILE3.exe"") == ""Yes""
    assert .candidate (""His12FILE94.exe"") == ""No""
    assert .candidate (""_Y.txt"") == ""No""
    assert .candidate (""?aREYA.exe"") == ""No""
    assert .candidate (""/this_is_valid.dll"") == ""No""
    assert .candidate (""this_is_valid.wow"") == ""No""
    assert .candidate (""this_is_valid.txt"") == ""Yes""
    assert .candidate (""this_is_valid.txtexe"") == ""No""
    assert .candidate (""#this2_i4s_5valid.ten"") == ""No""
    assert .candidate (""@this1_is6_valid.exe"") == ""No""
    assert .candidate (""this_is_12valid.6exe4.txt"") == ""No""
    assert .candidate (""all.exe.txt"") == ""No""
    assert .candidate (""I563_No.exe"") == ""Yes""
    assert .candidate (""Is3youfault.txt"") == ""Yes""
    assert .candidate (""no_one#knows.dll"") == ""Yes""
    assert .candidate (""1I563_Yes3.exe"") == ""No""
    assert .candidate (""I563_Yes3.txtt"") == ""No""
    assert .candidate (""final..txt"") == ""No""
    assert .candidate (""final132"") == ""No""
    assert .candidate (""_f4indsartal132."") == ""No""
    assert .candidate ("".txt"") == ""No""
    assert .candidate (""s."") == ""No""

end
.check (file_name_check)",
HumanEval_43_convert.evy,"func pairs_sum_to_zerol
    //""
    //    pairs_sum_to_zero takes a list of integers as an input.
    //    it returns True if there are two distinct elements in the list that
    //    sum to zero, and False otherwise.
    //    >>> pairs_sum_to_zero([1, 3, 5, 0])
    //    False
    //    >>> pairs_sum_to_zero([1, 3, -2, 1])
    //    False
    //    >>> pairs_sum_to_zero([1, 2, 3, 7])
    //    False
    //    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])
    //    True
    //    >>> pairs_sum_to_zero([1])
    //    False
    //    ""
    for i := range l
        l1 = l[i]
            if l1 + lj == 0
                return true
            end
        end
    end
    return false

end
METADATA := {}
func checkcandidate
    assert .candidate ([1 3 5 0 ]) == false
    assert .candidate ([1 3 -2 1 ]) == false
    assert .candidate ([1 2 3 7 ]) == false
    assert .candidate ([2 4 -5 3 5 7 ]) == true
    assert .candidate ([1 ]) == false
    assert .candidate ([-3 9 -1 3 2 30 ]) == true
    assert .candidate ([-3 9 -1 3 2 31 ]) == true
    assert .candidate ([-3 9 -1 4 2 30 ]) == false
    assert .candidate ([-3 9 -1 4 2 31 ]) == false

end
.check (pairs_sum_to_zero)",
HumanEval_30_convert.evy,"func get_positivel:list
    //""Return only positive numbers in the list.
    //    >>> get_positive([-1, 2, -4, 5, 6])
    //    [2, 5, 6]
    //    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    //    [5, 3, 2, 3, 9, 123, 1]
    //    ""
    return __evy_listcomp_ := []
    for e := l:
    if e > 0

end
METADATA := {}
func checkcandidate
    assert .candidate ([-1 -2 4 5 6 ]) == [4 5 6 ]
    assert .candidate ([5 3 -5 2 3 3 9 0 123 1 -10 ]) == [5 3 2 3 3 9 123 1 ]
    assert .candidate ([-1 -2 ]) == []
    assert .candidate ([]) == []

end
.check (get_positive)",
HumanEval_132_convert.evy,,
HumanEval_5_convert.evy,"func intersperse:[]int numbers:[]int delimeter:int
    //"" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'
    //    >>> intersperse([], 4)
    //    []
    //    >>> intersperse([1, 2, 3], 4)
    //    [1, 4, 2, 4, 3]
    //    ""
    if !numbers
        return []
    end
    result := []
        result = result + [n]
        result = result + [delimeter]
    end
    result = result + [numbers-1]
    return result

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate ([] 7) == []
    assert .candidate ([5 6 3 2 ] 8) == [5 8 6 8 3 8 2 ]
    assert .candidate ([2 2 2 ] 2) == [2 2 2 2 2 ]

end
.check (intersperse)",
HumanEval_142_convert.evy,"func sum_squareslst
    //""""
    //    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a 
    //    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not 
    //    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. 
    //    
    //    Examples:
    //    For lst = [1,2,3] the output should be 6
    //    For lst = []  the output should be 0
    //    For lst = [-1,-5,2,-1,-5]  the output should be -126
    //    ""
    result := []
        if i % 3 == 0
            result = result + [pow lsti 2]
        else if i % 4 == 0 i % 3 != 0 and
            result = result + [pow lsti 3]
        else
            if i % 4 == 0 i % 3 != 0 and
                result = result + [pow lsti 3]
                result = result + [lsti]
            else
                result = result + [lsti]
            end
        end
    end
    return .sum (result)

end
func checkcandidate
    assert .candidate ([1 2 3 ]) == 6
    assert .candidate ([1 4 9 ]) == 14
    assert .candidate ([]) == 0
    assert .candidate ([1 1 1 1 1 1 1 1 1 ]) == 9
    assert .candidate ([-1 -1 -1 -1 -1 -1 -1 -1 -1 ]) == -3
    assert .candidate ([0 ]) == 0
    assert .candidate ([-1 -5 2 -1 -5 ]) == -126
    assert .candidate ([-56 -99 1 0 -2 ]) == 3030
    assert .candidate ([-1 0 0 0 0 0 0 0 -1 ]) == 0
    assert .candidate ([-16 -9 -2 36 36 26 -20 25 -40 20 -4 12 -26 35 37 ]) == -14196
    assert .candidate ([-1 -3 17 -1 -15 13 -1 14 -14 -12 -5 14 -14 6 13 11 16 16 4 10 ]) == -1448

end
.check (sum_squares)",
HumanEval_40_convert.evy,"func triples_sum_to_zerol:list
    //""
    //    triples_sum_to_zero takes a list of integers as an input.
    //    it returns True if there are three distinct elements in the list that
    //    sum to zero, and False otherwise.
    //
    //    >>> triples_sum_to_zero([1, 3, 5, 0])
    //    False
    //    >>> triples_sum_to_zero([1, 3, -2, 1])
    //    True
    //    >>> triples_sum_to_zero([1, 2, 3, 7])
    //    False
    //    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])
    //    True
    //    >>> triples_sum_to_zero([1])
    //    False
    //    ""
                if li + lj + lk == 0
                    return true
                end
            end
        end
    end
    return false

end
METADATA := {}
func checkcandidate
    assert .candidate ([1 3 5 0 ]) == false
    assert .candidate ([1 3 5 -1 ]) == false
    assert .candidate ([1 3 -2 1 ]) == true
    assert .candidate ([1 2 3 7 ]) == false
    assert .candidate ([1 2 5 7 ]) == false
    assert .candidate ([2 4 -5 3 9 7 ]) == true
    assert .candidate ([1 ]) == false
    assert .candidate ([1 3 5 -100 ]) == false
    assert .candidate ([100 3 5 -100 ]) == false

end
.check (triples_sum_to_zero)",
HumanEval_93_convert.evy,"func encodemessage
    //""
    //    Write a function that takes a message, and encodes in such a 
    //    way that it swaps case of all letters, replaces all vowels in 
    //    the message with the letter that appears 2 places ahead of that 
    //    vowel in the english alphabet. 
    //    Assume only letters. 
    //    
    //    Examples:
    //    >>> encode('test')
    //    'TGST'
    //    >>> encode('This is a message')
    //    'tHKS KS C MGSSCGG'
    //    ""
    vowels := ""aeiouAEIOU""
    vowels_replace := .dict (__evy_listcomp_ := []
    for i := vowels:
    )
    message := message.swapcase ()
    return (join __evy_listcomp_ := []
    for i := message:
    if (has vowels i)
    __evy_listcomp_ = vowels_replacei
    else 
       __evy_listcomp_ = i
    end
     """")

end
func checkcandidate
    assert .candidate (""TEST"") == ""tgst""
    assert .candidate (""Mudasir"") == ""mWDCSKR""
    assert .candidate (""YES"") == ""ygs""
    assert .candidate (""This is a message"") == ""tHKS KS C MGSSCGG""
    assert .candidate (""I DoNt KnOw WhAt tO WrItE"") == ""k dQnT kNqW wHcT Tq wRkTg""

end
.check (encode)",
HumanEval_72_convert.evy,,
HumanEval_100_convert.evy,"func make_a_pilen
    //""
    //    Given a positive integer n, you have to make a pile of n levels of stones.
    //    The first level has n stones.
    //    The number of stones in the next level is:
    //        - the next odd number if n is odd.
    //        - the next even number if n is even.
    //    Return the number of stones in each level in a list, where element at index
    //    i represents the number of stones in the level (i+1).
    //
    //    Examples:
    //    >>> make_a_pile(3)
    //    [3, 5, 7]
    //    ""
    return __evy_listcomp_ := []
    for i := .range (n):

end
func checkcandidate
    assert .candidate (3) == [3 5 7 ]
    assert .candidate (4) == [4 6 8 10 ]
    assert .candidate (5) == [5 7 9 11 13 ]
    assert .candidate (6) == [6 8 10 12 14 16 ]
    assert .candidate (8) == [8 10 12 14 16 18 20 22 ]
    assert true

end
.check (make_a_pile)",
HumanEval_49_convert.evy,"func modpn:int p:int
    //""Return 2^n modulo p (be aware of numerics).
    //    >>> modp(3, 5)
    //    3
    //    >>> modp(1101, 101)
    //    2
    //    >>> modp(0, 101)
    //    1
    //    >>> modp(3, 11)
    //    8
    //    >>> modp(100, 101)
    //    1
    //    ""
    ret := 1
        ret = 2 * ret % p
    end
    return ret

end
METADATA := {}
func checkcandidate
    assert .candidate (3 5) == 3
    assert .candidate (1101 101) == 2
    assert .candidate (0 101) == 1
    assert .candidate (3 11) == 8
    assert .candidate (100 101) == 1
    assert .candidate (30 5) == 4
    assert .candidate (31 5) == 3

end
.check (modp)",
HumanEval_39_convert.evy,,
HumanEval_67_convert.evy,"func fruit_distributions n
    //""
    //    In this task, you will be given a string that represents a number of apples and oranges 
    //    that are distributed in a basket of fruit this basket contains 
    //    apples, oranges, and mango fruits. Given the string that represents the total number of 
    //    the oranges and apples and an integer that represent the total number of the fruits 
    //    in the basket return the number of the mango fruits in the basket.
    //    for examble:
    //    fruit_distribution(""5 apples and 6 oranges"", 19) ->19 - 5 - 6 = 8
    //    fruit_distribution(""0 apples and 1 oranges"",3) -> 3 - 0 - 1 = 2
    //    fruit_distribution(""2 apples and 3 oranges"", 100) -> 100 - 2 - 3 = 95
    //    fruit_distribution(""100 apples and 1 oranges"",120) -> 120 - 100 - 1 = 19
    //    ""
    lis := .list ()
        if i.isdigit ()
            lis = lis + [.int (i)]
        end
    end
    return n - .sum (lis)

end
func checkcandidate
    assert .candidate (""5 apples and 6 oranges"" 19) == 8
    assert .candidate (""5 apples and 6 oranges"" 21) == 10
    assert .candidate (""0 apples and 1 oranges"" 3) == 2
    assert .candidate (""1 apples and 0 oranges"" 3) == 2
    assert .candidate (""2 apples and 3 oranges"" 100) == 95
    assert .candidate (""2 apples and 3 oranges"" 5) == 0
    assert .candidate (""1 apples and 100 oranges"" 120) == 19

end
.check (fruit_distribution)",
HumanEval_115_convert.evy,"func max_fillgrid capacity
    
    //""
    //    You are given a rectangular grid of wells. Each row represents a single well,
    //    and each 1 in a row represents a single unit of water.
    //    Each well has a corresponding bucket that can be used to extract water from it, 
    //    and all buckets have the same capacity.
    //    Your task is to use the buckets to empty the wells.
    //    Output the number of times you need to lower the buckets.
    //
    //    Example 1:
    //        Input: 
    //            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]
    //            bucket_capacity : 1
    //        Output: 6
    //
    //    Example 2:
    //        Input: 
    //            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]
    //            bucket_capacity : 2
    //        Output: 5
    //    
    //    Example 3:
    //        Input: 
    //            grid : [[0,0,0], [0,0,0]]
    //            bucket_capacity : 5
    //        Output: 0
    //
    //    Constraints:
    //        * all wells have the same length
    //        * 1 <= grid.length <= 10^2
    //        * 1 <= grid[:,1].length <= 10^2
    //        * grid[i][j] -> 0 | 1
    //        * 1 <= capacity <= 10
    //    ""
    return .sum (__evy_listcomp_ := []
    for arr := grid:
    )

end
func checkcandidate
    assert true
    assert .candidate ([[0 0 1 0 ] [0 1 0 0 ] [1 1 1 1 ] ] 1) == 6
    assert .candidate ([[0 0 1 1 ] [0 0 0 0 ] [1 1 1 1 ] [0 1 1 1 ] ] 2) == 5
    assert .candidate ([[0 0 0 ] [0 0 0 ] ] 5) == 0
    assert true
    assert .candidate ([[1 1 1 1 ] [1 1 1 1 ] ] 2) == 4
    assert .candidate ([[1 1 1 1 ] [1 1 1 1 ] ] 9) == 2

end
.check (max_fill)",
HumanEval_17_convert.evy,"func parse_music:[]int music_string:string
    //"" Input to this function is a string representing musical notes in a special ASCII format.
    //    Your task is to parse this string and return list of integers corresponding to how many beats does each
    //    not last.
    //
    //    Here is a legend:
    //    'o' - whole note, lasts four beats
    //    'o|' - half note, lasts two beats
    //    '.|' - quater note, lasts one beat
    //
    //    >>> parse_music('o o| .| o| o| .| .| .| .| o o')
    //    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
    //    ""
    note_map := {""o"":4 ""o|"":2 "".|"":1}
    return __evy_listcomp_ := []
    for x := music_string.split ("" ""):
    if x

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate ("""") == []
    assert .candidate (""o o o o"") == [4 4 4 4 ]
    assert .candidate ("".| .| .| .|"") == [1 1 1 1 ]
    assert .candidate (""o| o| .| .| o o o o"") == [2 2 1 1 4 4 4 4 ]
    assert .candidate (""o| .| o| .| o o| o o|"") == [2 1 2 1 4 2 4 2 ]

end
.check (parse_music)",
HumanEval_109_convert.evy,"func move_one_ballarr
    //""We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The
    //    numbers in the array will be randomly ordered. Your task is to determine if
    //    it is possible to get an array sorted in non-decreasing order by performing 
    //    the following operation on the given array:
    //        You are allowed to perform right shift operation any number of times.
    //    
    //    One right shift operation means shifting all elements of the array by one
    //    position in the right direction. The last element of the array will be moved to
    //    the starting position in the array i.e. 0th index. 
    //
    //    If it is possible to obtain the sorted array by performing the above operation
    //    then return True else return False.
    //    If the given array is empty then return True.
    //
    //    Note: The given list is guaranteed to have unique elements.
    //
    //    For Example:
    //    
    //    move_one_ball([3, 4, 5, 1, 2])==>True
    //    Explanation: By performin 2 right shift operations, non-decreasing order can
    //                 be achieved for the given array.
    //    move_one_ball([3, 5, 4, 1, 2])==>False
    //    Explanation:It is not possible to get non-decreasing order for the given
    //                array by performing any number of right shift operations.
    //                
    //    ""
    if .len (arr) == 0
        return true
    end
    sorted_array := .sorted (arr)
    my_arr := []
    min_value := .min (arr)
    min_index := arr.index (min_value)
    my_arr = arr[min_index:] + arr[0:min_index]
        if my_arri != sorted_arrayi
            return false
        end
    end
    return true

end
func checkcandidate
    assert .candidate ([3 4 5 1 2 ]) == true
    assert .candidate ([3 5 10 1 2 ]) == true
    assert .candidate ([4 3 1 2 ]) == false
    assert .candidate ([3 5 4 1 2 ]) == false
    assert .candidate ([]) == true

end
.check (move_one_ball)",
HumanEval_86_convert.evy,"func anti_shuffles
    //""
    //    Write a function that takes a string and returns an ordered version of it.
    //    Ordered version of string, is a string where all words (separated by space)
    //    are replaced by a new word where all the characters arranged in
    //    ascending order based on ascii value.
    //    Note: You should keep the order of words and blank spaces in the sentence.
    //
    //    For example:
    //    anti_shuffle('Hi') returns 'Hi'
    //    anti_shuffle('hello') returns 'ehllo'
    //    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'
    //    ""
    return (join __evy_listcomp_ := []
    for i := s.split ("" ""):
     "" "")

end
func checkcandidate
    assert .candidate (""Hi"") == ""Hi""
    assert .candidate (""hello"") == ""ehllo""
    assert .candidate (""number"") == ""bemnru""
    assert .candidate (""abcd"") == ""abcd""
    assert .candidate (""Hello World!!!"") == ""Hello !!!Wdlor""
    assert .candidate ("""") == """"
    assert .candidate (""Hi. My name is Mister Robot. How are you?"") == "".Hi My aemn is Meirst .Rboot How aer ?ouy""
    assert true

end
.check (anti_shuffle)",
HumanEval_25_convert.evy,"func factorize:[]int n:int
    //"" Return list of prime factors of given integer in the order from smallest to largest.
    //    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
    //    Input number should be equal to the product of all factors
    //    >>> factorize(8)
    //    [2, 2, 2]
    //    >>> factorize(25)
    //    [5, 5]
    //    >>> factorize(70)
    //    [2, 5, 7]
    //    ""
    
    fact := []
    i := 2
    while i <= .int (math.sqrt (n) + 1)
        if n % i == 0
            fact = fact + [i]
            n = n None i
            1
        else
            i = i + 1
        end
    end
    if n > 1
        fact = fact + [n]
    end
    return fact

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate (2) == [2 ]
    assert .candidate (4) == [2 2 ]
    assert .candidate (8) == [2 2 2 ]
    assert .candidate (3 * 19) == [3 19 ]
    assert .candidate (3 * 19 * 3 * 19) == [3 3 19 19 ]
    assert .candidate (3 * 19 * 3 * 19 * 3 * 19) == [3 3 3 19 19 19 ]
    assert .candidate (3 * 19 * 19 * 19) == [3 19 19 19 ]
    assert .candidate (3 * 2 * 3) == [2 3 3 ]

end
.check (factorize)",
HumanEval_127_convert.evy,"func intersectioninterval1 interval2
    //""You are given two intervals,
    //    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
    //    The given intervals are closed which means that the interval (start, end)
    //    includes both start and end.
    //    For each given interval, it is assumed that its start is less or equal its end.
    //    Your task is to determine whether the length of intersection of these two 
    //    intervals is a prime number.
    //    Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
    //    which its length is 1, which not a prime number.
    //    If the length of the intersection is a prime number, return ""YES"",
    //    otherwise, return ""NO"".
    //    If the two intervals don't intersect, return ""NO"".
    //
    //
    //    [input/output] samples:
    //    intersection((1, 2), (2, 3)) ==> ""NO""
    //    intersection((-1, 1), (0, 4)) ==> ""NO""
    //    intersection((-3, -1), (-5, 5)) ==> ""YES""
    //    ""
    func is_primenum
        if num_ == 1 num_ == 0 or
            return false
        end
        if num_ == 2
            return true
        end
            if num_ % i == 0
                return false
            end
        end
        return true
    
    end
    l := .max (interval10 interval20)
    r := .min (interval11 interval21)
    length := r - l
    if length > 0 .is_prime (length) and
        return ""YES""
    end
    return ""NO""

end
func checkcandidate
    assert .candidate ([1 2 ] [2 3 ]) == ""NO""
    assert .candidate ([-1 1 ] [0 4 ]) == ""NO""
    assert .candidate ([-3 -1 ] [-5 5 ]) == ""YES""
    assert .candidate ([-2 2 ] [-4 0 ]) == ""YES""
    assert .candidate ([-11 2 ] [-1 -1 ]) == ""NO""
    assert .candidate ([1 2 ] [3 5 ]) == ""NO""
    assert .candidate ([1 2 ] [1 2 ]) == ""NO""
    assert .candidate ([-2 -2 ] [-3 -2 ]) == ""NO""

end
.check (intersection)",
HumanEval_157_convert.evy,"func right_angle_trianglea b c
    //""
    //    Given the lengths of the three sides of a triangle. Return True if the three
    //    sides form a right-angled triangle, False otherwise.
    //    A right-angled triangle is a triangle in which one angle is right angle or 
    //    90 degree.
    //    Example:
    //    right_angle_triangle(3, 4, 5) == True
    //    right_angle_triangle(1, 2, 3) == False
    //    ""
    return a * a == b * b + c * c b * b == a * a + c * c c * c == a * a + b * b or

end
func checkcandidate
    assert .candidate (3 4 5) == true
    assert .candidate (1 2 3) == false
    assert .candidate (10 6 8) == true
    assert .candidate (2 2 2) == false
    assert .candidate (7 24 25) == true
    assert .candidate (10 5 7) == false
    assert .candidate (5 12 13) == true
    assert .candidate (15 8 17) == true
    assert .candidate (48 55 73) == true
    assert .candidate (1 1 1) == false
    assert .candidate (2 2 10) == false

end
.check (right_angle_triangle)",
HumanEval_55_convert.evy,"func fibn:int
    //""Return n-th Fibonacci number.
    //    >>> fib(10)
    //    55
    //    >>> fib(1)
    //    1
    //    >>> fib(8)
    //    21
    //    ""
    if n == 0
        return 0
    end
    if n == 1
        return 1
    end
    return .fib (n - 1) + .fib (n - 2)

end
METADATA := {}
func checkcandidate
    assert .candidate (10) == 55
    assert .candidate (1) == 1
    assert .candidate (8) == 21
    assert .candidate (11) == 89
    assert .candidate (12) == 144

end
.check (fib)",
HumanEval_12_convert.evy,,
HumanEval_110_convert.evy,"func exchangelst1 lst2
    //""In this problem, you will implement a function that takes two lists of numbers,
    //    and determines whether it is possible to perform an exchange of elements
    //    between them to make lst1 a list of only even numbers.
    //    There is no limit on the number of exchanged elements between lst1 and lst2.
    //    If it is possible to exchange elements between the lst1 and lst2 to make
    //    all the elements of lst1 to be even, return ""YES"".
    //    Otherwise, return ""NO"".
    //    For example:
    //    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => ""YES""
    //    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => ""NO""
    //    It is assumed that the input lists will be non-empty.
    //    ""
    odd := 0
    even := 0
        if i % 2 == 1
            odd = odd + 1
        end
    end
        if i % 2 == 0
            even = even + 1
        end
    end
    if even >= odd
        return ""YES""
    end
    return ""NO""

end
func checkcandidate
    assert .candidate ([1 2 3 4 ] [1 2 3 4 ]) == ""YES""
    assert .candidate ([1 2 3 4 ] [1 5 3 4 ]) == ""NO""
    assert .candidate ([1 2 3 4 ] [2 1 4 3 ]) == ""YES""
    assert .candidate ([5 7 3 ] [2 6 4 ]) == ""YES""
    assert .candidate ([5 7 3 ] [2 6 3 ]) == ""NO""
    assert .candidate ([3 2 6 1 8 9 ] [3 5 5 1 1 1 ]) == ""NO""
    assert .candidate ([100 200 ] [200 200 ]) == ""YES""

end
.check (exchange)",
HumanEval_160_convert.evy,"func do_algebraoperator operand
    //""
    //    Given two lists operator, and operand. The first list has basic algebra operations, and 
    //    the second list is a list of integers. Use the two given lists to build the algebric 
    //    expression and return the evaluation of this expression.
    //
    //    The basic algebra operations:
    //    Addition ( + ) 
    //    Subtraction ( - ) 
    //    Multiplication ( * ) 
    //    Floor division ( // ) 
    //    Exponentiation ( ** ) 
    //
    //    Example:
    //    operator['+', '*', '-']
    //    array = [2, 3, 4, 5]
    //    result = 2 + 3 * 4 - 5
    //    => result = 9
    //
    //    Note:
    //        The length of operator list is equal to the length of operand list minus one.
    //        Operand is a list of of non-negative integers.
    //        Operator list has at least one operator, and operand list has at least two operands.
    //
    //    ""
    expression := .str (operand0)
        expression = expression + oprt + .str (oprn)
    end
    return .eval (expression)

end
func checkcandidate
    assert .candidate ([""**"" ""*"" ""+"" ] [2 3 4 5 ]) == 37
    assert .candidate ([""+"" ""*"" ""-"" ] [2 3 4 5 ]) == 9
    assert .candidate ([""//"" ""*"" ] [7 3 4 ]) == 8
    assert true

end
.check (do_algebra)",
HumanEval_62_convert.evy,"func derivativexs:list
    //"" xs represent coefficients of a polynomial.
    //    xs[0] + xs[1] * x + xs[2] * x^2 + ....
    //     Return derivative of this polynomial in the same form.
    //    >>> derivative([3, 1, 2, 4, 5])
    //    [1, 4, 12, 20]
    //    >>> derivative([1, 2, 3])
    //    [2, 6]
    //    ""
    return __evy_listcomp_ := []
    for [i x ] := .enumerate (xs):
    [1:]

end
METADATA := {}
func checkcandidate
    assert .candidate ([3 1 2 4 5 ]) == [1 4 12 20 ]
    assert .candidate ([1 2 3 ]) == [2 6 ]
    assert .candidate ([3 2 1 ]) == [2 2 ]
    assert .candidate ([3 2 1 0 4 ]) == [2 2 0 16 ]
    assert .candidate ([1 ]) == []

end
.check (derivative)",
HumanEval_9_convert.evy,,
HumanEval_50_convert.evy,,
HumanEval_152_convert.evy,"func comparegame guess
    //""I think we all remember that feeling when the result of some long-awaited
    //    event is finally known. The feelings and thoughts you have at that moment are
    //    definitely worth noting down and comparing.
    //    Your task is to determine if a person correctly guessed the results of a number of matches.
    //    You are given two arrays of scores and guesses of equal length, where each index shows a match. 
    //    Return an array of the same length denoting how far off each guess was. If they have guessed correctly,
    //    the value is 0, and if not, the value is the absolute difference between the guess and the score.
    //    
    //    
    //    example:
    //
    //    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]
    //    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]
    //    ""
    return __evy_listcomp_ := []
    for [x y ] := .zip (game guess):

end
func checkcandidate
    assert .candidate ([1 2 3 4 5 1 ] [1 2 3 4 2 -2 ]) == [0 0 0 0 3 3 ]
    assert .candidate ([0 0 0 0 0 0 ] [0 0 0 0 0 0 ]) == [0 0 0 0 0 0 ]
    assert .candidate ([1 2 3 ] [-1 -2 -3 ]) == [2 4 6 ]
    assert .candidate ([1 2 3 5 ] [-1 2 3 4 ]) == [2 0 0 1 ]
    assert true

end
.check (compare)",
HumanEval_122_convert.evy,,
HumanEval_20_convert.evy,,
HumanEval_83_convert.evy,"func starts_one_endsn
    //""
    //    Given a positive integer n, return the count of the numbers of n-digit
    //    positive integers that start or end with 1.
    //    ""
    if n == 1
        return 1
    end
    return 18 * pow 10 n - 2

end
func checkcandidate
    assert true
    assert .candidate (1) == 1
    assert .candidate (2) == 18
    assert .candidate (3) == 180
    assert .candidate (4) == 1800
    assert .candidate (5) == 18000
    assert true

end
.check (starts_one_ends)",
HumanEval_96_convert.evy,,
HumanEval_119_convert.evy,,
HumanEval_45_convert.evy,"func triangle_areaa h
    //""Given length of a side and high return area for a triangle.
    //    >>> triangle_area(5, 3)
    //    7.5
    //    ""
    return a * h / 2.0

end
METADATA := {}
func checkcandidate
    assert .candidate (5 3) == 7.5
    assert .candidate (2 2) == 2.0
    assert .candidate (10 8) == 40.0

end
.check (triangle_area)",
HumanEval_147_convert.evy,"func get_max_triplesn
    //""
    //    You are given a positive integer n. You have to create an integer array a of length n.
    //        For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
    //        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
    //    and a[i] + a[j] + a[k] is a multiple of 3.
    //
    //    Example :
    //        Input: n = 5
    //        Output: 1
    //        Explanation: 
    //        a = [1, 3, 7, 13, 21]
    //        The only valid triple is (1, 7, 13).
    //    ""
    A := __evy_listcomp_ := []
    for i := .range (1 n + 1):
    ans := []
                if Ai + Aj + Ak % 3 == 0
                    ans = ans + [[Ai Aj Ak ] ]
                end
            end
        end
    end
    return .len (ans)

end
func checkcandidate
    assert .candidate (5) == 1
    assert .candidate (6) == 4
    assert .candidate (10) == 36
    assert .candidate (100) == 53361

end
.check (get_max_triples)",
HumanEval_137_convert.evy,,
HumanEval_35_convert.evy,"func max_elementl:list
    //""Return maximum element in the list.
    //    >>> max_element([1, 2, 3])
    //    3
    //    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    //    123
    //    ""
    m := l0
        if e > m
            m = e
        end
    end
    return m

end
METADATA := {}
func checkcandidate
    assert .candidate ([1 2 3 ]) == 3
    assert .candidate ([5 3 -5 2 -3 3 9 0 124 1 -10 ]) == 124

end
.check (max_element)",
HumanEval_0_convert.evy,"func has_close_elements:bool numbers:[]float threshold:float
    //"" Check if in given list of numbers, are any two numbers closer to each other than
    //    given threshold.
    //    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)
    //    False
    //    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
    //    True
    //    ""
    for idx := range numbers
        elem = numbers[idx]
        for idx2 := range numbers
            elem2 = numbers[idx2]
            if idx != idx2
                distance := .abs (elem - elem2)
                if distance < threshold
                    return true
                end
            end
        end
    end
    return false

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate ([1.0 2.0 3.9 4.0 5.0 2.2 ] 0.3) == true
    assert .candidate ([1.0 2.0 3.9 4.0 5.0 2.2 ] 0.05) == false
    assert .candidate ([1.0 2.0 5.9 4.0 5.0 ] 0.95) == true
    assert .candidate ([1.0 2.0 5.9 4.0 5.0 ] 0.8) == false
    assert .candidate ([1.0 2.0 3.0 4.0 5.0 2.0 ] 0.1) == true
    assert .candidate ([1.1 2.2 3.1 4.1 5.1 ] 1.0) == true
    assert .candidate ([1.1 2.2 3.1 4.1 5.1 ] 0.5) == false

end
.check (has_close_elements)",
HumanEval_29_convert.evy,"func filter_by_prefix:[]string strings:[]string prefix:string
    //"" Filter an input list of strings only for ones that start with a given prefix.
    //    >>> filter_by_prefix([], 'a')
    //    []
    //    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')
    //    ['abc', 'array']
    //    ""
    return __evy_listcomp_ := []
    for x := strings:
    if x.startswith (prefix)

end
METADATA := {""author"":""jt"" ""dataset"":""test""}
func checkcandidate
    assert .candidate ([] ""john"") == []
    assert .candidate ([""xxx"" ""asd"" ""xxy"" ""john doe"" ""xxxAAA"" ""xxx"" ] ""xxx"") == [""xxx"" ""xxxAAA"" ""xxx"" ]

end
.check (filter_by_prefix)",
HumanEval_59_convert.evy,"func largest_prime_factorn:int
    //""Return the largest prime factor of n. Assume n > 1 and is not a prime.
    //    >>> largest_prime_factor(13195)
    //    29
    //    >>> largest_prime_factor(2048)
    //    2
    //    ""
    func is_primek
        if k < 2
            return false
        end
            if k % i == 0
                return false
            end
        end
        return true
    
    end
    largest := 1
        if n % j == 0 .is_prime (j) and
            largest = .max (largest j)
        end
    end
    return largest

end
METADATA := {}
func checkcandidate
    assert .candidate (15) == 5
    assert .candidate (27) == 3
    assert .candidate (63) == 7
    assert .candidate (330) == 11
    assert .candidate (13195) == 29

end
.check (largest_prime_factor)",
HumanEval_105_convert.evy,,
HumanEval_77_convert.evy,"func iscubea
    //""
    //    Write a function that takes an integer a and returns True 
    //    if this ingeger is a cube of some integer number.
    //    Note: you may assume the input is always valid.
    //    Examples:
    //    iscube(1) ==> True
    //    iscube(2) ==> False
    //    iscube(-1) ==> True
    //    iscube(64) ==> True
    //    iscube(0) ==> True
    //    iscube(180) ==> False
    //    ""
    a := .abs (a)
    return pow .int (.round (pow a 1.0 / 3)) 3 == a

end
func checkcandidate
    assert .candidate (1) == true
    assert .candidate (2) == false
    assert .candidate (-1) == true
    assert .candidate (64) == true
    assert .candidate (180) == false
    assert .candidate (1000) == true
    assert .candidate (0) == true
    assert .candidate (1729) == false

end
.check (iscube)",
0078-subsets.evy,"// 78. Subsets
// Solved
// Medium
// Topics
// Companies
// Given an integer array nums of unique elements, return all possible
// subsets
// (the power set).
// The solution set must not contain duplicate subsets. Return the solution in any order.
// Example 1:
// Input: nums = [1,2,3]
// Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
// Example 2:
// Input: nums = [0]
// Output: [[],[0]]
// Constraints:
// 1 <= nums.length <= 10
// -10 <= nums[i] <= 10
// All the numbers of nums are unique.

func backtrack nums:[]num current:[]num ans:[][]num
    if (len nums) == 0
        ans = [current[:]] + ans
        return
    end
    for range nums
        backtrack nums[1:] current ans
        current = current + [nums[0]]
        if (len nums) > 1
            backtrack nums[1:] current ans
        else
            backtrack [] current ans
        end
        current = current[:-1]
    end
end

func subsets:[][]num nums:[]num
    current:[]num
    ans:[][]num
    backtrack nums current ans
    return ans
end

fails := 0
total := 0

func assertEqualsameelements want:[][]num got:[][]num
    wantset := {}
    extraelements:[]string
    missingelements:[]string
    failed := false
    for elem := range want
        wantset[sprintf ""%v"" elem] = true
    end
    gotset := {}
    for elem := range got
        gotset[sprintf ""%v"" elem] = true
    end
    for key := range wantset
        if !(has gotset key)
            printf ""missing element int got %v\n"" key
            extraelements = extraelements + [key]
            failed = true
        end
    end
    for key := range gotset
        if !(has wantset key)
            printf ""extra element int got %v\n"" key
            missingelements = missingelements + [key]
            failed = true
        end
    end
    if (len missingelements) > 0
        printf ""missing elements: %v\n"" missingelements
    end
    if (len extraelements) > 0
        printf ""extra elements: %v\n"" extraelements
    end
    if failed
        fails = fails + 1
    end
    total = total + 1
end

func test
    assertEqualsameelements [[1 2 3] [1 2] [1 3] [1] [2 3] [2] [3] []] (subsets [1 2 3])
    assertEqualsameelements [[0] []] (subsets [0])
    assertEqualsameelements [[]] (subsets [])
end
",
0121-best-time-to-buy-and-sell-stock.evy,"// 121. Best Time to Buy and Sell Stock
// Solved
// Easy
// Topics
// Companies
// You are given an array prices where prices[i] is the price of a given stock on the ith day.
// You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.
// Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.
// Example 1:
// Input: prices = [7,1,5,3,6,4]
// Output: 5
// Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
// Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
// Example 2:
// Input: prices = [7,6,4,3,1]
// Output: 0
// Explanation: In this case, no transactions are done and the max profit = 0.
// Constraints:
// 1 <= prices.length <= 105
// 0 <= prices[i] <= 104

func maxProfit:num prices:[]num
    mprofit := 0
    lowest := prices[0]
    for price := range prices
        mprofit = max mprofit (price - lowest)
        lowest = min lowest price
    end
    return mprofit
end



func test
    assertEqual 5 (maxProfit [7 1 5 3 6 4])
    assertEqual 0 (maxProfit [7 6 4 3 1])
end
",
0208-implement-trie-prefix-tree.evy,"// 208. Implement Trie (Prefix Tree)
// Solved
// Medium
// Topics
// Companies
// A trie (pronounced as ""try"") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.
// Implement the Trie class:
// Trie() Initializes the trie object.
// void insert(String word) Inserts the string word into the trie.
// boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.
// boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.
// Example 1:
// Input
// [""Trie"", ""insert"", ""search"", ""search"", ""startsWith"", ""insert"", ""search""]
// [[], [""apple""], [""apple""], [""app""], [""app""], [""app""], [""app""]]
// Output
// [null, null, true, false, true, null, true]
// Explanation
// Trie trie = new Trie();
// trie.insert(""apple"");
// trie.search(""apple"");   // return True
// trie.search(""app"");     // return False
// trie.startsWith(""app""); // return True
// trie.insert(""app"");
// trie.search(""app"");     // return True
// Constraints:
// 1 <= word.length, prefix.length <= 2000
// word and prefix consist only of lowercase English letters.
// At most 3 * 104 calls in total will be made to insert, search, and startsWith.

func Node:{}any
    self:{}any
    self.next = {}
    self.isend = false
    return self
end

func Trie:{}any
    self:{}any
    self.data = (Node)
    return self
end

func insert self:{}any word:string
    node:{}any
    node = self.data.({}any)
    for ch := range word
        next := node.next.({}any)
        if !(has next ch)
            next[ch] = (Node)
        end
        node = next[ch].({}any)
    end
    node.isend = true
end

func search:bool self:{}any word:string
    node:{}any
    node = self.data.({}any)
    for ch := range word
        next := node.next.({}any)
        if !(has next ch)
            return false
        end
        node = next[ch].({}any)
    end
    return node.isend.(bool)
end

func startsWith:bool self:{}any prefix:string
    node:{}any
    node = self.data.({}any)
    for ch := range prefix
        next := node.next.({}any)
        if !(has next ch)
            return false
        end
        node = next[ch].({}any)
    end
    return true
end

func test
    trie := (Trie)
    insert trie ""apple""
    assertEqual true (search trie ""apple"")
    assertEqual false (search trie ""app"")
    assertEqual true (startsWith trie ""app"")
    insert trie ""app""
    assertEqual true (search trie ""app"")
end
",
0001-two-sum.evy,"// 1. Two Sum
// Solved
// Easy
// Topics
// Companies
// Hint
// Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
// You may assume that each input would have exactly one solution, and you may not use the same element twice.
// You can return the answer in any order.
// Example 1:
// Input: nums = [2,7,11,15], target = 9
// Output: [0,1]
// Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
// Example 2:
// Input: nums = [3,2,4], target = 6
// Output: [1,2]
// Example 3:
// Input: nums = [3,3], target = 6
// Output: [0,1]
// Constraints:
// 2 <= nums.length <= 104
// -109 <= nums[i] <= 109
// -109 <= target <= 109
// Only one valid answer exists.
// Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?

func twosum:[]num nums:[]num target:num
    m:{}num
    for i := range (len nums)
        v := nums[i]
        if has m (sprintf ""%v"" (target - v))
            return [m[sprintf ""%v"" (target - v)] i]
        end
        m[sprintf ""%v"" v] = i
    end
    return []
end



func test
    assertEqual [0 1] (twosum [2 7 11 15] 9)
    assertEqual [1 2] (twosum [3 2 4] 6)
    assertEqual [0 1] (twosum [3 3] 6)
end
",
0199-binary-tree-right-side-view.evy,"// 199. Binary Tree Right Side View
// Solved
// Medium
// Topics
// Companies
// Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.
// Example 1:
// Input: root = [1,2,3,null,5,null,4]
// Output: [1,3,4]
// Example 2:
// Input: root = [1,null,3]
// Output: [1,3]
// Example 3:
// Input: root = []
// Output: []
// Constraints:
// The number of nodes in the tree is in the range [0, 100].
// -100 <= Node.val <= 100

func rightSideView:[]any treearr:[]any
    root:any
    root = buildBinaryTree treearr
    queue := []
    res := []
    queue = queue + [root]
    while (len queue) > 0
        size := len queue
        for i := range 0 size
            node:{}any
            node = queue[0].({}any)
            queue = queue[1:]
            if (has node ""val"") and i == size - 1
                res = res + [node[""val""]]
            end
            if (has node ""left"") and node[""left""].({}any) != {}
                queue = queue + [node[""left""]]
            end
            if (has node ""right"") and node[""right""].({}any) != {}
                queue = queue + [node[""right""]]
            end
        end
    end
    return res
end

func buildBinaryTree:{}any tree:[]any
    root:{}any
    rootany:any
    rootany = root
    queue := [rootany]
    for i := range 0 (len tree)
        if (len queue) == 0
            break
        end
        node:{}any
        node = queue[0].({}any)
        queue = queue[1:]
        anynull:any
        anynull = ""null""
        if tree[i] != anynull
            node[""val""] = tree[i]
            node[""left""] = {}
            node[""right""] = {}
            queue = queue + [node[""left""]]
            queue = queue + [node[""right""]]
        end
    end
    return root
end

func test
    assertEqual [1 3 4 """"][:-1] (rightSideView [1 2 3 ""null"" 5 ""null"" 4])
    assertEqual [1 3 """"][:-1] (rightSideView [1 ""null"" 3])
    assertEqual [] (rightSideView [])
    assertEqual [1 3 4 """"][:-1] (rightSideView [1 2 3 4])
end
",
evy-build-binary-tree.evy,"// buildBinaryTree takes a list of strings and returns a binary tree.

func buildBinaryTree:{}any tree:[]any
    root:{}any
    rootany:any
    rootany = root
    queue := [rootany]
    for i := range 0 (len tree)
        if (len queue) == 0
            break
        end
        node:{}any
        node = queue[0].({}any)
        queue = queue[1:]
        anynull:any
        anynull = ""null""
        if tree[i] != anynull
            node[""val""] = tree[i]
            node[""left""] = {}
            node[""right""] = {}
            queue = queue + [node[""left""]]
            queue = queue + [node[""right""]]
        end
    end
    return root
end



func test
    tree := buildBinaryTree [""a"" ""b"" ""c""]
    assertEqual ""a"" tree[""val""]
    assertEqual ""b"" tree[""left""].({}any)[""val""]
    assertEqual ""c"" tree[""right""].({}any)[""val""]
    tree2 := buildBinaryTree [1 2 3]
    assertEqual 1 tree2[""val""]
    assertEqual 2 tree2[""left""].({}any)[""val""]
    assertEqual 3 tree2[""right""].({}any)[""val""]
    tree3 := buildBinaryTree [""a""]
    assertEqual ""a"" tree3[""val""]
end
",
0198-house-robber.evy,"// 198. House Robber
// Solved
// Medium
// Topics
// Companies
// You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.
// Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.
// Example 1:
// Input: nums = [1,2,3,1]
// Output: 4
// Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
// Total amount you can rob = 1 + 3 = 4.
// Example 2:
// Input: nums = [2,7,9,3,1]
// Output: 12
// Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
// Total amount you can rob = 2 + 9 + 1 = 12.
// Constraints:
// 1 <= nums.length <= 100
// 0 <= nums[i] <= 400

func rob:num nums:[]num
    n := len nums
    max_steal := nums
    if n > 1
        max_steal[1] = max nums[0] nums[1]
    end
    for i := range 2 n
        max_steal[i] = max (max_steal[i - 1]) (max_steal[i - 2] + nums[i])
    end
    return max_steal[-1]
end



func test
    assertEqual 4 (rob [1 2 3 1])
    assertEqual 12 (rob [2 7 9 3 1])
end
",
0567-permutation-in-string.evy,"// 567. Permutation in String
// Solved
// Medium
// Topics
// Companies
// Hint
// Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.
// In other words, return true if one of s1's permutations is the substring of s2.
// Example 1:
// Input: s1 = ""ab"", s2 = ""eidbaooo""
// Output: true
// Explanation: s2 contains one permutation of s1 (""ba"").
// Example 2:
// Input: s1 = ""ab"", s2 = ""eidboaoo""
// Output: false
// Constraints:
// 1 <= s1.length, s2.length <= 104
// s1 and s2 consist of lowercase English letters.

func checkInclusion:bool s1:string s2:string
    if (len s1) > (len s2)
        return false
    end
    s1count:{}num
    s2count:{}num
    for i := range (len s1)
        if !(has s1count s1[i])
            s1count[s1[i]] = 0
            s2count[s2[i]] = 0
        end
        s1count[s1[i]] = s1count[s1[i]] + 1
        s2count[s2[i]] = s2count[s2[i]] + 1
    end
    l := 0
    while l + (len s1) < (len s2)
        if s1count == s2count
            return true
        end
        start := s2[l] // The character at the start of the current window. To be removed
        finish := s2[l + (len s1)] // the character after the end of the current window. To be added
        s2count[start] = s2count[start] - 1
        if s2count[start] == 0
            del s2count start
        end
        if !(has s2count finish)
            s2count[finish] = 0
        end
        s2count[finish] = s2count[finish] + 1
        l = l + 1
    end
    return s1count == s2count
end

func test
    assertEqual true (checkInclusion ""ab"" ""ab"")
    assertEqual true (checkInclusion ""ab"" ""eidbaooo"")
    assertEqual false (checkInclusion ""ab"" ""eidboaoo"")
    assertEqual false (checkInclusion ""ab"" ""a"")
end
",
0509-fibonacci-number.evy,"// 509. Fibonacci Number
// Easy
// Topics
// Companies
// The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,
// F(0) = 0, F(1) = 1
// F(n) = F(n - 1) + F(n - 2), for n > 1.
// Given n, calculate F(n).
// Example 1:
// Input: n = 2
// Output: 1
// Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.
// Example 2:
// Input: n = 3
// Output: 2
// Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.
// Example 3:
// Input: n = 4
// Output: 3
// Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.
// Constraints:
// 0 <= n <= 30

func fibonacci:num n:num
    zero := 0
    one := 1
    for range 1 n
        tmp := one
        one = one + zero
        zero = tmp
    end
    return one
end

func test
    assertEqual 1 (fibonacci 2)
    assertEqual 2 (fibonacci 3)
    assertEqual 3 (fibonacci 4)
end
",
0003-longest-substring-without-repeating-characters.evy,"// 3. Longest Substring Without Repeating Characters
// Solved
// Medium
// Topics
// Companies
// Given a string s, find the length of the longest
// substring without repeating characters.
// Example 1:
// Input: s = ""abcabcbb""
// Output: 3
// Explanation: The answer is ""abc"", with the length of 3.
// Example 2:
// Input: s = ""bbbbb""
// Output: 1
// Explanation: The answer is ""b"", with the length of 1.
// Example 3:
// Input: s = ""pwwkew""
// Output: 3
// Explanation: The answer is ""wke"", with the length of 3.
// Notice that the answer must be a substring, ""pwke"" is a subsequence and not a substring.
// Constraints:
// 0 <= s.length <= 5 * 104
// s consists of English letters, digits, symbols and spaces.

func lengthOfLongestSubstring:num s:string
    seen:{}num
    longestsubstring := 0
    startIdx := 0
    for i := range (len s)
        elem := s[i]
        if has seen elem
            startIdx = max startIdx (seen[elem] + 1)
        end
        seen[elem] = i
        longestsubstring = max longestsubstring (i - startIdx + 1)
    end
    return longestsubstring
end

func test
    assertEqual 3 (lengthOfLongestSubstring ""abcabcbb"")
    assertEqual 1 (lengthOfLongestSubstring ""bbbbb"")
    assertEqual 3 (lengthOfLongestSubstring ""pwwkew"")
end
",
0217-contains-duplicate.evy,"// 217. Contains Duplicate
// Solved
// Easy
// Topics
// Companies
// Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.
// Example 1:
// Input: nums = [1,2,3,1]
// Output: true
// Example 2:
// Input: nums = [1,2,3,4]
// Output: false
// Example 3:
// Input: nums = [1,1,1,3,3,4,3,2,4,2]
// Output: true

func containsDuplicate:bool nums:[]num
    seen := {}
    for ii := range nums
        i := sprint ii
        if has seen i
            return true
        end
        seen[i] = true
    end
    return false
end

func test
    assertEqual true (containsDuplicate [1 2 3 1])
    assertEqual false (containsDuplicate [1 2 3 4])
    assertEqual true (containsDuplicate [1 1 1 3 3 4 3 2 4 2])
end
",
0412-fizz-buzz.evy,"// 412. Fizz Buzz
// Easy
// Topics
// Companies
// Given an integer n, return a string array answer (1-indexed) where:
// answer[i] == ""FizzBuzz"" if i is divisible by 3 and 5.
// answer[i] == ""Fizz"" if i is divisible by 3.
// answer[i] == ""Buzz"" if i is divisible by 5.
// answer[i] == i (as a string) if none of the above conditions are true.
// Example 1:
// Input: n = 3
// Output: [""1"",""2"",""Fizz""]
// Example 2:
// Input: n = 5
// Output: [""1"",""2"",""Fizz"",""4"",""Buzz""]
// Example 3:
// Input: n = 15
// Output: [""1"",""2"",""Fizz"",""4"",""Buzz"",""Fizz"",""7"",""8"",""Fizz"",""Buzz"",""11"",""Fizz"",""13"",""14"",""FizzBuzz""]
// Constraints:
// 1 <= n <= 104

func fizzbuzz:[]string n:num
    ans:[]string
    for i := range 1 (n + 1)
        s:string
        if i % 3 == 0
            s = s + ""Fizz""
        end
        if i % 5 == 0
            s = s + ""Buzz""
        end
        if s == """"
            s = sprintf ""%v"" i
        end
        ans = ans + [s]
    end
    return ans
end

func test
    assertEqual [""1"" ""2"" ""Fizz""] (fizzbuzz 3)
    assertEqual [""1"" ""2"" ""Fizz"" ""4"" ""Buzz""] (fizzbuzz 5)
    assertEqual [""1"" ""2"" ""Fizz"" ""4"" ""Buzz"" ""Fizz"" ""7"" ""8"" ""Fizz"" ""Buzz"" ""11"" ""Fizz"" ""13"" ""14"" ""FizzBuzz""] (fizzbuzz 15)
end
",
f70374938ed4795d168e995524aeabe6d04b8859.evy,"print (""check this file"")","# a = 2
print(""check this file"")
"
f7245a27daac0be722083cf7badfe71aa73117d0.evy,"func test_import
    //""
    //    Testing import of torsionfit.
    //    ""
    
end","#!/usr/bin/python

def test_import():
    """"""
    Testing import of torsionfit.
    """"""
    import torsionfit
"
f707edd2b040f0802a1354f8b3a12e88d8aee693.evy,"print (""Hello, World."")","print('Hello, World.')

# CONSOLE OUTPUT:
# Hello, World.
"
f723cc233a58a2785fb04f6b38b7dd40a29e256b.evy,"func test_import_index
    //""
    //    Try to import the indexd package.
    //    ""
    
end","def test_import_index():
    '''
    Try to import the indexd package.
    '''
    import indexd
"
f70737fd5fb974627c90224cc451b628fa286ec7.evy,"for num_ := range 1 51 
    if (((num_ % 3) == 0) and ((num_ % 5) == 0))
        print (""fizzbuzz"")
    else if (((num_ % 3) == 0) and ((num_ % 5) != 0))
        print (""fizz"")
    end
end","for num in range(1, 51):

    if num % 3 == 0 and num % 5 == 0:
        print(""fizzbuzz"")

    elif num % 3 == 0 and num % 5 != 0:
        print(""fizz"")

    elif num % 3 != 0 and num % 5 == 0:
        print(""buzz"")

    else:
        print(num)"
f716d8668d7f3e71327a13ddba27d41f18e2ef20.evy,"func calc_shipping
    print (""calc shipping"")
end","def calc_shipping():
    print(""calc shipping"")

"
f7026a4ae9f688521225dfaaa410970f7fe1bab1.evy,"for n := range 1 101 
    print (n) (""Я не буду їсти палички Бобо на уроці"")
end","# 7 завдання
for n in range(1, 101):
    print(n, ""Я не буду їсти палички Бобо на уроці"")
"
f725c5e76c999a9a4e9b18abb24d8c6a364d2b89.evy,"print (""second = hour * 60 * 60"")","print(""second = hour * 60 * 60"")
"
f72779dd707f715614f9cebb5334c248393f7004.evy,"print ((4 + 3))
print ((4 - 3))
print ((4 * 3))
print ((pow 4 3))
print ((4 / 3))","# 03 operator

print(4+3)
print(4-3)
print(4*3)
print(4 ** 3)  # 这个小学没学
print(4/3)
"
f7098cc1020c0449102ed02912eddc4ceb9787ee.evy,"func hello_world
    print (""Hello World"")
end","import this


def hello_world():
    print(""Hello World"")
"
f726df462e44abc76e9c11946685af130da6d59c.evy,"func Main:bool  a:bool  b:bool
    return (a == b)
end","from boa3.builtin import public


@public
def Main(a: bool, b: bool) -> bool:
    return a == b
"
f7285294d2a931523127fa75c792a0d89962c046.evy,"while (1 == 1)
    
end",
f71eb1bcceacb04d1e517066e97c304ca359d409.evy,"kwh_used := 1000
out := 0
if (kwh_used < 500)
    out = out + (500 * 0.45)
else if ((kwh_used >= 500) and (kwh_used < 1500))
    out = out + ((500 * 0.45) + ((kwh_used - 500) * 0.74))
end
out = out + (out * 0.2)
print (out)","kwh_used = 1000
out = 0

if(kwh_used < 500):
    out += 500 * 0.45
elif(kwh_used >= 500 and kwh_used < 1500):
    out += 500 * 0.45 + ((kwh_used - 500) * 0.74)
elif(kwh_used >= 1500 and kwh_used < 2500):
    out += 500 * 0.45 + ((kwh_used - 500) * 0.74) + ((kwh_used - 1500) * 1.25)
elif(kwh_used >= 2500):
    out += 500 * 0.45 + ((kwh_used - 500) * 0.74) + ((kwh_used - 1500) * 1.25) + ((kwh_used - 2500) * 2)
    
out += out * 0.2
print(out)"
f7043dd4a34f458d08244ea0a3dea781fe8dba49.evy,"print (""Hello Github!"")","print(""Hello Github!"")

"
f71e4ba69c62e1f2c427e125b8d3019de0eb2970.evy,"print (""I am having a try."")","print(""I am having a try."")
"
f701dd084a73bcb11656e05d04be88875e0a57a1.evy,"func test_abs
    //"" Unit test for abs() ""
    failure := false
    if !failure
        print (""SUCESS"")
    end
end
print (""Testing abs()..."")
test_abs","#!/usr/bin/env python3
from Lect7 import *
def test_abs():
  """""" Unit test for abs() """"""
  failure = False

  if not failure:
    print('SUCESS')

print('Testing abs()...')
test_abs()
"
f70dd7f719724433fbd2b992f920c229ba32ff63.evy,"print (""We Created Sub_Package for Numbers"")","print(""We Created Sub_Package for Numbers"")
"
f7044425b96c1b1b74a77404d1717095d1e2e08e.evy,"year := 1
millimeter := 1.6
while (year <= 25)
    years := (year * millimeter)
    print ("" The ocean will rises each year is="") (years)
    year = year + 1
end","#Question No 6
#Risen Each Year For Next 25 Years
year =1 
millimeter= 1.6
while(year<=25):
  years=(year * millimeter)
  print("" The ocean will rises each year is="" , years,)
  year+=1"
f70211c77ad9a61fdf5449a9356c32742a4ff109.evy,"func Print
    print (""you may want to install beautifulsoup4,not beautfulsoup4"")
end","def Print():
    print('you may want to install beautifulsoup4,not beautfulsoup4')
"
f70ab361101331e9cbcc4a524b6be7427a7c3df4.evy,"func test_something
    assert (1 == 1)
end","def test_something():
    assert 1 == 1
"
vars.evy,"main(){

}

","message = ""Hello, Python!""
counter = 42
price = 19.99
is_active = True
print(message, counter, price, is_active)
"
dict.evy,"main(){

}

","person = {""name"": ""Bob"", ""age"": 30, ""city"": ""New York""}
print(person[""name""])
person[""age""] = 31
print(person)
"
lists.evy,"main(){

}

","fruits = [""apple"", ""banana"", ""orange""]
print(fruits[0])
fruits.append(""grape"")
print(fruits)
"
control.evy,"main(){
age = 25
count = 0
}

","age = 25
if age >= 18:
    print(""You are an adult."")
else:
    print(""You are a minor."")
count = 0
while count < 5:
    print(count)
    count += 1
"
arithmetic.evy,"main(){
x = 10
y = 5
}

","x = 10
y = 5
print(x + y)
print(x - y)
print(x * y)
print(x / y)
print(x % y)
"
loops.evy,"main(){

}

","for i in range(5):
    print(""for"", i)

count = 0
while count < 5:
    print(""while"", count)
    count += 1

for i in range(1, 4):
    for j in range(1, 4):
        if i != j:
            print(f""({i}, {j})"")
"
functions.evy,"main(){

}

greet(name){

}

concat(a, b){

}

calculateArea(length, width){

}

","def greet(name):
    print(""Hello,"", name)
greet(""Alice"")

def concat(a: str, b: str) -> str:
    return a + b

a = ""foo""
b = ""bar""
print(concat(a, b))

def calculate_area(length, width):
    area = length * width
    return area

result = calculate_area(5, 8)
print(""Area of the rectangle:"", result)"
logical.evy,"main(){

}

","x = 10
y = 5
print(x > y)
print(x < y)
print(x == y)
print(x != y)
print(x > 5 and y < 10)
print(x > 5 or y > 10)
print(not (x > 5))
"
bools.evy,"main(){
x = 10
y = 5
}

","x = 10
y = 5
print(x > y)
print(x < y)
print(x == y)
print(x != y)
print(x > 5 and y < 10)
print(x > 5 or y > 10)
print(not (x > 5))
"
