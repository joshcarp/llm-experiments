
func KthLargest:{}any k:num nums:[]num
    self:{}any
    self.nums = nums
    self.k = k
    // build min heap
    heapify self.nums
    // remove n - k smallest number
    while (len self.nums) > k
        heappop self.nums
    end
    return self
end

func add:num self:{}any val:num
    // add to heaq if it's less then k
    if (len self.nums) < self.k
        heappush self.nums val
    else if val > self.nums[0]
        // if len(heaq) == k, and val greater than smallest num
        // then pop smallest num than add val to heap
        heapreplace self.nums val
    end
    // return k largest
    return self.nums[0]
end

func heapify arr:[]num
    for i := range (floor (len arr)/2)-1 -1 -1
        heapifyDown arr i (len arr)
    end
end

func heapifyDown arr:[]num i:num n:num
    left := 2 * i + 1
    right := 2 * i + 2
    smallest := i
    if left < n and arr[left] < arr[smallest]
        smallest = left
    end
    if right < n and arr[right] < arr[smallest]
        smallest = right
    end
    if smallest != i
        tmp := arr[i]
        arr[i] = arr[smallest]
        arr[smallest] = tmp
        heapifyDown arr smallest n
    end
end

func heappush arr:[]num val:num
    arr = arr + [val]
    heapifyUp arr (len arr)-1
end

func heapifyUp arr:[]num i:num
    parent := floor (i-1)/2
    while i > 0 and arr[i] < arr[parent]
        tmp := arr[i]
        arr[i] = arr[parent]
        arr[parent] = tmp
        i = parent
        parent = floor (i-1)/2
    end
end

func heappop:[]num arr:[]num
    if (len arr) == 0
        return arr
    end
    result := arr[0]
    arr[0] = arr[-1]
    arr = arr[:-1]
    heapifyDown arr 0 (len arr)
    return arr
end

func heapreplace:[]num arr:[]num val:num
    result := heappop arr
    heappush arr val
    return arr
end

func test
    k := 3
    nums := [4 5 8 2]
    obj := (KthLargest k nums)
    assert 4 (add obj 3)
    assert 5 (add obj 5)
    assert 5 (add obj 10)
    assert 5 (add obj 9)
    assert 8 (add obj 4)
end
test
