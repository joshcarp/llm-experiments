
import math
import random
from typing import Any

from .hill_climbing import SearchProblem


func simulated_annealing:any (
    search_prob:any,
    find_max:bool = true,
    max_x:num = math.inf,
    min_x:num = -math.inf,
    max_y:num = math.inf,
    min_y:num = -math.inf,
    visualization:bool = false,
    start_temperate:num = 100,
    rate_of_decrease:num = 0.01,
    threshold_temp:num = 1,
)
    search_end := false
    current_state := search_prob
    current_temp := start_temperate
    scores := []
    iterations := 0
    best_state := none

    while !search_end
        current_score := current_state.score()
        if best_state == none or current_score > best_state.score()
            best_state = current_state
        end
        scores = scores + [current_score]
        iterations = iterations + 1
        next_state := none
        neighbors := current_state.get_neighbors()
        while next_state == none and neighbors != []
            index := random.randint 0 (len neighbors - 1)
            picked_neighbor := neighbors[index]
            change := picked_neighbor.score() - current_score

            if picked_neighbor.x > max_x or picked_neighbor.x < min_x or picked_neighbor.y > max_y or picked_neighbor.y < min_y
                continue
            end

            if !find_max
                change = change * -1
            end
            if change > 0
                next_state = picked_neighbor
            else
                probability := (math.e) ^ (change / current_temp)
                if random.random() < probability
                    next_state = picked_neighbor
                end
            end
        end
        current_temp = current_temp - (current_temp * rate_of_decrease)

        if current_temp < threshold_temp or next_state == none
            search_end = true
        else
            current_state = next_state
        end
    end

    if visualization
        import matplotlib.pyplot as plt
        plt.plot (range iterations) scores
        plt.xlabel "Iterations"
        plt.ylabel "Function values"
        plt.show()
    end
    return best_state
end


func main
    func test_f1:num x:num y:num
        return (x ^ 2) + (y ^ 2)
    end

    prob := SearchProblem x:12 y:47 step_size:1 function_to_optimize:test_f1
    local_min := simulated_annealing prob find_max:false max_x:100 min_x:5 max_y:50 min_y:-5 visualization:true
    print "The minimum score for f(x, y) = x^2 + y^2 with the domain 100 > x > 5 " "and 50 > y > - 5 found via hill climbing: " (local_min.score())

    prob := SearchProblem x:12 y:47 step_size:1 function_to_optimize:test_f1
    local_min := simulated_annealing prob find_max:true max_x:100 min_x:5 max_y:50 min_y:-5 visualization:true
    print "The maximum score for f(x, y) = x^2 + y^2 with the domain 100 > x > 5 " "and 50 > y > - 5 found via hill climbing: " (local_min.score())

    func test_f2:num x:num y:num
        return (3 * x ^ 2) - (6 * y)
    end

    prob := SearchProblem x:3 y:4 step_size:1 function_to_optimize:test_f1
    local_min := simulated_annealing prob find_max:false visualization:true
    print "The minimum score for f(x, y) = 3*x^2 - 6*y found via hill climbing: " (local_min.score())

    prob := SearchProblem x:3 y:4 step_size:1 function_to_optimize:test_f1
    local_min := simulated_annealing prob find_max:true visualization:true
    print "The maximum score for f(x, y) = 3*x^2 - 6*y found via hill climbing: " (local_min.score())
end
test
